<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 4.2.1"><script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"><style>.pace .pace-progress{background:#1e92fb;height:3px}.pace .pace-progress-inner{box-shadow:0 0 10px #1e92fb,0 0 5px #1e92fb}.pace .pace-activity{border-top-color:#1e92fb;border-left-color:#1e92fb}</style><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"www.bluedawn1.space",root:"/",scheme:"Gemini",version:"7.7.1",exturl:!1,sidebar:{position:"left",width:240,display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:null},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="1.1 线性表的类型定义线性表：简单来说，一个线性表是n个数据元素的有限序列。记录：数据元素（由若干个数据项组成的那些数据元素）。文件：含有大量记录的线性表。线性表的长度：即线性表中元素的个数。位序：元素$a_i$是线性表L的第i个元素，则称i为$a_i$在L中的位序。同一线性表中的元素是同一数据对象（即具有相同的特性），并相邻的数据元素之间具有序偶关系。若将线性表记为$L&#x3D;(a_1,a_2,…,"><meta property="og:type" content="article"><meta property="og:title" content="数据结构笔记_1"><meta property="og:url" content="http://www.bluedawn1.space/2020/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0_1/index.html"><meta property="og:site_name" content="不羁"><meta property="og:description" content="1.1 线性表的类型定义线性表：简单来说，一个线性表是n个数据元素的有限序列。记录：数据元素（由若干个数据项组成的那些数据元素）。文件：含有大量记录的线性表。线性表的长度：即线性表中元素的个数。位序：元素$a_i$是线性表L的第i个元素，则称i为$a_i$在L中的位序。同一线性表中的元素是同一数据对象（即具有相同的特性），并相邻的数据元素之间具有序偶关系。若将线性表记为$L&#x3D;(a_1,a_2,…,"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://img-blog.csdnimg.cn/20200908231321251.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JsdWVfZGF3bg==,size_16,color_FFFFFF,t_70#pic_center"><meta property="og:image" content="https://img-blog.csdnimg.cn/20200908231212199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JsdWVfZGF3bg==,size_16,color_FFFFFF,t_70#pic_center"><meta property="og:image" content="https://img-blog.csdnimg.cn/20200908213528656.png#pic_center"><meta property="article:published_time" content="2020-09-10T04:46:49.000Z"><meta property="article:modified_time" content="2020-09-10T13:47:26.408Z"><meta property="article:author" content="blue_dawn"><meta property="article:tag" content="考研"><meta property="article:tag" content="数据结构"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://img-blog.csdnimg.cn/20200908231321251.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JsdWVfZGF3bg==,size_16,color_FFFFFF,t_70#pic_center"><link rel="canonical" href="http://www.bluedawn1.space/2020/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0_1/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0}</script><title>数据结构笔记_1 | 不羁</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">不羁</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">仰天大笑出门去, 我辈岂是蓬蒿人</p></div><div class="site-nav-right"></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a></li><li class="menu-item menu-item-notes"><a href="/notes" rel="section"><i class="fa fa-fw fa-fas fa-book"></i>notes</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="site-search"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"></div></div><div class="search-pop-overlay"></div></div></div></header><div class="reading-progress-bar"></div><a href="https://github.com/bluedawn520" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://www.bluedawn1.space/2020/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0_1/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="blue_dawn"><meta itemprop="description" content="清风徐来, 水波不兴"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="不羁"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">数据结构笔记_1</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-09-10 12:46:49 / 修改时间：21:47:26" itemprop="dateCreated datePublished" datetime="2020-09-10T12:46:49+08:00">2020-09-10</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E8%80%83%E7%A0%94/" itemprop="url" rel="index"><span itemprop="name">考研</span> </a></span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E8%80%83%E7%A0%94/%E4%B8%93%E4%B8%9A%E8%AF%BE/" itemprop="url" rel="index"><span itemprop="name">专业课</span> </a></span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E8%80%83%E7%A0%94/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span> </a></span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">计算机</span> </a></span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span> </a></span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>16k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>14 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><a id="more"></a><hr><h1 id="1-1-线性表的类型定义"><a href="#1-1-线性表的类型定义" class="headerlink" title="1.1 线性表的类型定义"></a>1.1 线性表的类型定义</h1><p><strong>线性表</strong>：简单来说，一个线性表是n个数据元素的有限序列。</p><p><strong>记录</strong>：数据元素（由若干个数据项组成的那些数据元素）。</p><p><strong>文件</strong>：含有大量记录的线性表。</p><p><strong>线性表的长度</strong>：即线性表中元素的个数。</p><p><strong>位序</strong>：元素$a_i$是线性表L的第i个元素，则称i为$a_i$在L中的位序。</p><blockquote><p>同一线性表中的元素是同一数据对象（即具有相同的特性），并<strong>相邻</strong>的数据元素之间具有<strong>序偶关系</strong>。若将线性表记为$L=(a_1,a_2,…,a_n)$，则除了第一个数据元素以外其余的都具有一个<strong>直接前驱</strong>，除了最后一个数据元素以外其余的都具有一个<strong>直接后继</strong>。</p></blockquote><p><strong>抽象数据类型线性表的定义：</strong><br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">ATD List&#123;</span><br><span class="line">    数据对象：D = &#123;ai | ai∈Elemset，i=<span class="number">1</span>,...,n, n&gt;=<span class="number">0</span>&#125;</span><br><span class="line">    数据关系：R1 = &#123;&lt;ai<span class="number">-1</span>,ai&gt; | ai<span class="number">-1</span>,ai∈D，i=<span class="number">1</span>,...,n&#125;</span><br><span class="line">    基本操作：</span><br><span class="line">        InitList(&amp;L)</span><br><span class="line">        操作结果：构造了一个空的线性表L。</span><br><span class="line">        DestroyList(&amp;L)</span><br><span class="line">        初始条件：线性表L已存在。</span><br><span class="line">        操作结果：销毁线性表L。</span><br><span class="line">        ClearList(&amp;L)</span><br><span class="line">        初始条件：线性表L已存在。</span><br><span class="line">        操作结果：将线性表L置为空表。</span><br><span class="line">        ListEmpty(L)</span><br><span class="line">        初始条件：线性表L已存在。</span><br><span class="line">        操作结果：若L为空表，则返回True，否则返回False。</span><br><span class="line">        ListLength(L)</span><br><span class="line">        初始条件：线性表L已存在。</span><br><span class="line">        操作结果：返回线性表元素个数。</span><br><span class="line">        GetElem(L, i, &amp;e)</span><br><span class="line">        初始条件：线性表L已存在，<span class="number">1</span>&lt;= i &lt;=ListLength(L)。</span><br><span class="line">        操作结果：用e返回L中第i个元素。</span><br><span class="line">        LocateElem(L, e, compare())</span><br><span class="line">        初始条件：线性表L已存在，compare()是数据元素的判别函数。</span><br><span class="line">        操作结果：返回L中第一个与e满足compare()关系的数据元素的位序，若不存在，返回<span class="number">0</span>。</span><br><span class="line">        PriorElem(L, curr_e, &amp;pre_e)</span><br><span class="line">        初始条件：线性表L已存在。</span><br><span class="line">        操作结果：若curr_e是L的元素且不是第一个，则用pre_e返回其的前驱，否则操作失败，pre_e无定义。</span><br><span class="line">        NextElem(L, curr_e, &amp;next_e)</span><br><span class="line">        初始条件：线性表L已存在。</span><br><span class="line">        操作结果：若curr_e是L的元素且不是最后一个，则用next_e返回其的后继，则操作失败，next_e无定义。</span><br><span class="line">        ListInsert(&amp;L, i, e)</span><br><span class="line">        初始条件：线性表L已存在，<span class="number">1</span>&lt;= i &lt;=ListLength(L)+<span class="number">1</span>。</span><br><span class="line">        操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加<span class="number">1</span>。</span><br><span class="line">        ListDelete(&amp;L, i, &amp;e)</span><br><span class="line">        初始条件：线性表L已存在且非空，<span class="number">1</span>&lt;= i &lt;=ListLength(L)。</span><br><span class="line">        操作结果：删除L的第i个元素，用e返回其，L的长度减<span class="number">1</span>。</span><br><span class="line">        ListTraverse(L, visit())</span><br><span class="line">        初始条件：线性表L已存在。</span><br><span class="line">        操作结果：依次对L的每个元素进行visit()操作,一旦visit()失败，则操作失败。        </span><br><span class="line">&#125;ADT List</span><br></pre></td></tr></table></figure><p></p><blockquote><p>eg1.若两个线性表LA、LB分别表示两个结合A、B，则求线性表LC表示集合C=A∪B。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(List &amp;La, List Lb)</span></span>&#123;</span><br><span class="line">    <span class="comment">//将所有在Lb中但不在La中的数据元素插入到La中</span></span><br><span class="line">    La_len = ListLength(La);</span><br><span class="line">    Lb_len = ListLength(Lb);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt;= Lb_len; i++)&#123;</span><br><span class="line">        GetElem(Lb, i, e);</span><br><span class="line">        <span class="keyword">if</span>(LocateElem(La, e, equal))&#123;</span><br><span class="line">            ListInsert(La, ++La_len, e);        <span class="comment">//++在前表示先自增再赋值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//union</span></span><br></pre></td></tr></table></figure><blockquote><p>eg2.若LA、LB中的数据元素的按值非递减有序排列，则将LA、LB归并后的线性表LC依然保持值非递减有序排列。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeList</span><span class="params">(List La, List Lb, List &amp;Lc)</span></span>&#123;</span><br><span class="line">    <span class="comment">//已知线性表La和Lb中的数据元素按值非递减有序排列</span></span><br><span class="line">    <span class="comment">//将La和Lb归并后的线性表Lc中的元素也是按值非递减有序排列</span></span><br><span class="line">    InitList(Lc);</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>, j=<span class="number">1</span>, k=<span class="number">0</span>;</span><br><span class="line">    La_len = ListLength(La);</span><br><span class="line">    Lb_len = ListLength(Lb);</span><br><span class="line">    <span class="keyword">while</span>((i &lt;= La_len) &amp;&amp; (j &lt;= Lb_len))&#123;</span><br><span class="line">        GetElem(La, i, ai);</span><br><span class="line">        GetElem(Lb, j, bj);</span><br><span class="line">        <span class="keyword">if</span>(ai &lt;= bj)&#123;</span><br><span class="line">            ListInsert(Lc, ++k, ai); i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ListInsert(Lc, ++k, bj); j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= La_len)&#123;</span><br><span class="line">        GetElem(La, i++, ai);</span><br><span class="line">        ListInsert(Lc, ++k, ai);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= Lb_len)&#123;</span><br><span class="line">        GetElem(Lb, j++, bj);</span><br><span class="line">        ListInsert(Lc, ++k, bj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//MergeList</span></span><br></pre></td></tr></table></figure><hr><h1 id="1-2-线性表的顺序表示和实现"><a href="#1-2-线性表的顺序表示和实现" class="headerlink" title="1.2 线性表的顺序表示和实现"></a>1.2 线性表的顺序表示和实现</h1><p><strong>顺序表</strong>（顺序表示的线性表）：用一组<strong>地址连续</strong>的存储单元存储线性表的数据元素。</p><p><strong>基地址</strong>（起始地址）：线性表的第一个数据元素的存储地址。</p><blockquote><p>第$i$个元素的地址：$Loc(a_i) = Loc(a_1) + (i-1)<em>l$。<br>$Loc(a_1)$是基地址，$l$是单个数据元素所占的存储单元。<br>因此，线性表的<strong>顺序存储结构</strong>是一种<em>*随机存取</em></em>的存储结构。</p><p>// 由于高级程序语言中的数组类型具有随机存取的特性，因此通常以数组来描述顺序存储结构。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-----------线性表动态分配的顺序存储结构-----------</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_INIT_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTINCREMENT 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType *elem;     <span class="comment">//存储空间的基址</span></span><br><span class="line">    <span class="keyword">int</span> length;         <span class="comment">//当前的长度</span></span><br><span class="line">    <span class="keyword">int</span> listsize;       <span class="comment">//当前分配的存储容量（以sizeof(ElemType)为单位）</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function">Status <span class="title">InitList_Sq</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">        <span class="comment">//构造一个空的线性表L</span></span><br><span class="line">        L.elem = (ElemType*)<span class="built_in">malloc</span>(LIST_INIT_SIZE * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">        <span class="keyword">if</span>(!L.elem) <span class="built_in">exit</span>(overflow);         <span class="comment">//存储失败</span></span><br><span class="line">        L.length = <span class="number">0</span>;                       <span class="comment">//空表长度为0</span></span><br><span class="line">        L.listsize = LIST_INIT_SIZE;        <span class="comment">//初始存储容量</span></span><br><span class="line">    &#125;<span class="comment">//InitList_Sq</span></span><br><span class="line">    <span class="function">Status <span class="title">ListInsert_Sq</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i, ElemType e)</span></span>&#123;</span><br><span class="line">        <span class="comment">//在顺序表L的第i个位置插入新的数据元素</span></span><br><span class="line">        <span class="comment">//i的合法值为 1&lt;= i &lt;=L.length +1</span></span><br><span class="line">        <span class="keyword">if</span>((i&lt;<span class="number">1</span>)||(i&gt;L.length+<span class="number">1</span>))   <span class="keyword">return</span> ERROR;</span><br><span class="line">        <span class="keyword">if</span>(L.length &gt;= L.listsize)&#123;</span><br><span class="line">            newbase = (ElemType*)<span class="built_in">malloc</span>((L.listsize + LISTINCREMENT)*<span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">            <span class="keyword">if</span>(!newbase) <span class="built_in">exit</span>(overflow);</span><br><span class="line">            L.elem = newbase;</span><br><span class="line">            L.listsize += LISTINCREMENT;</span><br><span class="line">        &#125;</span><br><span class="line">        q = &amp;(L.elem[i<span class="number">-1</span>]);                 <span class="comment">//指针q、p</span></span><br><span class="line">        <span class="keyword">for</span>(p=&amp;(L.elem[L.length<span class="number">-1</span>]); p&gt;=q; p--)&#123;</span><br><span class="line">            *(p+<span class="number">1</span>) = *p;</span><br><span class="line">        &#125;</span><br><span class="line">        *q = e;</span><br><span class="line">        ++L.length;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;<span class="comment">//ListInsert_Sq</span></span><br><span class="line">    <span class="function">Status <span class="title">ListDelete_sq</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i, ElemType &amp;e)</span></span>&#123;</span><br><span class="line">        <span class="comment">//在顺序表L中删除第i位置的数据元素</span></span><br><span class="line">        <span class="comment">//i的合法值为1&lt;= i &lt;=L.length</span></span><br><span class="line">        <span class="keyword">if</span>((i&lt;<span class="number">1</span>)||(i&gt;L.length)) <span class="keyword">return</span> ERROR;</span><br><span class="line">        p = &amp;(L.elem[i<span class="number">-1</span>]);</span><br><span class="line">        e = *p;</span><br><span class="line">        q = &amp;(L.elem[L.length<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(p++; p&lt;=q; p++)&#123;</span><br><span class="line">            *(p<span class="number">-1</span>) = *p;</span><br><span class="line">        &#125;</span><br><span class="line">        L.length--;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;<span class="comment">//ListDelete_sq</span></span><br><span class="line">``` </span><br><span class="line">&gt; - 顺序表在某位置上的删除和插入操作时间主要消耗在移动元素上。</span><br><span class="line">&gt; - 假设$P_i$是顺序表L在第i个元素之前插入一个元素的概率，则在长度为n的线性链表L中插入一个元素需要移动的次数期望为$∑_1^&#123;n+<span class="number">1</span>&#125; [Pi*(n-i+<span class="number">1</span>)]$。</span><br><span class="line">&gt; - 假设$Q_i$是顺序表L删除第i个元素的概率，则在长度为n的L中删除一个元素需要移动的次数期望为$∑_1^&#123;n&#125;[Qi*(n-i)]$。</span><br><span class="line">&gt; - 不失一般性，若$Pi、Qi$是等概率的，则插入和删除分别平均移$\frac&#123;n&#125;&#123;<span class="number">2</span>&#125;、 \frac&#123;n<span class="number">-1</span>&#125;&#123;<span class="number">2</span>&#125;$。则ListInsert_Sq和ListDelete_sq的时间复杂度为$O(n)$。</span><br><span class="line">    </span><br><span class="line">&gt; <span class="comment">// 函数指针：指向函数的指针；</span></span><br><span class="line">    <span class="comment">// 指针函数：返回值是一个指针的函数；</span></span><br><span class="line">```cpp</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem_Sq</span><span class="params">(SqList L, ElemType e, Status (*compare)(ElemType,ElemType))</span></span>&#123;</span><br><span class="line">    <span class="comment">//在顺序表L中查找与e满足compare()的元素的位序</span></span><br><span class="line">    <span class="comment">//若找到，则返回对应位序，否则返回0</span></span><br><span class="line">    i = <span class="number">1</span>;</span><br><span class="line">    p = L.elem;</span><br><span class="line">    <span class="keyword">while</span>((i&lt;=L.length)&amp;&amp;!(compare(*p++,e)))    i++;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;=L.length) <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">else</span>    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//LocateElem_Sq</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeList_Sq</span><span class="params">(SqList La, SqList Lb, SqList &amp;Lc)</span></span>&#123;</span><br><span class="line">    <span class="comment">//已知顺序表La、Lb的数据元素按值非递减有序排列</span></span><br><span class="line">    <span class="comment">//归并后的顺序表Lc的数据元素也按值非递减有序排列</span></span><br><span class="line">    pa = La.elem;</span><br><span class="line">    pb = Lb.elem;</span><br><span class="line">    Lc.listsize = Lc.length = La.length + Lb.length;</span><br><span class="line">    pc = Lc.elem = (ElemType*)<span class="built_in">malloc</span>(Lc.listsize * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">    <span class="keyword">if</span>(!Lc.elem)    <span class="built_in">exit</span>(overflow);</span><br><span class="line">    pa_last = La.elem + La.length - <span class="number">1</span>;</span><br><span class="line">    pb_last = Lb.elem + Lb.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>((pa&lt;=pa_last)&amp;&amp;(pb&lt;=pb_last))&#123;</span><br><span class="line">        <span class="keyword">if</span>(*pa &lt;= *pb)  *pc++ = *pa++;</span><br><span class="line">        <span class="keyword">else</span>    *pc++ = *pb++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(pa&lt;=pa_last)  *pc++ = *pa++;</span><br><span class="line">    <span class="keyword">while</span>(pb&lt;=pb_last)  *pc++ = *pb++;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">//MergeList_Sq</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>若将第一个while循环中的条件语句改为“switch…case…”语句，并当<code>*pa=*pb</code>的时候改为<code>*pc++ = *pa++;*pb++;</code>由于集合A、B而言是值单增的，则该算法完成的操作和union()相同，但很明显时间复杂度不同。</li><li>时间复杂度不同的原因：<blockquote><ul><li>① 由于La、Lb的值以单增有序排列，则对La中的每一个元素无需从La由表头到表尾进行全程搜索。</li><li>② 用Lc表示合并之后的“并集”，union()中的插入操作是通过“复制”实现的。</li></ul></blockquote></li><li>因此，由快速排序算法的时间复杂度是$O(nlog(n))$，则可知在进行集合合并相关的操作时，先要对集合对应的顺序表进行排序。</li></ul></blockquote><hr><h1 id="1-3-线性表的链式表示和实现"><a href="#1-3-线性表的链式表示和实现" class="headerlink" title="1.3 线性表的链式表示和实现"></a>1.3 线性表的链式表示和实现</h1><blockquote><p>线性表的<strong>链式存储结构</strong>的特点是用一组<strong>任意</strong>的存储单元存储线性表中的数据元素。（这些存储单元可以是连续的，也可以是不连续的）</p></blockquote><p><strong>结点</strong>：数据元素的存储映像（由数据域+指针域组成）。</p><p><strong>数据域</strong>：用于存储数据元素信息的域。</p><p><strong>指针域</strong>：（对单链表而言）存储一个指示其直接后继的信息（即直接后继的地址）。</p><p><strong>指针（链）</strong>：指针域中存储的信息。</p><h2 id="1-3-1-线性链表（单链表）"><a href="#1-3-1-线性链表（单链表）" class="headerlink" title="1.3.1 线性链表（单链表）"></a>1.3.1 线性链表（单链表）</h2><blockquote><p>特点：链表的每个结点中只包含一个指针域。</p></blockquote><p><strong>头指针</strong>：指向链表中第一个结点（即第一个数据元素的映像）。</p><blockquote><ul><li>线性链表的存取必须从头指针开始进行，因此单链表是<strong>非随机存取</strong>的存储结构。由于线性链表的最后一个结点没有直接后继，因此最后一个结点的指针为NULL。</li><li>用线性链表表示线性表时，数据元素之间的逻辑关系是由结点中的指针指示的，因此，<strong>指针</strong>为数据元素之间的<strong>逻辑关系的映像</strong>。</li></ul><p>// 由于单链表可由头指针唯一确定，在C中用结构指针描述<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct LS&#123;</span><br><span class="line">    char name[20];</span><br><span class="line">    int num;</span><br><span class="line">&#125;L1,*p;</span><br><span class="line">&#x2F;&#x2F;L1是LS的别名，p&#x3D;&amp;L1,p是struct LS*类型,p指向L1的首地址，即p和(*p).name表示同一个内存空间，</span><br><span class="line">&#x2F;&#x2F;(*p).name的类型是char*。L1.name,(*p).name,p-&gt;name等价。</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line"></span><br><span class="line">### (1) 线性链表动态存储结构表示</span><br><span class="line">![单链表](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20200908212951823.png#pic_center)</span><br><span class="line">&lt;center&gt;图 1.3.1-1&lt;center&gt;</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;cpp</span><br><span class="line">&#x2F;&#x2F;-----------单链表的动态存储结构-------------</span><br><span class="line">typedef struct LNode&#123;</span><br><span class="line">    ElemType    data;   </span><br><span class="line">    struct LNode *next;</span><br><span class="line">&#125;LNode,*LinkList;</span><br></pre></td></tr></table></figure><br>对于没有头结点的单链表，L是LinkList类型的变量，则L为该单链表的头指针。<code>L=NULL</code>表示空表。<br>对于有头结点的单链表，L是LinkList类型的变量，<code>L-&gt;next=NULL</code>表示空表。<p></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetElem_L</span><span class="params">(LinkList L, <span class="keyword">int</span> i, ElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//L是带头结点的单链表的头指针</span></span><br><span class="line">    <span class="comment">//当第i个元素存在时，用e返回其值且返回OK，否则返回ERROR</span></span><br><span class="line">    p = L-&gt;next;</span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>((j&lt;i)&amp;&amp;p)&#123; p = p-&gt;next;  j++;&#125;</span><br><span class="line">    <span class="keyword">if</span>(!p||j&gt;i) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">//GetElem_L</span></span><br></pre></td></tr></table></figure><blockquote><p>该算法的时间复杂度为$O(n)$。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert_L</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//在带头结点的单链表的第i个位置之前插入元素e</span></span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p&amp;&amp;(j&lt;i<span class="number">-1</span>))&#123; p = p-&gt;next; j++;&#125;           <span class="comment">//寻找指向第i-1位置的指针</span></span><br><span class="line"><span class="comment">//  if(!p||(j&gt;i-1)) return ERROR;</span></span><br><span class="line">    s = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(!s) <span class="built_in">exit</span>(overflow);</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">//ListInsert_L</span></span><br></pre></td></tr></table></figure><br>该算法的时间复杂度为$O(n)$。<p></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListDelete_L</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, ElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//删除带头结点的单链表的第i个位置元素，并用e返回其值</span></span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((p-&gt;next)&amp;&amp;(j&lt;i<span class="number">-1</span>))&#123;p = p-&gt;next; j++;&#125;    <span class="comment">//寻找指向第i-1位置的指针</span></span><br><span class="line"><span class="comment">//  if(!(p-&gt;next)||(j&gt;i-1)) return ERROR;</span></span><br><span class="line">    q = p-&gt;next;</span><br><span class="line">    e = q-&gt;data;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">//ListDelete_L</span></span><br></pre></td></tr></table></figure><blockquote><p>该算法的时间复杂度为$O(n)$。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateList_L</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//逆位序输入n个元素的值，建立带有头结点的单链表L</span></span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n; i&gt;=<span class="number">1</span>; i--)&#123;</span><br><span class="line">        p = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line"><span class="comment">//      if(!p)&#123;ClearList_L(L);  exit(overflow);&#125;</span></span><br><span class="line">        <span class="built_in">scanf</span>(&amp;p-&gt;data);</span><br><span class="line">        p-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//CreateList_L</span></span><br></pre></td></tr></table></figure><blockquote><p>显然易见，按逆位序建立的时间复杂度为$O(n)$，而按顺位序建立的时间复杂度为$O(n^2)$。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeList_L</span><span class="params">(LinkList &amp;La, LinkList &amp;Lb, LinkList &amp;Lc)</span></span>&#123;</span><br><span class="line">    <span class="comment">//已知单链表La,Lb是按值不减有序排列</span></span><br><span class="line">    <span class="comment">//归并La和Lb得单链表Lc，Lc也是按值不减有序排列</span></span><br><span class="line">    pa = La-&gt;next;</span><br><span class="line">    pb = Lb-&gt;next;</span><br><span class="line">    Lc = pc = La;</span><br><span class="line">    <span class="keyword">while</span>(pa&amp;&amp;pb)&#123;</span><br><span class="line">        <span class="keyword">if</span>((pa-&gt;data)&lt;=(pb-&gt;data)))&#123;</span><br><span class="line">            pc-&gt;next = pa; </span><br><span class="line">            pc = pa; </span><br><span class="line">            pa = pa-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123; </span><br><span class="line">            pc-&gt;next = pb; </span><br><span class="line">            pc = pb; </span><br><span class="line">            pb = pb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pc-&gt;next = pa?pa:pb;</span><br><span class="line">    <span class="built_in">free</span>(pb);</span><br><span class="line">&#125;MergeList_L</span><br></pre></td></tr></table></figure><br>该算法的时间复杂度为$O(ListLength_L(La)+ListLength_L(Lb))$。<br>该算法与之前MergeList_Sq()的空间复杂度不同，因为该算法在归并两个链表时，不需建立新表的存储关系，只需将原来两个链表中结点之间的关系解除然后在重新按值非递减将所有结点链接成一个链表即可。<p></p></blockquote><h3 id="2-线性链表静态存储结构表示"><a href="#2-线性链表静态存储结构表示" class="headerlink" title="(2) 线性链表静态存储结构表示"></a>(2) 线性链表静态存储结构表示</h3><p><img src="https://img-blog.csdnimg.cn/20200908231321251.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JsdWVfZGF3bg==,size_16,color_FFFFFF,t_70#pic_center" alt="静态单链表1"><br><img src="https://img-blog.csdnimg.cn/20200908231212199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JsdWVfZGF3bg==,size_16,color_FFFFFF,t_70#pic_center" alt="静态单链表2"></p><p><center>图 1.3.1-2<center></center></center></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---------------线性链表的静态单链表的存储结构--------------------------</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">int</span> cur;</span><br><span class="line">&#125;component,SLinkList[MAXSIZE];</span><br></pre></td></tr></table></figure><blockquote><ul><li>定义了一个匿名结构体，component是其的别名，SLinkList是component类型的数组。</li><li>数组的一个分量表示一个结点，游标（指示器cur）代替指针指示结点在数组中的相对位置。数组的第零个分量可以看成是头结点，其指针域指示链表的第一个结点。这种存储结构需要预先分配一个较大的存储空间，但作为线性表的插入和删除操作无需移动元素，仅需修改指针，故仍具有链式存储结构的主要优点。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetElem_SL</span><span class="params">(SLinkList L, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//在静态链表L中查找值为e的第1个元素</span></span><br><span class="line">    <span class="comment">//若找到，则返回对应位序，否则返回0</span></span><br><span class="line">    i = L[<span class="number">0</span>].cur;</span><br><span class="line">    <span class="keyword">while</span>(i&amp;&amp;(L[i].data!=e))&#123;</span><br><span class="line">        i = L[i].cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;<span class="comment">//GetElem_SL </span></span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList_SL</span><span class="params">(SLinkList &amp;space)</span></span>&#123;</span><br><span class="line">    <span class="comment">//将一维数组space的各分量链接成一个备用链表，头指针为space[0].cur</span></span><br><span class="line">    <span class="comment">//“0”代表空指针</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;MAXSIZE<span class="number">-1</span>; i++)&#123; space[i].cur = i+<span class="number">1</span>;&#125;</span><br><span class="line">    space[MAXSIZE<span class="number">-1</span>].cur = <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//InitList_SL</span></span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Malloc_SL</span><span class="params">(SLinkList &amp;space)</span></span>&#123;</span><br><span class="line">    <span class="comment">//若备用链表非空，则返回分配结点下标，否则返回0</span></span><br><span class="line">    i = space[<span class="number">0</span>].cur;</span><br><span class="line">    <span class="keyword">if</span>(space[<span class="number">0</span>].cur)    space[<span class="number">0</span>].cur = space[i].cur;</span><br><span class="line">    <span class="keyword">return</span>  i;</span><br><span class="line">&#125;<span class="comment">//Malloc_SL</span></span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Free_SL</span><span class="params">(SLinkList &amp;space, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="comment">//将下标为k的空闲结点回收到备用链表</span></span><br><span class="line">    space[k].cur = space[<span class="number">0</span>].cur;</span><br><span class="line">    space[<span class="number">0</span>].cur = k;</span><br><span class="line">&#125;<span class="comment">//Free_SL</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">difference</span><span class="params">(SLinkList &amp;space, <span class="keyword">int</span> &amp;S)</span></span>&#123;</span><br><span class="line">    <span class="comment">//依次输入A、B集合的元素，在一维数组space中建立集合(A-B)∪(B-A)的静态链表，S为其的头指针。</span></span><br><span class="line">    <span class="comment">//假设备用空间足够大，space[0].cur为其头指针。</span></span><br><span class="line">    InitList_SL(space);</span><br><span class="line">    S = Malloc_SL(space);</span><br><span class="line">    r = S;</span><br><span class="line">    <span class="built_in">scanf</span>(m,n);                 <span class="comment">//m,n分别是A和B的元素个数</span></span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=m; j++)&#123;</span><br><span class="line">        i = Malloc_SL(space);</span><br><span class="line">        <span class="built_in">scanf</span>(space[i].data);</span><br><span class="line">        space[r].cur = i;</span><br><span class="line">        r = i;                  <span class="comment">//r指向当前S的最后一个结点，即（合并前、后）属于A的最后一个结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    space[r].cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=n; j++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(b);</span><br><span class="line">        p = S;</span><br><span class="line">        k = space[S].cur;</span><br><span class="line">        <span class="keyword">while</span>((space[k].data!=b)&amp;&amp;(space[r].cur!=k))&#123;</span><br><span class="line">            p = k;</span><br><span class="line">            k = space[k].cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k == space[r].cur)&#123;</span><br><span class="line">            i = Malloc_SL(space);</span><br><span class="line">            space[i].data = b;</span><br><span class="line">            space[i].cur = space[r].cur;        </span><br><span class="line">            space[r].cur = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            space[p].cur = space[k].cur;</span><br><span class="line">            Free_SL(space, k);</span><br><span class="line">            <span class="keyword">if</span>(r == k)  r = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//difference</span></span><br><span class="line">```     </span><br><span class="line">&gt; 该算法的时间复杂度为$O(m*n)$。</span><br><span class="line"></span><br><span class="line">&gt;  eg. 线性表$La=(c,b,e,g,f,d)$表示结合A，线性表$Lb=(a,b,n,f)$表示B, difference()求$(A-B)\cup(B-A)$，其中space静态单链表如前图 <span class="number">1.3</span><span class="number">.1</span><span class="number">-2</span>所示。</span><br><span class="line"></span><br><span class="line">## <span class="number">1.3</span><span class="number">.2</span> 循环链表</span><br><span class="line">&gt; - 特点：表中的最后一个结点的指针域指向头结点，整个链表形成一个环。</span><br><span class="line">&gt; - 循环链表的操作和线性链表的操作基本一致，不同在于算法中的**循环条件**由p或p-&gt;next非空，而是是否等于头指针;</span><br><span class="line">&gt; - 但有时候，在循环链表设立尾指针而不设头指针，则可使某些操作简化。如在合并两个线性表时，只需将一个表的表尾和另一个表的表头的相连接即可，时间复杂度为$O(<span class="number">1</span>)$。</span><br><span class="line">    </span><br><span class="line">## <span class="number">1.3</span><span class="number">.3</span> 双向链表</span><br><span class="line">&gt; 特点：各结点中有两个指针域，一个指向直接后继，一个指向直接前驱。</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="comment">//-----------------线性表的双向链表存储结构--------------------</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> *<span class="title">prior</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;DuLNode,*DuLinkList;</span><br></pre></td></tr></table></figure><h3 id="1-双向循环链表"><a href="#1-双向循环链表" class="headerlink" title="(1) 双向循环链表"></a>(1) 双向循环链表</h3><blockquote><p>特点：<code>d-&gt;next-&gt;prior = d-&gt;prior-&gt;next = d</code></p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200908213528656.png#pic_center" alt="双向循环链表"></p><p><center>图 1.3.3-1<center></center></center></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert_DuL</span><span class="params">(DuLinkList &amp;L, <span class="keyword">int</span> i, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//在带头结点的双向循环链表L中第i个位置之前插入元素e</span></span><br><span class="line">    <span class="comment">//i的合法值为 1&lt;=i&lt;=表长+1</span></span><br><span class="line">    <span class="keyword">if</span>(!GetElem_DuL(L,i))   <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">if</span>(!(s = (DuLinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DuLNode))))  <span class="keyword">return</span> ERROR;</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    p-&gt;prior-&gt;next = s;</span><br><span class="line">    s-&gt;prior = p-&gt;prior;</span><br><span class="line">    s-&gt;next = p;</span><br><span class="line">    p-&gt;prior = s;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">//ListInsert_DuL</span></span><br></pre></td></tr></table></figure><blockquote><p>该算法的时间复杂度为$O(n)$;</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListDelete_DuL</span><span class="params">(DuLinkList &amp;L, <span class="keyword">int</span> i, ElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//删除带头结点的双向循环链表L中第i个位置的元素</span></span><br><span class="line">    <span class="comment">//i的合法值为1&lt;=i&lt;=表长，且用e返回该元素</span></span><br><span class="line">    <span class="keyword">if</span>(!GetElem_DuL(L,i))   <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    p-&gt;prior-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next-&gt;prior = p-&gt;prior;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">//ListDelete_DuL</span></span><br></pre></td></tr></table></figure><blockquote><p>该算法的时间复杂度为$O(n)$;</p></blockquote><h2 id="1-3-4-一般线性链表存储表示"><a href="#1-3-4-一般线性链表存储表示" class="headerlink" title="1.3.4 一般线性链表存储表示"></a>1.3.4 一般线性链表存储表示</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*Link,*Position;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Link head,tail;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">&#125;LinkList;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">MakeNode</span><span class="params">(Link &amp;p, ElemType e)</span></span>;</span><br><span class="line"><span class="comment">//分配由p指向值为e的结点，并返回OK；若分配失败，返回ERROR；</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FreeNode</span><span class="params">(Link &amp;p)</span></span>;</span><br><span class="line"><span class="comment">//释放p指向的结点</span></span><br><span class="line"><span class="function">Status <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span></span>;</span><br><span class="line"><span class="comment">//构造一个空的线性链表L</span></span><br><span class="line"><span class="function">Status <span class="title">DestroyList</span><span class="params">(LinkList &amp;L)</span></span>;</span><br><span class="line"><span class="comment">//销毁线性链表L</span></span><br><span class="line"><span class="function">Status <span class="title">ClearList</span><span class="params">(LinkList &amp;L)</span></span>;</span><br><span class="line"><span class="comment">//将线性链表L置位空表，并释放原来链表的结点空间</span></span><br><span class="line"><span class="function">Status <span class="title">InsFirst</span><span class="params">(Link h, Link s)</span></span>;</span><br><span class="line"><span class="comment">//已知h指向线性链表的头结点，将s指向的结点插入在第一个节点之前</span></span><br><span class="line"><span class="function">Status <span class="title">DelFirst</span><span class="params">(Link h, Link &amp;q)</span></span>;</span><br><span class="line"><span class="comment">//已知h指向线性链表的头结点，删除线性链表的第一个结点并返回q</span></span><br><span class="line"><span class="function">Status <span class="title">Append</span><span class="params">(LinkList &amp;L, Link s)</span></span>; </span><br><span class="line"><span class="comment">//将指针s所指的一串结点(彼此以指针相互链接)链接在线性链表的最后一个结点，并改变L的尾指针指向新链表的尾结点</span></span><br><span class="line"><span class="function">Status <span class="title">Remove</span><span class="params">(LinkList &amp;L, Link &amp;q)</span></span>;</span><br><span class="line"><span class="comment">//删除线性链表的尾结点，并以q返回，并改变L的尾指针指向新的尾结点</span></span><br><span class="line"><span class="function">Status <span class="title">InsBefore</span><span class="params">(LinkList &amp;L, Link &amp;p, Link s)</span></span>;</span><br><span class="line"><span class="comment">//已知p指向L中的一个结点，将s指向的结点插入在p所指的结点之前，并修改指针p指向新插入的结点</span></span><br><span class="line"><span class="function">Status <span class="title">InsAfter</span><span class="params">(LinkList &amp;L, Link &amp;p, Link s)</span></span>;</span><br><span class="line"><span class="comment">//已知p指向L中的一个结点，将s指向的结点插入在p所指的结点之后，并修改指针p指向新插入的结点</span></span><br><span class="line"><span class="function">Status <span class="title">SetCurElem</span><span class="params">(Link &amp;p, ElemType e)</span></span>;</span><br><span class="line"><span class="comment">//已知p指向线性链表的一个结点，用e更新p所指结点的数据元素的值</span></span><br><span class="line"><span class="function">ElemType <span class="title">GetCurElem</span><span class="params">(Link p)</span></span>;</span><br><span class="line"><span class="comment">//已知p指向线性链表的一个结点，返回p所指结点的数据元素的值</span></span><br><span class="line"><span class="function">Status <span class="title">ListEmpty</span><span class="params">(LinkList L)</span></span>;</span><br><span class="line"><span class="comment">//若线性链表为空表，则返回True，否则返回False。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength</span><span class="params">(LinkList L)</span></span>;</span><br><span class="line"><span class="comment">//返回线性链表的元素个数</span></span><br><span class="line"><span class="function">Position <span class="title">GetHead</span><span class="params">(LinkList L)</span></span>;</span><br><span class="line"><span class="comment">//返回线性链表头结点的位置</span></span><br><span class="line"><span class="function">Position <span class="title">GetLast</span><span class="params">(LinkList L)</span></span>;</span><br><span class="line"><span class="comment">//返回线性链表最后一个结点的位置</span></span><br><span class="line"><span class="function">Position <span class="title">PriorPos</span><span class="params">(LinkList L, Link &amp;p)</span></span>;</span><br><span class="line"><span class="comment">//已知p指向线性链表L中的一个结点，返回p所指结点的直接前驱的位置，若无前驱返回NULL</span></span><br><span class="line"><span class="function">Position <span class="title">NextPos</span><span class="params">(LinkList L, Link &amp;p)</span></span>;</span><br><span class="line"><span class="comment">//已知p指向线性链表L中的一个结点，返回p所指结点的直接后继的位置，若无后继返回NULL</span></span><br><span class="line"><span class="function">Status <span class="title">LocatePos</span><span class="params">(LinkList L, <span class="keyword">int</span> i, Link &amp;p)</span></span>;</span><br><span class="line"><span class="comment">//返回p指示线性链表L的第i个结点的位置并返回OK，i值不合法时返回ERROR</span></span><br><span class="line"><span class="function">Position <span class="title">LocateElem</span><span class="params">(LinkList L, ElemType e, Status (*compare)(ElemType,ElemType))</span></span>;</span><br><span class="line"><span class="comment">//返回线性链表第一个与e符合compare()判定关系的元素位置，若不存在则返回NULL</span></span><br><span class="line"><span class="function">Status <span class="title">ListTraverse</span><span class="params">(LinkList L, Status(*visit)())</span></span>;</span><br><span class="line"><span class="comment">//依次对L的每个元素进行visit，一旦visit失败则操作失败</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//在带头结点的单链表L中第i个位置之前插入元素e</span></span><br><span class="line">    <span class="keyword">if</span>(!LocatePos(L,i<span class="number">-1</span>,h)) <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">if</span>(!MakeNode(s,e))  <span class="keyword">return</span> ERROR;</span><br><span class="line">    InsFirst(h,s);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">//ListInsert</span></span><br><span class="line">        </span><br><span class="line"><span class="function">Status <span class="title">MergeList</span><span class="params">(LinkList &amp;La, LinkList &amp;Lb, LinkList &amp;Lc)</span></span>&#123;</span><br><span class="line">    <span class="comment">//已知单链表La,Lb是按值不减有序排列</span></span><br><span class="line">    <span class="comment">//归并La和Lb得单链表Lc，Lc也是按值不减有序排列</span></span><br><span class="line">    <span class="keyword">if</span>(!InitList(Lc))   <span class="keyword">return</span> ERROR;</span><br><span class="line">    ha = GetHead(La);</span><br><span class="line">    hb = GetHead(Lb);</span><br><span class="line">    pa = NextPos(La,ha);</span><br><span class="line">    pb = NextPos(Lb,hb);</span><br><span class="line">    <span class="keyword">while</span>(pa&amp;&amp;pb)&#123;</span><br><span class="line">        a = GetCurElem(pa);</span><br><span class="line">        b = GetCurElem(pb);</span><br><span class="line">        <span class="keyword">if</span>((*compare)(a,b)&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            DelFirst(ha,q);</span><br><span class="line">            Append(Lc,q);</span><br><span class="line">            pb = NextPos(Lb,hb);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            DelFirst(hb,q);</span><br><span class="line">            Append(Lc,q);</span><br><span class="line">            pa = NextPos(La,ha);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pa)  Append(Lc,pa);</span><br><span class="line">    <span class="keyword">else</span>    Append(Lc,pb);</span><br><span class="line">    FreeNode(ha);</span><br><span class="line">    FreeNode(hb);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">//MergeList</span></span><br></pre></td></tr></table></figure><hr><h1 id="1-4-一元多项式的表示及相加"><a href="#1-4-一元多项式的表示及相加" class="headerlink" title="1.4 一元多项式的表示及相加"></a>1.4 一元多项式的表示及相加</h1><p><code>顺序存储表示</code> <code>链式存储表示</code></p><blockquote><p>有序链表和线性链表的基本操作有两处不同：<br>① 是LocateElem()职能不同；② 是需增加按有序关系进行插入的操作<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Status LocateElem(LinkList L, ElemType e, Position &amp;q, int (*compare)(ElemType,ElemType));</span><br><span class="line">&#x2F;&#x2F;若有序链表L中存在与e符合compare()值为0的元素，则q指向L中第一个值为e的结点，并返回True</span><br><span class="line">&#x2F;&#x2F;否则，q指示第一个与e满足compare()取值&gt;0的元素的前驱，并返回False</span><br><span class="line">Status OrderInsert(LinkList &amp;L, ElemType e, int (*compare)(ElemType,ElemType));</span><br><span class="line">&#x2F;&#x2F;按有序判定函数compare将值为e的结点插入到L的适当位置</span><br></pre></td></tr></table></figure><p></p><h2><a href="#" class="headerlink"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">float</span> coef;</span><br><span class="line">    <span class="keyword">int</span> expn;</span><br><span class="line">&#125;term, ElemType;</span><br><span class="line"><span class="keyword">typedef</span> LinkList polynomial;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//----------------基本操作的函数原型说明-------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatPolyn</span><span class="params">(polynomial &amp;P, <span class="keyword">int</span> m)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyPolyn</span><span class="params">(polynomial &amp;P)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPolyn</span><span class="params">(polynomial P)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PolynLength</span><span class="params">(polynomial P)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddPolyn</span><span class="params">(polynomial &amp;Pa, polynomial &amp;Pb)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SubtractPolyn</span><span class="params">(polynomial &amp;Pa, polynomial &amp;Pb)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MutiplyPolyn</span><span class="params">(polynomial &amp;Pa, polynomial &amp;Pb)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//--------------------算法描述-------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(term a, term b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  (a.expn&gt;b.expn)?<span class="number">1</span>:((a.expn &lt; b.expn)?<span class="number">-1</span>:<span class="number">0</span>);</span><br><span class="line">&#125;<span class="comment">//cmp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatPolyn</span><span class="params">(polynomial &amp;P, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    InitList(P);</span><br><span class="line">    h = GetHead(P);</span><br><span class="line">    e.coef = <span class="number">0</span>;</span><br><span class="line">    e.expn = <span class="number">-1</span>;</span><br><span class="line">    SetCurElem(h,e);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=m; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(e.coef,e.expn);</span><br><span class="line">        <span class="keyword">if</span>(!LocateElem(P,e,q,(*cmp)()))&#123;</span><br><span class="line">        <span class="keyword">if</span>(!MakeNode(s,e))  InsFirst(q,s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//CreatPolyn</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddPolyn</span><span class="params">(PolynLength &amp;Pa, polynomial &amp;Pb)</span></span>&#123;</span><br><span class="line">    ha = GetHead(Pa);</span><br><span class="line">    hb = GetHead(Pb);</span><br><span class="line">    qa = NextPos(ha);</span><br><span class="line">    qb = NextPos(hb);</span><br><span class="line">    <span class="keyword">while</span>(qa&amp;&amp;qb)&#123;</span><br><span class="line">        a = GetCurElem(qa);</span><br><span class="line">        b = GetCurElem(qb);</span><br><span class="line">        swith(*cmp(a,b))&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">-1</span>:    </span><br><span class="line">                ha = qa; qa = NextPos(Pa, qa);  <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                sum = a.coef + b.coef;</span><br><span class="line">                <span class="keyword">if</span>(sum != <span class="number">0.0</span>)&#123;</span><br><span class="line">                    SetCurElem(qa,sum);</span><br><span class="line">                    ha = qa;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    DelFirst(ha,qa);</span><br><span class="line">                    FreeNode(qa);</span><br><span class="line">                &#125;</span><br><span class="line">                DelFirst(hb,qb);</span><br><span class="line">                FreeNode(qb);</span><br><span class="line">                qb = NextPos(Pb,hb);</span><br><span class="line">                qa = NextPos(Pa,ha);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                DelFirst(hb,qb);</span><br><span class="line">                InsFirst(ha,qb);</span><br><span class="line">                qb = NextPos(Pb,hb);</span><br><span class="line">                ha = NextPos(Pa,ha);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!ListEmpty(Pb))  Append(Pa,qb);</span><br><span class="line">    FreeNode(hb);</span><br><span class="line">&#125;<span class="comment">//AddPolyn</span></span><br></pre></td></tr></table></figure></h2></blockquote></div><div class="reward-container"><div></div><button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'>打赏</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="/images/wechatpay.png" alt="blue_dawn 微信支付"><p>微信支付</p></div></div></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------本文结束<i class="fa fa-heart"></i>感谢您的阅读-------------</div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>blue_dawn</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="http://www.bluedawn1.space/2020/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0_1/" title="数据结构笔记_1">http://www.bluedawn1.space/2020/09/10/数据结构笔记_1/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E8%80%83%E7%A0%94/" rel="tag"><i class="fa fa-tag"></i> 考研</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"><i class="fa fa-tag"></i> 数据结构</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2020/09/05/List1/" rel="prev" title="List1"><i class="fa fa-chevron-left"></i> List1</a></div><div class="post-nav-item"><a href="/2020/10/05/List2/" rel="next" title="List2">List2 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div><script>window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-1-线性表的类型定义"><span class="nav-number">1.</span> <span class="nav-text">1.1 线性表的类型定义</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-2-线性表的顺序表示和实现"><span class="nav-number">2.</span> <span class="nav-text">1.2 线性表的顺序表示和实现</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-3-线性表的链式表示和实现"><span class="nav-number">3.</span> <span class="nav-text">1.3 线性表的链式表示和实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-1-线性链表（单链表）"><span class="nav-number">3.1.</span> <span class="nav-text">1.3.1 线性链表（单链表）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-线性链表静态存储结构表示"><span class="nav-number">3.1.1.</span> <span class="nav-text">(2) 线性链表静态存储结构表示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-双向循环链表"><span class="nav-number">3.1.2.</span> <span class="nav-text">(1) 双向循环链表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-4-一般线性链表存储表示"><span class="nav-number">3.2.</span> <span class="nav-text">1.3.4 一般线性链表存储表示</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-4-一元多项式的表示及相加"><span class="nav-number">4.</span> <span class="nav-text">1.4 一元多项式的表示及相加</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#"><span class="nav-number">4.1.</span> <span class="nav-text">1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 typedef struct&amp;#123; float coef; int expn; &amp;#125;term, ElemType; typedef LinkList polynomial; &#x2F;&#x2F;----------------基本操作的函数原型说明------------- void CreatPolyn(polynomial &amp;P, int m); void DestroyPolyn(polynomial &amp;P); void PrintPolyn(polynomial P); int PolynLength(polynomial P); void AddPolyn(polynomial &amp;Pa, polynomial &amp;Pb); void SubtractPolyn(polynomial &amp;Pa, polynomial &amp;Pb); void MutiplyPolyn(polynomial &amp;Pa, polynomial &amp;Pb); &#x2F;&#x2F;--------------------算法描述------------------------- int cmp(term a, term b)&amp;#123; return (a.expn&gt;b.expn)?1:((a.expn &lt; b.expn)?-1:0); &amp;#125;&#x2F;&#x2F;cmp void CreatPolyn(polynomial &amp;P, int m)&amp;#123; InitList(P); h &#x3D; GetHead(P); e.coef &#x3D; 0; e.expn &#x3D; -1; SetCurElem(h,e); for(i&#x3D;1; i&lt;&#x3D;m; i++)&amp;#123; scanf(e.coef,e.expn); if(!LocateElem(P,e,q,(*cmp)()))&amp;#123; if(!MakeNode(s,e)) InsFirst(q,s); &amp;#125; &amp;#125; &amp;#125;&#x2F;&#x2F;CreatPolyn void AddPolyn(PolynLength &amp;Pa, polynomial &amp;Pb)&amp;#123; ha &#x3D; GetHead(Pa); hb &#x3D; GetHead(Pb); qa &#x3D; NextPos(ha); qb &#x3D; NextPos(hb); while(qa&amp;&amp;qb)&amp;#123; a &#x3D; GetCurElem(qa); b &#x3D; GetCurElem(qb); swith(*cmp(a,b))&amp;#123; case -1: ha &#x3D; qa; qa &#x3D; NextPos(Pa, qa); break; case 0: sum &#x3D; a.coef + b.coef; if(sum !&#x3D; 0.0)&amp;#123; SetCurElem(qa,sum); ha &#x3D; qa; &amp;#125; else&amp;#123; DelFirst(ha,qa); FreeNode(qa); &amp;#125; DelFirst(hb,qb); FreeNode(qb); qb &#x3D; NextPos(Pb,hb); qa &#x3D; NextPos(Pa,ha); break; case 1: DelFirst(hb,qb); InsFirst(ha,qb); qb &#x3D; NextPos(Pb,hb); ha &#x3D; NextPos(Pa,ha); break; &amp;#125; &amp;#125; if(!ListEmpty(Pb)) Append(Pa,qb); FreeNode(hb); &amp;#125;&#x2F;&#x2F;AddPolyn</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="blue_dawn" src="/images/avatar.gif"><p class="site-author-name" itemprop="name">blue_dawn</p><div class="site-description" itemprop="description">清风徐来, 水波不兴</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">33</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">19</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">14</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/bluedawn520" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;bluedawn520" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:2515294061@qq.com" title="E-Mail → mailto:2515294061@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a> </span><span class="links-of-author-item"><a href="/2515294061" title="QQ → 2515294061"><i class="fa fa-fw fa-qq"></i>QQ</a></span></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> 推荐阅读</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="http://www.alloyteam.com/nav/" title="http:&#x2F;&#x2F;www.alloyteam.com&#x2F;nav&#x2F;" rel="noopener" target="_blank">Web前端导航</a></li><li class="links-of-blogroll-item"><a href="http://www.chuangzaoshi.com/code" title="http:&#x2F;&#x2F;www.chuangzaoshi.com&#x2F;code" rel="noopener" target="_blank">创造狮导航</a></li><li class="links-of-blogroll-item"><a href="http://www.36zhen.com/t?id=3448" title="http:&#x2F;&#x2F;www.36zhen.com&#x2F;t?id&#x3D;3448" rel="noopener" target="_blank">前端书籍资料</a></li><li class="links-of-blogroll-item"><a href="http://e.xitu.io/" title="http:&#x2F;&#x2F;e.xitu.io&#x2F;" rel="noopener" target="_blank">掘金酱</a></li><li class="links-of-blogroll-item"><a href="https://www.v2ex.com/" title="https:&#x2F;&#x2F;www.v2ex.com&#x2F;" rel="noopener" target="_blank">V2EX</a></li><li class="links-of-blogroll-item"><a href="https://www.v2ex.com/" title="https:&#x2F;&#x2F;www.v2ex.com&#x2F;" rel="noopener" target="_blank">印记中文</a></li></ul></div></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2020</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">blue_dawn</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span title="站点总字数">90k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">1:22</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/jquery/2.1.3/jquery.min.js"></script><script src="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.min.js"></script><script src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script defer src="/lib/three/three.min.js"></script><script defer src="/lib/three/three-waves.min.js"></script><script defer src="/lib/three/canvas_sphere.min.js"></script><script src="/js/local-search.js"></script><script>if (document.querySelectorAll('div.pdf').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/pdfobject@2/pdfobject.min.js', () => {
    document.querySelectorAll('div.pdf').forEach(element => {
      PDFObject.embed(element.getAttribute('target'), element, {
        pdfOpenParams: {
          navpanes : 0,
          toolbar  : 0,
          statusbar: 0,
          pagemode : 'thumbs',
          view     : 'FitH'
        },
        PDFJS_URL: '/lib/pdf/web/viewer.html',
        height: element.getAttribute('height') || '500px'
      });
    });
  }, window.PDFObject);
}</script><script>if (typeof MathJax === 'undefined') {
    window.MathJax = {
        loader: {
          load: ['[tex]/mhchem']
        },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }</script><script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script><link rel="stylesheet" href="/dist/APlayer.min.css"><div id="aplayer"></div><script type="text/javascript" src="/dist/APlayer.min.js"></script><script type="text/javascript" src="/dist/music.js"></script><canvas class="fireworks" style="position:fixed;left:0;top:0;z-index:1;pointer-events:none"></canvas><script src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script><script src="/js/cursor/explosion.min.js"></script><script type="text/javascript" src="/js/src/crash_cheat.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,model:{scale:1,hHeadPos:.5,vHeadPos:.618,jsonPath:"/live2dw/assets/wanko.model.json"},display:{superSample:2,width:150,height:300,position:"right",hOffset:0,vOffset:-20},mobile:{show:!0,scale:.5},react:{opacityDefault:.7,opacityOnHover:.2}})</script></body></html>