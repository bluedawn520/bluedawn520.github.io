<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 4.2.1"><script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"><style>.pace .pace-progress{background:#1e92fb;height:3px}.pace .pace-progress-inner{box-shadow:0 0 10px #1e92fb,0 0 5px #1e92fb}.pace .pace-activity{border-top-color:#1e92fb;border-left-color:#1e92fb}</style><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"www.bluedawn1.space",root:"/",scheme:"Gemini",version:"7.7.1",exturl:!1,sidebar:{position:"left",width:240,display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:null},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="CHAPTER 1Q1：What is OS?OS是指 ①控制和管理计算机系统硬件资源、②合理的组织和调度计算机工作和资源的分配、③进而为用户以及其他应用软件提供方便的接口和环境的 系统软件。Q2：OS的基本特征① 并发：多个程序可以在同一时间段内同时执行【并行：同一时刻同时执行，必须要有硬件资源或多处理机的支持】【引入进程是为了更好地实现系统的并发性】【OS的并发使得以分时实现的】② 共享：即资"><meta property="og:type" content="article"><meta property="og:title" content="OS_NOTES.md"><meta property="og:url" content="http://www.bluedawn1.space/2021/11/24/OS_NOTES/index.html"><meta property="og:site_name" content="不羁"><meta property="og:description" content="CHAPTER 1Q1：What is OS?OS是指 ①控制和管理计算机系统硬件资源、②合理的组织和调度计算机工作和资源的分配、③进而为用户以及其他应用软件提供方便的接口和环境的 系统软件。Q2：OS的基本特征① 并发：多个程序可以在同一时间段内同时执行【并行：同一时刻同时执行，必须要有硬件资源或多处理机的支持】【引入进程是为了更好地实现系统的并发性】【OS的并发使得以分时实现的】② 共享：即资"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2021-11-24T07:43:54.000Z"><meta property="article:modified_time" content="2021-11-25T02:44:34.319Z"><meta property="article:author" content="blue_dawn"><meta property="article:tag" content="考研"><meta property="article:tag" content="操作系统"><meta name="twitter:card" content="summary"><link rel="canonical" href="http://www.bluedawn1.space/2021/11/24/OS_NOTES/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0}</script><title>OS_NOTES.md | 不羁</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">不羁</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">仰天大笑出门去, 我辈岂是蓬蒿人</p></div><div class="site-nav-right"></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a></li><li class="menu-item menu-item-notes"><a href="/notes" rel="section"><i class="fa fa-fw fa-fas fa-book"></i>notes</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="site-search"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"></div></div><div class="search-pop-overlay"></div></div></div></header><div class="reading-progress-bar"></div><a href="https://github.com/bluedawn520" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://www.bluedawn1.space/2021/11/24/OS_NOTES/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="blue_dawn"><meta itemprop="description" content="清风徐来, 水波不兴"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="不羁"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">OS_NOTES.md</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-11-24 15:43:54" itemprop="dateCreated datePublished" datetime="2021-11-24T15:43:54+08:00">2021-11-24</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2021-11-25 10:44:34" itemprop="dateModified" datetime="2021-11-25T10:44:34+08:00">2021-11-25</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E8%80%83%E7%A0%94/" itemprop="url" rel="index"><span itemprop="name">考研</span> </a></span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E8%80%83%E7%A0%94/%E4%B8%93%E4%B8%9A%E8%AF%BE/" itemprop="url" rel="index"><span itemprop="name">专业课</span> </a></span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E8%80%83%E7%A0%94/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span> </a></span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">计算机</span> </a></span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span> </a></span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>56k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>51 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><a id="more"></a><h1 id="CHAPTER-1"><a href="#CHAPTER-1" class="headerlink" title="CHAPTER 1"></a>CHAPTER 1</h1><h2 id="Q1：What-is-OS"><a href="#Q1：What-is-OS" class="headerlink" title="Q1：What is OS?"></a>Q1：What is OS?</h2><blockquote><p>OS是指 ①控制和管理计算机系统硬件资源、②合理的组织和调度计算机工作和资源的分配、③进而为用户以及其他应用软件提供方便的接口和环境的 <u>系统软件</u>。</p></blockquote><hr><h2 id="Q2：OS的基本特征"><a href="#Q2：OS的基本特征" class="headerlink" title="Q2：OS的基本特征"></a>Q2：OS的基本特征</h2><blockquote><p>① 并发：多个程序可以在同一时间段内同时执行</p><p>【并行：同一时刻同时执行，必须要有硬件资源或多处理机的支持】</p><p>【引入进程是为了更好地实现系统的并发性】</p><p>【OS的并发使得以分时实现的】</p><p>② 共享：即资源共享，系统中的资源可供多个进程共同使用</p><ul><li>互斥共享方式：规定同一时间段内只能由一个进程访问该资源（称临界/独占资源）</li><li>同步共享方式</li></ul><p>③ 虚拟：即将一个物理上的实体虚拟化为逻辑上的多个对应物</p><ul><li>空分复用技术：虚拟存储器</li><li>时分复用技术：处理机分时共享</li></ul><p>④ 异步：在多道程序环境下，允许多个进程并发执行，但由于资源的有限，进程的执行不是一往直前的，而是走走停停的，以不可预知的速度向前推进。</p><p>其中，并发和共享是OS最基本的特征，它们之间相互依存，即资源共享是以并发为前提的，没有多个程序并发执行，资源共享也无从谈起；若系统无法对资源进行有效的管理，那么程序的执行势必会受到影响，甚至无法执行。</p></blockquote><hr><h2 id="Q3：OS的目标及功能"><a href="#Q3：OS的目标及功能" class="headerlink" title="Q3：OS的目标及功能"></a>Q3：OS的目标及功能</h2><blockquote><p>① 作为系统资源的管理者</p><ul><li>进程管理、处理机管理、内存管理、文件管理、外设管理</li></ul><p>② 作为用户与硬件之间的接口</p><ul><li><p>命令接口：</p><ul><li><p>联机命令接口/交互式命令接口：</p><p>【由一组键盘操作组合而成】</p><p>【用户每输入一条指令，控制权就转给OS，由OS的命令解释程序解释并执行，然后返还控制权】</p><ul><li><p>脱机命令接口/批处理命令接口：</p><p>【由一组作业控制命令组成】</p><p>【用户不能直接干扰作业的运行】</p><p>【需事先将作业的操作命令写成一份作业说明书，连同作业一起交给OS】</p></li></ul></li></ul></li><li><p>程序接口：【由一组系统调用/广义指令组成】</p></li><li><p>图形接口：【严格地来说，它不属于OS，但其所调用的系统调用属于OS】</p></li></ul><p>③ 作为扩充机器</p></blockquote><hr><h2 id="Q4：OS的发展"><a href="#Q4：OS的发展" class="headerlink" title="Q4：OS的发展"></a>Q4：OS的发展</h2><blockquote><p>手工操作阶段：</p><p>【缺点：① 用户独占全机②CPU利用率极低】</p><p>批处理阶段：</p><ul><li><p>单道批处理系统：</p><p>【内存中仅保持一道作业】</p><p>【特点：自动性、顺序性、单道性】</p><p>【是为了解决人机矛盾以及CPU与I/O设备之间的不协调】</p></li><li><p>多道批处理系统：</p><p>【特点：多道、宏观上并行微观上串行】</p><p>【优点：资源利用率高、系统吞吐量大】</p><p>【缺点：用户响应时间长、不提供人机交互】</p><p>【是为了进一步提高CPU利用率和系统吞吐量】</p></li></ul><p>分时OS：是指多个用户通过终端连接在一台主机上，用户可同时与主机进行交互而不被干扰</p><p>【分时技术：将CPU的运行时间分成很小的时间片，通过时间片轮转的方式分配CPU】</p><p>【优点：同时性、交互性、独立性、及时性】</p><p>实时OS：</p><p>硬实时OS、软实时OS</p><p>【优点：安全性、可靠性】</p><p>分布式OS、网络OS、个人计算机…</p></blockquote><hr><h2 id="Q5：内核主要包括"><a href="#Q5：内核主要包括" class="headerlink" title="Q5：内核主要包括"></a>Q5：内核主要包括</h2><blockquote><p>① 时钟管理</p><p>【FUNC1 计时，系统提供标准化的时间给用户】</p><p>【FUNC2 通过时钟中断的管理，可以实现进程的切换】</p><p>【在分时OS中采用时间片轮转调度方式、在实时OS中按截止时间控制运行、在批处理系统中通过时钟管理来衡量一个进程的运行程度】</p><p>② 中断机制</p><p>【中断机制中，只有一小部分属于内核，负责保护和恢复中断现场的信息，然后将控制权转给相应的中断处理程序，这样可以减少中断处理的时间，提高系统并行处理的能力】</p><p>【中断机制最初的目的是为了实现多道程序的并发】</p><p>【通道：是一种控制一台或多台外部设备的硬件机构，它一旦被启动就独立于CPU运行，因而做到了I/O操作与CPU并行工作。】</p><p>【早期的CPU和通道的联络方法是由CPU向通道发出询问指令来了解通道工作是否完成。若未完成，则主机就循环询问一直到通道工作结束。因此，这种询问方式无法真正做到CPU和I/O操作并行。引入中断机制后，CPU启动通道传输数据之后就去执行其他程序的计算工作，而通道进行输入/输出工作，当通道工作结束时，通过中断机制向CPU发出中断请求，然后CPU暂停当前执行工作，处理中断请求后再继续原来工作。】</p><p>③ 原语</p><p>【按层系结构设计的OS，底层是一些可以被调用的公用小程序，各自完成一个功能】</p><p>【特性：原子性、处于OS最底层、处理时间短调用频繁】</p><p>④ 系统控制的数据结构及处理</p><p>【作业控制块、PCB、设备控制块、各类链表、消息队列、缓冲区、空闲区登记表、内存分配表】</p></blockquote><hr><h2 id="Q6：中断-amp-异常"><a href="#Q6：中断-amp-异常" class="headerlink" title="Q6：中断&amp;异常"></a>Q6：中断&amp;异常</h2><blockquote><p>中断/外中断：是指来自CPU指令以外的事件发生。</p><p>【时钟中断：表示一个固定的时间片已到，让处理机处理计时、启动定时运行的任务等】</p><p>【时钟中断的主要工作是处理和时间相关的信息（系统时间、进程的时间片、延时、使用CPU的时间、各种定时器）以及决定是否执行调度程序】</p><p>【I/O设备结束中断：表示设备的输入/输出已经完成，希望处理机向设备发送下一输入/输出请求，同时让完成输入/输出的程序继续执行】</p><p>异常/内中断：是指来自CPU指令内部事件的发生。</p><p>【程序的非法操作码、地址越界、算术溢出、虚拟系统的缺页、专门的trap指令引起的事件】</p><p>【对异常处理一般要依赖于当前程序的运行现场，而且异常不能被屏蔽，一旦出现就应立即处理】</p><p>中断处理过程：</p><p>①关中断</p><p>【CPU响应中断后，首先要保存程序的运行现场，而在保存过程中，不应该响应更高级中断源发送的中断请求】</p><p>②保存断点</p><p>【为了保证中断服务程序执行完后，能够正确返回到原来程序，必须将原来程序的断点（程序计数器PC）保存起来】</p><p>③中断服务程序寻址</p><p>【其实质是取出中断服务程序的入口地址送到程序计数器】【硬件找到该中断请求对应的中断向量，中断向量指明中断服务程序的入口地址（各中断向量统一存放在中断向量表中，该表由OS初始化）】</p><p>④保存现场和屏蔽字</p><p>【现场信息一般指程序状态字寄存器PSWR和某些通用寄存器的内容】</p><p>⑤开中断</p><p>【允许更高级的中断请求得到响应】</p><p>⑥执行中断服务程序</p><p>⑦关中断</p><p>【保证在恢复现场和屏蔽字的时候不被中断】</p><p>⑧恢复现场和屏蔽字</p><p>⑨开中断、中断返回</p><p>【中断服务程序的最后一条指令通常是一条中断返回指令，使其返回到原程序的断点处，使之继续运行】</p><p>【①②③是由硬件（中断隐指令）完成，④~⑨由中断服务程序（属于OS内核）完成】</p><p>访管指令&amp;访管中断：</p><p>处于用户态的用户程序使用访管指令时，系统根据访管指令的操作数执行访管中断处理程序，访管中断处理程序按照系统调用的操作数和参数转到相应的例行子程序。完成功能后，退出中断，返回到用户程序断点继续执行。</p><p>☆☆☆【由用户态进入核心态，不仅状态需要切换，而且所用到的堆栈也可能由用户堆栈切换成系统堆栈，并且这个系统堆栈也是属于该进程的】☆☆☆</p></blockquote><hr><h2 id="Q7：OS的体系结构"><a href="#Q7：OS的体系结构" class="headerlink" title="Q7：OS的体系结构"></a>Q7：OS的体系结构</h2><blockquote><p>【大内核：将OS的主要功能模块作为一个紧密联系的整体运行在核心态，从而为应用提供高性能的系统服务】</p><p>【微内核：将内核中最基本的功能保留，其他移到用户态】【缺点：需要频繁在用户态和核心态之间进行切换，OS执行开销大】</p></blockquote><hr><h1 id="CHAPTER-2"><a href="#CHAPTER-2" class="headerlink" title="CHAPTER 2"></a>CHAPTER 2</h1><h2 id="Q8：为什么引入进程？"><a href="#Q8：为什么引入进程？" class="headerlink" title="Q8：为什么引入进程？"></a>Q8：为什么引入进程？</h2><p>在多道程序环境下，允许程序并发执行，此时失去封闭性，并具有间断性、不可重现的特性。为此，引入进程，以便更好地描述和控制程序的执行，实现OS的并发与共享。</p><h2 id="Q9：进程的概念"><a href="#Q9：进程的概念" class="headerlink" title="Q9：进程的概念"></a>Q9：进程的概念</h2><p>进程是具有独立功能的程序在一个数据集合上的运行过程，它是系统进行资源分配和调度的一个独立单位。（引入线程后，线程是调度的基本单位）</p><p>进程是程序的一次执行过程。</p><p>进程一个程序及数据在处理机上顺序执行时所发生的活动。</p><p>进程是进程实体的运行过程，是系统进行资源分配和调度的基本单位。（进程实体/进程映像：由PCB、程序段、数据段组成；某时刻静态的进程）</p><h2 id="Q10：进程的特征"><a href="#Q10：进程的特征" class="headerlink" title="Q10：进程的特征"></a>Q10：进程的特征</h2><p>①动态性</p><p>【进程是程序的一次执行过程，是动态地产生、变化和消亡的】</p><p>②并发性</p><p>【多个进程存在于内存中，能够在同一时间段执行】</p><p>【引入进程的目的就是为了程序之间的并发执行，以提高系统吞吐量】</p><p>③独立性</p><p>【进程是一个能够独立运行，独立获取资源以及独立调度的基本单位】</p><p>【PCB是进程存在的唯一标志，凡未建立PCB的程序都不能作为一个独立单位运行】</p><p>④异步性</p><p>【由于进程的相互制约，使得进程的执行具有间断性。即进程是按照各自独立的、不可预知的速度向前推进。异步性导致了其执行结果的不可重现性。】</p><p>⑤结构性</p><p>【每个进程都是由PCB、程序段、数据段三部分组成】</p><h2 id="Q11：进程的状态及状态转换"><a href="#Q11：进程的状态及状态转换" class="headerlink" title="Q11：进程的状态及状态转换"></a>Q11：进程的状态及状态转换</h2><p>①创建态：进程正在被创建，未转到就绪态。</p><p>【创建步骤：首先申请一个空白的PCB，并向PCB中填入一些控制和管理进程的信息，然后由系统为进程分配运行时所必要的资源，最后将其转为就绪态。】</p><p>②就绪态：进程获得了除CPU以外的所有资源，一旦分配CPU即可执行。</p><p>③运行态：进程正在运行。</p><p>④阻塞态：</p><p>进程由于等待某一事件发生（如：等待I/O完成、等待除CPU外的某资源分配）而暂停运行，只有当这个事件响应时才从阻塞态转为就绪态。</p><p>【一个正在执行的进程等待某一事件而被阻塞是主动行为，因此只有运行态才可转到阻塞态。而当等待事件发生唤醒阻塞进程是被动行为，需要其他进程的协助】</p><p>⑤结束态：可能由于进程的正常结束或其他原因中断退出运行。</p><p>【进程需要结束运行时，系统首先将该进程置为结束态，然后进一步处理资源释放和回收工作】</p><p>⑥就绪挂起态</p><p>⑦阻塞挂起态：由于内存资源有限，当内存不足时将一些阻塞的进程移到外存，待内存有空闲时将其移到内存。</p><p>状态转换：</p><p>创建态 —&gt; 就绪态</p><p>—&gt; 阻塞态 【分配内存等资源不足时】</p><p>就绪态 —&gt; 运行态</p><p>—&gt; 结束态</p><p>—&gt; 就绪挂起态 【内存不足】</p><p>运行态 —&gt; 就绪态 【时间片已到/可剥夺系统中有更高优先级进程进入】</p><p>—&gt; 阻塞态 【等待某事件的发生】</p><p>【进程以系统调用的形式请求OS提供服务，这是一种特殊的、由用户态程序调用OS内核过程的形式】</p><p>—&gt; 结束态</p><p>阻塞态 —&gt; 就绪态 【等待事件的响应】</p><p>—&gt; 阻塞挂起态 【内存不足】</p><p>—&gt; 结束态</p><p>—&gt; 创建态</p><p>阻塞挂起态 —&gt; 阻塞态 【内存有空闲】</p><p>—&gt; 就绪挂起态</p><p>就绪挂起态 —&gt; 就绪态 【内存有空闲】</p><h2 id="Q12：进程的控制"><a href="#Q12：进程的控制" class="headerlink" title="Q12：进程的控制"></a>Q12：进程的控制</h2><p>进程控制的主要功能是对系统中所有的进程实施有效的管理，包括创建新进程、撤销已有进程、进程状态转换等。</p><p>①进程的创建：</p><p>【父进程可以创建子进程、子进程可以继承父进程所拥有的全部资源、当子进程撤销时应当归还所有从父进程那所获得的资源、当父进程撤销时应当撤销其所有的子进程并将所拥有的资源归还给父进程或OS】</p><p>【引发事件：终端用户登录系统、作业调度、系统提供服务、用户程序的应用请求】</p><p>创建原语：</p><p>1) OS为进程分配一个唯一的PID，并申请一个空白的PCB（PCB数量有限，申请失败则创建失败）。</p><p>2)为进程分配资源，为新进程的程序、数据及用户栈分配必要的内存空间，若资源不足则处于阻塞态，等待资源。</p><p>3)初始化PCB，主要包括初始化标志信息、初始化处理机状态信息、初始化处理机控制信息、以及设置进程优先级。</p><p>4)若就绪队列可以容纳新进程，则将其插入队列，等待被调度。</p><p>②进程的终止：</p><p>【正常结束、异常结束（存储区越界、保护错、非法指令、特权指令错、算术运算错、I/O故障错等）、外界干预】</p><p>撤销原语：</p><p>1)根据结束进程的PID检索到对应的PCB，从中读出进程状态。</p><p>2)若进程处于运行状态，则立即终止该进程的执行，将CPU分配给其他进程。</p><p>3)若进程还有子孙进程，则应将所有子孙进程撤销。</p><p>4)将进程拥有的全部资源归还给父进程或OS。</p><p>5)将PCB从所在队列删除。</p><p>③进程的阻塞和唤醒：</p><p>阻塞原语：</p><p>1)找到要阻塞进程PID对应的PCB。</p><p>2)若该进程处于运行态，则保护其现场，将状态转换为阻塞态，停止运行。</p><p>3)将该PCB插入到相应等待事件的阻塞队列，并把处理机分配给其他进程。</p><p>唤醒原语：</p><p>1)在该事件对应的阻塞队列找到相应的PCB。</p><p>2)将其从等待队列移出，并置位就绪态。</p><p>3)将PCB插入到就绪队列，等待被调度执行。</p><p>④进程的切换：</p><p>通常情况下，进程的创建、撤销及要求OS所要完成的I/O操作，都是利用系统调用进入OS内核，然后由内核中相应程序完成。进程的切换也是在内核的支持下完成的。</p><p>1)保存处理机上下文，包括程序计数器和其他寄存器。</p><p>2)更新PCB信息。</p><p>3)把进程的PCB移入到相应的等待队列。</p><p>4)选择另一个进程执行，并更新其PCB。</p><p>5)更新内存管理的数据结构。</p><p>6)恢复处理机上下文。</p><h2 id="Q13：进程的组织"><a href="#Q13：进程的组织" class="headerlink" title="Q13：进程的组织"></a>Q13：进程的组织</h2><p>进程是一个独立运行的、独立分配资源和独立调度的基本单位。</p><p>①PCB</p><p>【进程创建时，OS为其新建一个PCB，该结构之后常驻于内存，任何时刻都可以存取，该进程结束时删除。是进程存在的唯一标志。】</p><p>【进程执行时，系统要根据进程的PCB来了解进程的现行状态信息，以便对其进行控制和管理】</p><p>【当OS要调度某进程执行时，首要要从该进程的PCB中读出其现行状态及优先级；在调度某进程后，要根据其PCB所保存的处理机状态信息，设置该进程的恢复运行现场，并根据其PCB中程序和数据的内存地址，找到对应的程序和数据；进程在运行的过程中要与与之合作的进程实现同步、通信和访问文件也要访问PCB；当进程由于某种原因暂停运行时，要将其断点的处理机现场信息保存到PCB中去】</p><p>1) 进程的描述信息</p><p>【PID（每个进程都有唯一的）、UID（进程的归属用户，主要用于保护和共享）】</p><p>2) 进程控制和管理信息</p><p>进程的当前状态信息、进程优先级、代码运行入口地址、程序的外存地址、进入内存的时间、处理机占用时间、信号量使用</p><p>3) 资源分配清单</p><p>【用于说明有关内存地址空间或虚拟地址空间的状况，打开的文件列表和所使用的的输入/输出设备信息】</p><p>代码段指针、数据段指针、堆栈段指针、文件描述符、键盘、鼠标</p><p>4) 处理机相关信息</p><p>【主要指CPU中各寄存器的值，当进程切换时，处理机状态信息必须保存到相应的PCB中，以便进程再重新运行可以恢复到断点处继续执行】</p><p>通用寄存器值、地址寄存器值、控制寄存器值、标志寄存器值、状态字</p><p>②程序段</p><p>能被进程调度程序调度到CPU执行的程序代码段。</p><p>③数据段</p><p>可以是进程对应程序加工处理的原始数据，也可以是程序执行时产生的中间或最终结果。</p><h2 id="Q14：进程的通信"><a href="#Q14：进程的通信" class="headerlink" title="Q14：进程的通信"></a>Q14：进程的通信</h2><p>进程通信是指进程之间的信息交换。P/V操作是低级通信方式，高级通信方式是指以较高效率传输大量数据的通信方式。</p><p>高级通信方式：</p><p>①共享存储</p><p>【在通信进程之间存在一块可以直接访问的共享空间，通过对这片共享空间的读/写操作实现进程间的信息交换。在对共享进行读/写操作时，要用到进程同步互斥工具】</p><p>1)基于数据结构的共享：低级方式</p><p>2)基于存储区的共享：高级方式</p><p>【OS只负责为通信进程提供可共享使用的存储空间以及同步互斥工具，而数据交换则是由用户自己安排读/写指令完成的】</p><p>【用户进程空间一般是独立的，进程运行期间一般是不能访问其他进程的空间，想实现进程间的通信，必须通过特殊的系统调用实现，而进程内的线程共享该进程的全部资源】</p><p>②消息传递</p><p>进程之间的数据交换是以格式化的消息为单位的。进程提供系统提供的发送和接收原语实现数据交换。</p><p>1) 直接通信方式：</p><p>【发送进程直接将消息发送给接收进程，并把它挂在接收进程的消息缓冲队列上，然后接收进程从其消息缓冲队列中取得消息】</p><p>2) 间接通信方式/信箱通信方式：</p><p>【发送进程将消息发送给某个中间实体（信箱），然后接收进程从其中取得消息】</p><p>③管道通信</p><p>是消息传递的一种特殊方式。</p><p>【管道pipe：是指用于连接一个读进程和一个写进程以及实现它们之间通信的一个共享文件】</p><p>【写进程以字符流形式将大量数据送入管道，读进程则从管道中接收数据】</p><p>【管道实际上是一个固定大小的缓冲区。Linux中其大小为4KB。从管道中读数据是一次性操作，数据一旦被读取就从管道中抛弃。管道通信只能采用半双工的通信方式，即某一时刻只能单向传输。】</p><p>【缓冲区只允许进程一边写入、一边读出。只有当写进程将缓冲区写满时，读进程才可以去读取。只有当读进程将数据全部从缓冲区中读出时，写进程才可以写入】</p><h2 id="Q15：线程及多线程模型"><a href="#Q15：线程及多线程模型" class="headerlink" title="Q15：线程及多线程模型"></a>Q15：线程及多线程模型</h2><p>①引入线程的目的：</p><p>​ 是为了更好地使多道程序并发执行，提高资源利用率及系统吞吐量。</p><p>​</p><p>②线程的概念：</p><p>线程是一个基本的CPU执行单元，也是程序流的一个最小单元，由线程ID、程序计数器、其他寄存器和堆栈构成。线程是系统调度的基本单位，它只拥有一点儿在程序中运行必不可少的资源，但它可以和同一个所属进程中的线程共享进程拥有的全部资源。</p><p>​ ③线程与进程的比较：</p><p>1) 调度：</p><p>对于传统的OS中，进程是OS进行调度和资源分配的基本单位；引入线程后，线程是OS进行调度的基本单位，进程是资源分配的基本单位。</p><p>同一个进程中的线程进行切换时，进程不会发生切换；但线程和其他进程中的线程发生切换时，进程发生切换。</p><p>2) 拥有资源：</p><p>不管是传统的OS，还是引入Thread之后的OS，进程都是系统进行资源分配的基本单位，而线程不拥有资源（只拥有一点儿必不可少的资源），但线程可以访问所属进程拥有的全部资源。</p><p>若线程也是资源分配的基本单位，那么在线程切换时就需要很大的时空开销，引入线程就几乎没有意义了。</p><p>3) 并发性：</p><p>引入线程的OS，不仅进程间可并发执行，多个线程也可并发执行，使OS具有更好的并发性，提高了系统的吞吐量。</p><p>4) 系统开销：</p><p>由于进程创建和撤销时，系统都要为之分配和回收资源，如内存空间、I/O设备等，因此系统所付出的时空开销远大于创建和撤销线程时的开销。</p><p>在进程进行切换时，涉及到当前执行进程的CPU环境保存以及新调度进程CPU环境的设置，而线程切换只需要保存和设置少量的寄存器内容，开销小。</p><p>由于进程的线程共享进程拥有的全部资源，因此进程内的线程通信容易实现，甚至无需系统的干预。</p><p>5) 地址空间和其他资源：</p><p>进程的地址空间之间相互独立（OS利用硬件地址机制对进程的地址空间进行了严格的保护），而进程内各线程共享进程的全部资源。</p><p>6) 通信：</p><p>进程间通行(IPC)需要借助进程的同步互斥工具，而线程之间通信可以直接读/写进程数据段来进行通信。</p><p>​</p><p>​ ④线程的实现方式：</p><p>1) 用户级线程(ULT)：</p><p>有关线程的管理（创建、撤销、切换等）的工作都是由应用程序完成的，内核意识不到线程的存在。应用程序可以通过使用线程库来设计多线程程序。通常，应用程序从单线程开始，在其运行的任意时刻，可以通过线程库中的派生例程创建一个同一进程内的线程。</p><p>2) 内核级线程(KLT)：</p><p>线程的管理工作都是由OS内核完成的，应用程序没有直接对线程进行管理的代码，只是有一个到内核级进程的接口。内核为进程内的各线程维护上下文信息，调度也是在内核基于线程结构的基础上完成。</p><p>​</p><p>​ ⑤多线程模型：</p><p>​ 有些系统同时支持ULT以及KLT。</p><p>1) 多对一模型：</p><p>多个ULT映射到一个KLT，ULT管理是在用户空间完成的，对OS透明。</p><p>【优点：线程管理是在用户空间进行的，因此效率比较高。】</p><p>【缺点：一个线程在使用内核服务时被阻塞，整个进程都会被阻塞，多个线程不能并行地运行在多个处理机上。】</p><p>2) 一对一模型：</p><p>一个ULT映射到一个KLT。</p><p>【优点：当一个线程被阻塞后，允许其他线程继续执行，并发能力强。】</p><p>【缺点：每创建一个ULT，都要创建一个KLT与之对应，这样创建线程的开销比较大，会影响到应用程序的性能。】</p><p>3) 多对多模型：</p><p>m个ULT映射到n个KLT（m&gt;=n）。</p><p>【特点：既克服了多对一模型并发度不高的缺点，又克服了一对一模型的一个ULT对应一个KLT开销大的缺点。同时具有两者的优点。】</p><h2 id="Q16：调度层次"><a href="#Q16：调度层次" class="headerlink" title="Q16：调度层次"></a>Q16：调度层次</h2><p>当系统中的作业/进程数高于当前可以进行执行的时候，就要涉及到调度。</p><p>一个从提交直到完成，往往要经历三级调度：</p><p>①作业调度/高级调度：</p><p>按照一定的调度原则从外存上处于后备状态的作业队列中挑选一个或多个作业，给它们创建相应进程，并且分配内存、输入/输出设备等必要资源，使之有竞争处理机的权利。</p><p>多道批处理系统中大多配有作业调度，而其他系统中通常不需要配置作业调度。作业调度执行的频率较低，通常为几分钟一次。</p><p>​</p><p>②内存调度/中级调度：</p><p>其作用是提高内存利用率和系统吞吐量。为此，把那些暂时不能运行的进程调至外存等待（把此时进程所处的状态称为挂起态），当它们具备了运行条件并且内存又稍有空闲时，由中级调度决定把那些外存上具备运行条件的就绪进程再重新调入内存，并修改为就绪态，挂在就绪队列上等待被调度。</p><p>③进程调度/低级调度：</p><p>是按照某种方法和策略从就绪队列中选取一个进程，并为之分配处理机。进程调度的频率很高，通常几十毫秒一次。</p><p>【进程调度和进程切换是OS内核程序进行操作的。】</p><p>l 在现代OS中，不能进行进程调度和切换的情况：</p><p>1) 在处理中断的过程中。</p><p>2) 进程在OS内核临界区中。</p><p>3) 其他需要完全屏蔽中断的原子操作过程中。</p><p>（若在上述条件下发生了进程调度请求，则应置请求调度标志，等上述情况结束后再进行进程的调度与切换）</p><p>l 在现代OS中，应该进行进程调度和切换的情况：</p><p>1) 发生引起调度的条件且当前进程无法继续执行下去的时候，可以马上进行进程调度与切换；（若OS只在这种情况下进行中级调度，则是实现非剥夺方式的调度）</p><p>2) 中断/异常处理结束后，返回被中断进程的用户态程序执行现场前，若置上请求调度标志，即可立马进行进程调度与切换。（若OS支持在这种情况下进行中级调度，则是实现了剥夺方式的调度）</p><p>【进程的切换往往在进程调度完成后立即发生，它要求保存原进程的当前切换点的现场信息，以及恢复被调进程的现场信息。现场切换时，OS内核将原进程的现场信息推入到当前进程的内核堆栈中，并更新堆栈指针】</p><p>【内核完成从新进程的内核栈中装入新进程的现场信息、更新当前运行进程空间指针、重设PC寄存器等相关工作后，开时运行新进程】</p><p>​</p><p>进程的调度方式：</p><p>（即当某个进程正在运行时，有个更为重要或紧迫的进程进入就绪队列时，此时如何分配处理机）</p><p>1) 非剥夺调度方式/非抢占方式：</p><p>继续运行，直至进程执行完或发生某种事件进入阻塞队列时，才将处理机分配给这个更为重要或紧迫的进程。</p><p>2) 剥夺调度方式/抢占方式：</p><p>立即停止执行当前运行进程，将处理机分配给这个更为重要或紧迫的进程。</p><p>【采用剥夺式的调度，对提高系统吞吐量以及响应效率都有明显好处。但“剥夺”不是一种任意行为，需要遵循一定原则，如：优先权、时间片、短进程优先等】</p><h2 id="Q17：调度的基本准则"><a href="#Q17：调度的基本准则" class="headerlink" title="Q17：调度的基本准则"></a>Q17：调度的基本准则</h2><p>①CPU利用率</p><p>CPU是系统最重要和昂贵的资源之一，应使得CPU总处于“忙”的状态，使得其资源利用率最高。</p><p>②系统吞吐量</p><p>表示单位时间内完成的作业数量。长作业需耗较长的处理机时间，因此会降低系统吞吐量；而短作业需要消耗的处理机时间短，会提高系统吞吐量。调度算法和方式的不同，也会对系统吞吐量产生较大的影响。</p><p>③周转时间</p><p>是指从作业提交到完成所经历的时间。</p><p>带权周转时间：是指作业的周转时间和实际运行时间的比值。</p><p>④等待时间</p><p>是指进程处于等待处理机状态的时间之和。</p><p>【处理机调度算法实际上并不影响作业执行或输入/输出操作的时间，只影响进程在就绪队列等待所花的时间。因此衡量一个低级调度算法，只需简单地考察等待时间即可。】</p><p>⑤响应时间</p><p>是指从用户提交请求到系统首次产生响应所用的时间。</p><p>【在交互式系统中，一般将响应时间作为衡量调度算法的重要依据之一。】</p><h2 id="Q18：典型的调度算法"><a href="#Q18：典型的调度算法" class="headerlink" title="Q18：典型的调度算法"></a>Q18：典型的调度算法</h2><p>①先来先服务调度算法FCFS</p><p>（适用于作业调度、进程调度）（不可剥夺算法）</p><p>在作业调度中，算法每次从后备队列中选择最先进入的一个或几个作业，把它们调入内存，为其分配必要的资源，创建进程并放入就绪队列。</p><p>在进程调度中，算法每次从就绪队列中选择最先进入该队列的进程，分配处理机使之运行，直至完成或因某事件而阻塞才释放处理机。</p><p>【特点：算法简单，但效率低；对长作业有利，对短作业不利（相对于SJF和高响应比优先）；有利于CPU繁忙型作业，不利于I/O繁忙型作业。】</p><p>​</p><p>②短作业/进程优先调度算法:</p><p>【平均等待时间、平均周转时间最少】</p><p>SJF从后备队列中选择一个或若干个估计运行时间最短的作业，把它们调入到内存运行。</p><p>SPF从就绪队列中选择一个估计运行时间最短的作业，把处理机分配给它，使之得以运行，直至完成或发生某事件而阻塞时才释放处理机。</p><p>【缺点：对长作业不利，有可能导致“饥饿”现象；未考虑作业的紧迫程度，不能保证紧迫作业及时处理；由于作业长短是依据用户提供的估计运行时间而定的，使得该算法不一定能够真正做到短作业优先调度。】</p><p>​</p><p>③优先级调度算法：</p><p>（适用于作业调度、进程调度）（适用于实时OS）</p><p>在作业调度中，该算法从作业后备队列中选择一个或若干个优先级最高的作业调入内存运行。</p><p>在进程调度中，该算法从就绪队列中选择一个优先级最高的进程，为之分配处理机，使之得以运行。</p><p>​</p><p>依据当某进程正在运行时，此时有更高优先级的进程进入就绪队列，此时如何分配处理机，可分为：</p><p>1) 非剥夺式优先级调度算法：</p><p>继续运行，直至进程执行完或发生某种事件进入阻塞队列时，才将处理机分配给这个更为重要或紧迫的进程。</p><p>2) 剥夺式优先级调度算法：</p><p>立即停止执行当前运行进程，将处理机分配给这个更为重要或紧迫的进程。</p><p>​</p><p>进程的优先级：</p><p>1) 静态优先级：</p><p>优先级是在创建进程时确定的，且在进程的整个运行期间保持不变。</p><p>设置的主要依据有进程类型、进程对资源的要求、用户要求。</p><p>2) 动态优先级：</p><p>在进程运行过程中，根据进程状态情况变化动态调整优先级。</p><p>设置的主要依据有进程占CPU时间长短、就绪进程等待CPU时间长短。</p><p>​</p><p>优先级设置参考原则：</p><p>系统进程 &gt; 用户进程</p><p>交互型进程 &gt; 非交互型进程</p><p>I/O型进程 &gt; CPU型进程</p><p>​</p><p>④高响应比优先调度算法：</p><p>（适用于作业调度）（适用于分时OS）</p><p>响应比：=（等待时间 +要求服务时间）/ 要求服务时间。</p><p>【作业等待时间相同时，要求服务时间越短，响应比越高，即有利于短作业；】</p><p>【要求服务时间相同时，等待时间越长，响应比越高，因而它实现的是FCFS；】</p><p>【对于长作业，作业的响应比可以随等待时间增加而提高，当等待时间足够长时，其响应比也很高，从而获得处理机得以运行。因此克服了“饥饿”，兼顾了长作业。】</p><p>⑤时间片轮转调度算法：</p><p>（适用于进程调度）（适用于分时OS）</p><p>在这种算法中，系统将所有就绪进程按照到达时间的先后次序排成一个队列，进程调度程序总是选择该队列中第一个进程执行，但只能执行一个时间片。</p><p>当使用完一个时间片后，即使该进程并未完成，也要释放处理机给下一个就绪进程，而被剥夺的进程返回该队列尾部重新排队，等待再次运行。</p><p>【若时间片足够大，以至于所有进程都可以在一个时间片内被执行完成，则该算法退化为FCFS。】</p><p>【若时间片很小，则处理机在进程间过于频繁切换，使得处理机开销增发，真正用于运行用户进程的时间将减少。】</p><p>【时间片长短影响因素：系统的响应时间、就绪队列的进程数目、系统处理能力。】</p><p>⑥多级反馈队列调度算法：</p><p>（适用于进程调度）（适用于分时OS）</p><p>1) 设置多个就绪队列，并为各个队列赋予不同的优先级，第1级队列优先级最高，其他队列优先级依次降低；</p><p>2) 赋予各个队列的时间片大小互不相同。在优先级越高的队列中，每个进程的运行时间片越小。</p><p>3) 一个新进程进入内存后，首先置于第1级队列的末尾，按照FCFS原则排队等待调度。当轮到该进程被调度时，若它能够在时间片内运行完成，则可准备撤销该进程；否则，调度程序将其置于第2级队列的末尾，同样按照FCFS的原则等待被调度。….如此下去，一个长进程从第1级队列降到第n级队列时，在第n级队列中按时间片轮转的方式执行。</p><p>4) 仅当第k级队列以及之前所有队列为空时，调度程序才调度第k+1级队列。若处理机正在执行第i级队列中的某个进程，这时有新进程进入到更高级别的队列中，则此时新进程将抢占正在运行进程的处理机，即调度程序将正在运行的进程置于第i级队列的末尾，然后将处理机分配给新到的更高优先级的进程。</p><p>【特点：终端型作业用户：短作业优先；短批处理作业用户：周转时间较短；长批处理作业用户：经过前面几个队列得到部分执行，不会长期得不到执行。】</p><p>​</p><h2 id="Q19：进程同步"><a href="#Q19：进程同步" class="headerlink" title="Q19：进程同步"></a>Q19：进程同步</h2><p>①为什么引入进程同步概念：</p><p>在多道程序环境下，不同进程之间存在着不同的相互制约关系，为了协调进程间的相互制约关系，引入了进程同步概念。</p><p>②临界资源及临界区：</p><p>临界资源：是指在同一时间段内只能由一个进程进行访问的资源。对临界资源的访问必须是互斥的。</p><p>临界区：是指进程中用于访问临界资源的那段代码。</p><p>③对临界资源的访问过程分为：</p><p>1) 进入区：</p><p>为了进入临界区使用临界资源，在进入区检查是否可进入临界区，若能进入则应设置正在访问临界区的标志，以避免其它进程同时进入临界区。</p><p>2) 临界区/临界段：</p><p>进程中用于访问临界资源的那段代码。</p><p>3) 退出区：</p><p>将正在访问临界区的标志清除。</p><p>4) 释放区：</p><p>代码其余部分。</p><p>④同步及互斥：</p><p>同步（直接制约关系）：</p><p>是指为了完成某种任务而创建的两个或多个进程，这些进程因为在某些位置上协调它们的工作次序、传递信息而产生的制约关系。</p><p>互斥（间接制约关系）：</p><p>是指当一个进程临界区访问临界资源时，其他想要访问该资源的进程必须等待，当该进程从临界区退出后，才允许进入临界区访问临界资源。</p><p>​</p><p>为了使进程互斥进入临界区，同步机制应遵循的原则：</p><p>1) 空闲让进：临界区空闲时，允许一个请求该资源的进程立即进入临界区。</p><p>2) 忙则等待：当已有进程进入临界区时，其他想要进入该临界区的进程等待。</p><p>3) 有限等待：对于请求访问的进程，应保证能在有限时间内进行响应。</p><p>4) 让权等待：当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</p><h2 id="Q20：实现临界区互斥的基本方法"><a href="#Q20：实现临界区互斥的基本方法" class="headerlink" title="Q20：实现临界区互斥的基本方法"></a>Q20：实现临界区互斥的基本方法</h2><p>①软件方法：</p><p>在进入区设置并检查一些标志来表明是否有进程在临界区中，若已有进程在临界区，则在进入区通过循环检查进行等待，进程离开临界区后在退出区修改标志。</p><p>1) 单标志检查法：</p><p>通过设置一个公用整型变量turn，用于指示被允许进入临界区的进程编号。该算法可确保每次只有一个进程被允许进入临界区。</p><p>但两个进程必须交替进入临界区，若某个进程不再进入临界区，那么另一个进程也将无法进入临界区（违背“空闲让进”），容易造成资源利用不充分。</p><p>…</p><p>PROCESS_P0:</p><p>while(turn != 0);</p><p>critical section;</p><p>turn = 1;</p><p>remainder section;</p><p>…</p><p>…</p><p>PROCESS_P1:</p><p>while(turn != 1);</p><p>critical section;</p><p>turn = 0;</p><p>remainder section;</p><p>…</p><p>​</p><p>2) 双标志先检查法:</p><p>该算法的思想是在进入临界区之前先检查临界资源是否被访问，若正在被访问则需等待，否则进入自己的临界区。</p><p>通过设置布尔型数据flag[i]，若为TRUE表示Pi进程进入临界区。优先：不用交替使用，可连续使用。缺点：两个进程可同时进入临界区（违背“忙则等待”）。</p><p>…</p><p>PROCESS_Pi:</p><p>while(flag[j]);</p><p>flag[i] = TRUE;</p><p>critical section;</p><p>flag[i] = FALSE;</p><p>remainder section;</p><p>…</p><p>…</p><p>PROCESS_Pj:</p><p>while(flag[i]);</p><p>flag[j] = TRUE;</p><p>critical section;</p><p>flag[j] = FALSE;</p><p>remainder section;</p><p>…</p><p>​</p><p>3) 双标志后检查法：</p><p>由于双标志先检查是先检查临界区是否正在被访问然后来设置自己的标志，因此有可能会导致检查完执行另一个进程，进而导致出现两个进程同时访问的情况。</p><p>因此，通过先设置自己标志然后在检查来避免这种情况的发生。</p><p>缺点：会出现两个进程都想进入临界区，由于互相相互谦让而导致都不能进入临界区，从而导致“饥饿”现象。</p><p>…</p><p>PROCESS_Pi:</p><p>flag[i] = TRUE;</p><p>while(flag[j]);</p><p>critical section;</p><p>flag[i] = FALSE;</p><p>remainder section;</p><p>…</p><p>…</p><p>PROCESS_Pj:</p><p>flag[j] = TRUE;</p><p>while(flag[i]);</p><p>critical section;</p><p>flag[j] = FALSE;</p><p>remainder section;</p><p>…</p><p>4) Peterson’s 算法</p><p>为了防止双标志后检查的两个进程无限期等待的情况发生，又设置了变量turn（不允许进入标志），每个进程在设置完自己的标志后再设置turn标志，这时再检查另一个进程的状态标志和不允许进入标志，以便两个进程同时请求进入临界区时，只允许一个进程进入。</p><p>…</p><p>PROCESS_Pi:</p><p>flag[i] = TRUE;turn = j;</p><p>while(flag[j] &amp;&amp; turn == j);</p><p>critical section;</p><p>flag[i] = FALSE;</p><p>remainder section;</p><p>…</p><p>…</p><p>PROCESS_Pj:</p><p>flag[j] = TRUE;turn = i;</p><p>while(flag[i] &amp;&amp; turn == i);</p><p>critical section;</p><p>flag[j] = FALSE;</p><p>remainder section;</p><p>…</p><p>②硬件方法：</p><p>计算机提供了特殊的硬件指令，允许对一个字进行检查和修正，或对两个字的内容进行交换等。通过硬件实现临界段问题的方法为低级方法/元方法。</p><p>1) 中断屏蔽：</p><p>当一个进程正在使用处理机执行它的临界区代码时，防止其他进程进入临界区进行访问的最简方法是，禁止一切中断的发生，即屏蔽中断。因为CPU只有在发生中断时引起进程切换，屏蔽中断可以让当前运行的进程让临界区代码顺利地执行完。</p><p>缺点：限制了处理机交替执行程序的能力；对于内核来说，在它执行更新变量或列表的几条指令期间，关中断是很方便的；但将关中断的权力交给用户则很不明智，当一个程序关中断后不再开中断，系统则很可能因此而终止。</p><p>…</p><p>关中断</p><p>临界区</p><p>开中断</p><p>…</p><p>​</p><p>2) 硬件指令方法：</p><p>TestAndSet指令：</p><p>这条指令是原子操作，及执行该代码时不可被中断。其功能是读出指定的标志后把该标志设置为真。</p><p>…</p><p>boolean TestAndSet(boolean *lock){</p><p>boolean old;</p><p>old = *lock;</p><p>*lock = true;</p><p>return old;</p><p>}</p><p>…</p><p>可以为每个临界资源设置一个共享布尔变量lock，表示资源的两种状态：true表示正被占用；初值为false。在进程进入临界区之前，通过该指令进行检查和修改标志lock，直至进程退出。</p><p>…</p><p>while(TestAndSet(&amp;lock));</p><p>critical section;</p><p>lock = false;</p><p>remainder section;</p><p>…</p><p>​</p><p>Swap指令：该指令的功能是交换两个字的内容。</p><p>…</p><p>Swap(boolean <em>a, boolean </em>b){</p><p>boolean temp;</p><p>temp = *a;</p><p><em>a = </em>b;</p><p>*b = temp;</p><p>}</p><p>…</p><p>可以为每个临界资源设置一个共享布尔变量lock，初值为false。在每个进程中设置一个局部布尔变量key，用于与lock交换信息。在进入临界区前，先利用该指令交换内容，然后检查key的状态。</p><p>…</p><p>key = true;</p><p>while(key != false){</p><p>Swap(&amp;lock,&amp;key);</p><p>}</p><p>critical section;</p><p>lock = false;</p><p>remainder section;</p><p>…</p><p>硬件方法的优点：</p><p>适用于任意数目的进程，而不管是处于单处理机还是多处理机；简单、容易验证其正确性；可以支持进程内有多个临界区，只需为每个临界区设立一个布尔变量。</p><p>缺点：进程等待进入临界区要耗费处理机时间，不能实现让权等待。从等待进程中随机选择一个进程进入临界区，有的进程可能一直选不上，从而导致出现“饥饿”现象。</p><p>③信号量：</p><p>信号量机制是一种功能较强的机制，可以用来解决互斥和同步问题。它只能被两个标准的原语进行访问（signal(S)、wait(S)）。</p><p>原语通常由硬件实现；原语的不可中断性在单处理机上可由软件通过屏蔽中断的方法实现。</p><p>1) 整型信号量：</p><p>被定义为一个用于表示资源数目的整型量S。</p><p>…</p><p>wait(S){</p><p>while(S &lt;= 0);</p><p>S = S - 1;</p><p>}</p><p>signal(S){</p><p>S = S + 1;</p><p>}</p><p>…</p><p>该机制并未遵循“让权等待”，而是使进程处于“忙等”状态。</p><p>​</p><p>2) 记录型信号量：</p><p>该机制是不存在“忙等”现象的，除了需要一个表示资源数目的整型变量value外，再增加一个进程链表L。</p><p>typedef struct{</p><p>int value;</p><p>struct process *L;</p><p>}semaphore;</p><p>…</p><p>void wait(semaphore S){</p><p>S.value—;</p><p>if(S.value &lt; 0){</p><p>add this process to S.L;</p><p>block(S.L);</p><p>}</p><p>}</p><p>…</p><p>…</p><p>void signal(semaphore S){</p><p>S.value++;</p><p>if(S.value &lt;= 0){</p><p>remove a process P from S.L;</p><p>wakeup(P);</p><p>}</p><p>}</p><p>…</p><p>​</p><p>3) 利用信号量实现同步、互斥、进程前驱关系</p><p>a. 实现同步：</p><p>操作A执行完再执行操作B；</p><p>semaphore S = 0;</p><p>…</p><p>PROCESS_Pa{</p><p>…</p><p>操作A;</p><p>V(S);</p><p>…</p><p>}</p><p>PROCESS_Pb{</p><p>…</p><p>P(S);</p><p>操作B;</p><p>…</p><p>}</p><p>…</p><p>​</p><p>b. 实现互斥：</p><p>临界资源数目为m;</p><p>semaphore S = m;</p><p>…</p><p>PROCESS_Pa{</p><p>…</p><p>P(S);</p><p>critical section;</p><p>V(S);</p><p>…</p><p>}</p><p>PROCESS_Pb{</p><p>…</p><p>P(S);</p><p>critical section;</p><p>V(S);</p><p>…</p><p>}</p><p>…</p><p>​</p><p>c. 实现前驱关系：</p><p>eg：P1-&gt;P2-&gt;P4; P1-&gt;P3-&gt;P4;</p><p>semaphore S_12=0,S_13=0,S_24=0,S_34=0;</p><p>…</p><p>PROCESS_P1{</p><p>…</p><p>V(S_12);</p><p>V(S_13);</p><p>}</p><p>PROCESS_P2{</p><p>P(S_12);</p><p>…</p><p>V(S_24);</p><p>}</p><p>PROCESS_P3{</p><p>P(S_13);</p><p>…</p><p>V(S_34);</p><p>}</p><p>PROCESS_P4{</p><p>P(S_24);</p><p>P(S_34);</p><p>…</p><p>}</p><p>…</p><p>④管程：</p><p>1) 引入管程目的：</p><p>在信号量机制中，每个访问临界资源的进程都必须自备同步的P/V操作，大量分散的同步机制给系统管理带来了麻烦，且容易因同步操作不当而导致系统死锁。</p><p>管程的特性保证了进程互斥，无需程序员自己实现互斥，从而降低了死锁发生的可能性。同时管程提供了条件变量，可以让程序员灵活地实现进程同步。</p><p>2) 管程(monitor)：</p><p>代表系统中共享资源的数据结构，以及对该共享数据结构实施操作的一组过程所组成的资源管理程序。</p><p>【管程对共享资源的操作封装起来；每次只允许一个进程进入管程，从而实现进程互斥。】</p><p>3) 管程的组成：</p><p>管程名字、局部于管程内部的共享数据结构说明、对该数据结构进行操作的一组过程、对局部于管程内部的共享数据设置初始化语句。</p><p>4) 条件变量：</p><p>当一个进程进入管程后发生阻塞，直到阻塞原因解除，在此期间若进程不释放管程，那么其他进程无法进入管程。因此，将阻塞的原因定义为条件变量condition。</p><p>通常，由于阻塞原因有多个，所以管程内部的条件变量也有多个，每个条件变量保存了一个队列，用于记录因此条件变量而阻塞的所有进程；对条件变量的操作只有两种wait和signal。</p><p>x.wait:</p><p>当x所对应的条件不满足时，正在调用管程的进程调用x.wait将自己插入到x条件的等待队列，并释放管程。此时其他进程可以使用管程。</p><p>x.signal:</p><p>x对应的条件发生了变化，则调用x.signal，唤醒一个因x条件而被阻塞的进程。</p><p>5) 信号量 &amp; 条件变量：</p><p>相似点：条件变量的wait/signal操作类似于信号量的P/V操作，可以实现进程的阻塞与唤醒；</p><p>不同点：条件变量仅实现了“排队功能”功能；而信号量的值反应了剩余资源数目，而在管程中用共享数据结构记录剩余资源数目。</p><p>…</p><p>monitor demo{</p><p>共享数据结构S；</p><p>condition x;</p><p>init_code{…};</p><p>take_away(){</p><p>if(S&lt;=0) x.wait();</p><p>资源足够，分配资源，做相应处理；</p><p>}</p><p>give_back(){</p><p>归还资源，作相应处理；</p><p>if(有进程在等待) x.signal();</p><p>}</p><p>}</p><p>…</p><h2 id="Q21：经典同步问题"><a href="#Q21：经典同步问题" class="headerlink" title="Q21：经典同步问题"></a>Q21：经典同步问题</h2><p>①生产者-消费者问题</p><p>Que1: 一组生产者和一组消费者进程共享一个初始为空、大小为n的缓冲区。只有当缓冲区未满时，生产者才可以将消息放入缓冲区；只有当缓冲区未空时，消费者才可以把消息从缓冲区取出。由于缓冲区是临界资源，它只允许一个生产者放入消息，或一个消费者取出消息。</p><p>​</p><h6><a href="#" class="headerlink" title="#"></a>#</h6><p>semaphore mutex = 1; //临界区互斥信号量</p><p>semaphore empty = n; //空闲缓冲区</p><p>semaphore full = 0; //缓冲区初始化为空</p><p>produce(){</p><p>while(1){</p><p>produce a product of A;</p><p>P(empty);</p><p>P(mutex);</p><p>add A to buffer;</p><p>V(mutex);</p><p>V(full);</p><p>}</p><p>}</p><p>consumer(){</p><p>while(1){</p><p>P(full);</p><p>P(mutex);</p><p>remove A from buffer;</p><p>V(mutex);</p><p>V(empty);</p><p>}</p><p>}</p><h6 id="-1"><a href="#-1" class="headerlink" title="#"></a>#</h6><p>​</p><p>Que2: 一个盘子只能放一个水果，爸爸只放apple，妈妈只放orange，儿子只拿orange，女儿只拿apple。</p><p>​ ################</p><p>semaphore plate = 1; //对盘子临界资源互斥访问 //对应Que1中的mutex及empty</p><p>semaphore apple = 0; //对应Que1中的full</p><p>semaphore orange = 0; //对应Que1中的full</p><p>PROCESS_papa(){</p><p>…</p><p>P(plate);</p><p>put an apple on the plate;</p><p>V(apple);</p><p>…</p><p>}</p><p>PROCESS_mom(){</p><p>…</p><p>P(plate);</p><p>put an orange on the plate;</p><p>V(orange);</p><p>…</p><p>}</p><p>PROCESS_son(){</p><p>…</p><p>P(orange);</p><p>take the orange from the plate;</p><p>V(plate);</p><p>…</p><p>}</p><p>PROCESS_daughter(){</p><p>…</p><p>P(apple);</p><p>take the apple from the plate;</p><p>V(plate);</p><p>…</p><p>}</p><h6 id="-2"><a href="#-2" class="headerlink" title="#"></a>#</h6><p>②吸烟者问题</p><p>Que: 假设一个系统有三个吸烟者进程和一个供应者进程。每个吸烟者不停地卷烟并抽掉他。卷烟需要三种材料：烟草、纸、胶水。三个吸烟者中，第一个有烟草、第二个有纸、第三个有胶水。供应者无限地提供三种材料，每次将两种材料放在桌子上，拥有剩下一种的吸烟者拿起材料，卷烟并抽掉他，并给供应者一个信号告诉已完成，此时供应者就会将另外两种材料放在桌子上。</p><h6 id="0"><a href="#0" class="headerlink" title="## 0"></a>## 0</h6><p>int num = 0;</p><p>semaphore offer1 = 0;</p><p>semaphore offer2 = 0;</p><p>semaphore offer3 = 0;</p><p>semaphore finish = 0; //完成信号量</p><p>PROCESS_P0(){ //供应者</p><p>while(1){</p><p>num++;</p><p>num = num % 3;</p><p>if(num == 0)</p><p>V(offer1);</p><p>if(num == 1)</p><p>V(offer2);</p><p>if(num == 2)</p><p>V(offer3);</p><p>P(finish);</p><p>}</p><p>}</p><p>PROCESS_P1(){</p><p>while(1){</p><p>P(offer1);</p><p>拿起纸、胶水，卷烟并抽掉；</p><p>V(finish);</p><p>}</p><p>}</p><p>PROCESS_P2(){</p><p>while(1){</p><p>P(offer2);</p><p>拿起烟草、胶水，卷烟并抽掉；</p><p>V(finish);</p><p>}</p><p>}</p><p>PROCESS_P3(){</p><p>while(1){</p><p>P(offer3);</p><p>拿起烟草、纸，卷烟并抽掉；</p><p>V(finish);</p><p>}</p><p>}</p><h6 id="-3"><a href="#-3" class="headerlink" title="#"></a>#</h6><p>③读者/写者问题</p><p>Que: 读者、写者两组进程共享一个文件。要求：允许多个读者可以同时对文件进行读操作、只允许一个写者往文件中写信息、任一写者在完成写操作之前不允许其他读/写进程工作、写者执行写操作之前其他已有的读者和写者应全部退出。</p><h6 id="0-1"><a href="#0-1" class="headerlink" title="## 0"></a>## 0</h6><p>int count = 0; //记录当前读者数量</p><p>semaphore mutex = 1; //用于保护和更新count变量时的互斥</p><p>semaphore rw = 1; //用于实现读/写的互斥</p><p>writer(){</p><p>​ while(1){</p><p>​ P(rw);</p><p>​ writing;</p><p>​ V(rw);</p><p>​ }</p><p>}</p><p>reader(){</p><p>​ while(1){</p><p>​ P(mutex);</p><p>​ count++;</p><p>​ if(count == 1)</p><p>​ P(rw);</p><p>​ V(mutex);</p><p>​ reading;</p><p>​ P(mutex);</p><p>​ count—;</p><p>​ if(count == 0)</p><p>​ V(rw);</p><p>​ V(mutex);</p><p>​ }</p><p>}</p><h6 id="-4"><a href="#-4" class="headerlink" title="#"></a>#</h6><p>上述的算法中，读进程是优先，即存在读进程时，写进程将被延迟，若至少有一个的读进程活跃，那么随后的写进程都将被阻塞，有可能出现写进程“饿死”情况。</p><h6 id="1"><a href="#1" class="headerlink" title="## 1"></a>## 1</h6><p>int count = 0; //记录当前读者数量</p><p>semaphore mutex = 1; //用于保护和更新count变量时的互斥</p><p>semaphore rw = 1; //用于实现读/写的互斥</p><p>semaphore w = 1; //</p><p>writer(){</p><p>​ while(1){</p><p>​ P(w);</p><p>​ P(rw);</p><p>​ writing;</p><p>​ V(rw);</p><p>​ V(w); //恢复对共享文件的访问</p><p>​ }</p><p>}</p><p>reader(){</p><p>​ while(1){</p><p>​ P(w);</p><p>​ P(mutex);</p><p>​ count++;</p><p>​ if(count == 1)</p><p>​ P(rw);</p><p>​ V(mutex);</p><p>​ V(w); //恢复对共享文件的访问</p><p>​ reading;</p><p>​ P(mutex);</p><p>​ count—;</p><p>​ if(count == 0)</p><p>​ V(rw);</p><p>​ V(mutex);</p><p>​ }</p><p>}</p><h6 id="-5"><a href="#-5" class="headerlink" title="#"></a>#</h6><p>​</p><p>④哲学家进餐问题</p><p>Que：5名哲学家围着一个圆桌而坐，两人之间仅有一只筷子，哲学家只做两件事：think and eat，且当拿起左右两只筷子时才能吃饭。</p><h6 id="0-2"><a href="#0-2" class="headerlink" title="## 0"></a>## 0</h6><p>semaphore chopstick[5] = {1,1,1,1,1};</p><p>professor_i(){</p><p>​ while(1){</p><p>​ P(chopstick[i]); //拿左手筷子</p><p>​ P(chopstick[(i+1)%5]); //拿右手筷子</p><p>​ eat;</p><p>​ V(chopstick[i]);</p><p>​ V(chopstick[(i+1)%5]);</p><p>​ think;</p><p>​ }</p><p>}</p><h6 id="-6"><a href="#-6" class="headerlink" title="#"></a>#</h6><p>当所有哲学家拿起左手筷子，就会出现死锁。</p><p>解决方案：</p><p>1) 限制最多4人同时进餐；</p><p>2) 限制只有当可以拿起左右两只筷子时才允许拿起；</p><p>3) 限制奇数号哲学家先拿左手筷子，偶数号先拿右手筷子；</p><p>​</p><h6 id="1-1"><a href="#1-1" class="headerlink" title="## 1"></a>## 1</h6><p>semaphore chopstick[5] = {1,1,1,1,1};</p><p>​ semaphore S = 4;</p><p>​ professor_i(){</p><p>​ while(1){</p><p>​ P(S);</p><p>​ P(chopstick[i]); //拿左手筷子</p><p>​ P(chopstick[(i+1)%5]); //拿右手筷子</p><p>​ eat;</p><p>​ V(chopstick[i]);</p><p>​ V(chopstick[(i+1)%5]);</p><p>​ V(S);</p><p>​ think;</p><p>​ }</p><p>​ }</p><p>​ ###################</p><p>​ ######## 2 ########</p><p>​ semaphore chopstick[5] = {1,1,1,1,1};</p><p>​ semaphore mutex = 1; //设置取筷子信号量</p><p>​ professor_i(){</p><p>​ while(1){</p><p>​ P(mutex);</p><p>​ P(chopstick[i]); //拿左手筷子</p><p>​ P(chopstick[(i+1)%5]); //拿右手筷子</p><p>​ V(mutex);</p><p>​ eat;</p><p>​ V(chopstick[i]);</p><p>​ V(chopstick[(i+1)%5]);</p><p>​ think;</p><p>​ }</p><p>​ }</p><p>​ ###################</p><p>​ ######## 3 ########</p><p>​ semaphore chopstick[5] = {1,1,1,1,1};</p><p>​ professor_i(){</p><p>​ while(1){</p><p>​ if(i%2 == 1)</p><p>​ P(chopstick[i]);</p><p>​ P(chopstick[(i+1)%5]);</p><p>​ else</p><p>​ P(chopstick[(i+1)%5]);</p><p>​ P(chopstick[i]);</p><p>​ eat;</p><p>​ V(chopstick[i]);</p><p>​ V(chopstick[(i+1)%5]);</p><p>​ think;</p><p>​ }</p><p>​ }</p><p>​ ###################</p><p>与贪心算法比较：</p><p>贪心算法强调争取眼前最好的情况，而哲学家进餐问题不仅考虑眼前一步，还考虑下一步。若该问题用贪心算法解决，即只要眼前有筷子就拿起的话，有可能会导致死锁。</p><p>​</p><h2 id="Q22：死锁"><a href="#Q22：死锁" class="headerlink" title="Q22：死锁"></a>Q22：死锁</h2><p>①死锁：</p><p>是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。</p><p>②产生的原因：</p><p>1) 系统资源的竞争。</p><p>【只有对不可剥夺资源进行竞争时才有可能产生死锁，对可剥夺资源的竞争是不会产生死锁的。】</p><p>2) 进程推进顺序不当。</p><p>进程运行过程中，对资源的请求和释放顺序不当；信号量使用不当。</p><p>​</p><p>③死锁产生的必要条件：</p><p>1) 互斥条件：进程对所分配的资源进行排他控制。</p><p>2) 不剥夺条件：进程所获的资源在未使用完之前，不能被其他进程剥夺，即只能由获得该资源的进程主动释放。</p><p>3) 请求并保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源被其他进程所占有，此时进程被阻塞，但不释放自己所获得的资源。</p><p>4) 循环等待条件：存在一种进程资源的循环等待链。</p><p>【资源分配图含圈但不一定有死锁的原因是，同类资源数目大于1。若系统中每类资源都只有一个，则资源分配图含圈就成了系统出现死锁的充要条件。】</p><p>​</p><p>④死锁的处理策略：</p><p>1) 死锁预防：</p><p>防止死锁的发生只需破坏死锁产生的4个必要条件之一即可。</p><p>a. 破坏互斥条件</p><p>若所有的系统都能共享使用，则系统自然不会进入死锁状态，但有些资源只能互斥使用，不能同时使用，因此此方案不太可行，而且在某些场合下应该保护这种互斥性。</p><p>b. 破坏不剥夺条件</p><p>即当已保持资源的进程请求新资源时而得不到满足时，它必须释放掉所拥有的全部资源，待以后需要时再次重新申请。</p><p>【释放已获得的资源可能造成前一阶段的工作失效，反复地申请和释放资源会增加系统的开销，降低系统吞吐量。这种方法常用状态易保存和修复的资源，如CPU的寄存器及内存资源，一般不能用于打印机之类的资源。】</p><p>c. 破坏请求并保持条件</p><p>采用预先静态分配方法，即在进程运行之前一次申请完所需要的全部资源，在运行期间这些资源归他所有，不能提出其他资源请求。</p><p>【系统资源被严重浪费，有些资源有可能只在开始或快结束时才用到；而且还会导致“饥饿”现象，个别资源长期被其他进程占用，导致等待该资源的进程迟迟不能开始运行。】</p><p>d. 破坏循环并等待条件</p><p>采用按顺序资源分配法。首先给系统中的资源编号，规定进程按编号递增的顺序请求资源，同类资源一次申请完。</p><p>【限制新类型设备的增加；尽管在编号时考虑到大多作业使用这些资源的顺序，但也经常会发生作业使用资源顺序和系统规定顺序不同情况，造成资源浪费；不利于用户编程。】</p><p>2) 避免死锁：</p><p>在资源动态分配过程中，防止进程进入不安全状态，以避免发生死锁。</p><p>【系统安全状态：是指系统按照某种进程顺序推进时为每个进程分配其所需的资源，直至满足每个进程对资源最大的最大需求，使得每个进程都可顺序完成。</p><p>【称此时的进程序列为一个安全序列，若系统找不到这样的一个安全序列，则系统处于不安全状态。】</p><p>【并不是所有的不安全状态都是死锁状态，只是不安全状态有可能发生死锁，即安全状态一定不会发生死锁。】</p><p>​</p><p>银行家算法：</p><p>设Request_i是进程P_i的请求向量，“Request_i[j]=K”表示P_i进程申请j类资源K个，当P_i发出请求后，系统按以下步骤检查：</p><p>a) 若Request_i[j] &lt;= Need[i,j]，转b)；否则认为出错，因为所需要的的资源数超出所声明的最大数目。</p><p>b) 若Request_i[j] &lt;= Available[i,j]，转b)；否则，表示尚无足够资源，P_i等待。</p><p>c) 系统试探着把资源分配给P_i进程，并修改：</p><p>Available = Available - Request_i;</p><p>Allocation[i,j] = Allocation[i,j] + Request_i[j];</p><p>Need[i,j] = Need[i,j] - Request_i[j];</p><p>d) 系统执行安全性算法，检查此次分配后系统是否处于安全状态。若安全，则系统正式将资源分配给P_i进程；否则，将本次试探分配作废，让P_i进程等待。</p><p>安全性算法：</p><p>设置工作向量Work，有m个元素，表示系统中剩余可用资源数目。在执行算法开始时，置Work = Available。</p><p>a) 初始时安全序列为空。</p><p>b) 从Need矩阵中找出符合下面条件的行：该行对应的进程不再安全序列里面，而且该行小于等于Work向量。找到后则把对应进程加入到安全序列，否则执行d)。</p><p>c) 进程P_i进入安全序列后，可顺利执行，直至完成，并释放分配给它的资源。执行Work = Work + Allocation[i]。</p><p>d) 若此时安全序列已有所有进程则系统处于安全状态，否则处于不安全状态。</p><p>​</p><p>3) 死锁的检测并解除：</p><p>a) 资源分配图：</p><p>一个圆圈代表一个进程，一个框代表一类资源，框中的一个圆圈代表一个资源，从资源到进程的有向边表示该类资源的一个已分配给进程，从进程到资源的有向边表示该进程申请一个该类资源。</p><p>【简化资源分配图：在资源分配图中，找出既不阻塞又不孤点的进程P_i，小区它的所有请求边和分配边，使之成为孤立的结点。然后进程P_i所释放资源，可唤醒某些因等待这些资源而阻塞的进程。继续执行此过程。】</p><p>​</p><p>b) 死锁定理：</p><p>S为死锁的条件是当且仅当S状态的资源分配图是不可完全简化的。</p><p>c) 死锁解除：</p><p>i) 资源剥夺法：</p><p>挂起某些死锁进程，并抢占它的资源，分配给其他的死锁进程。</p><p>【但应防止被挂起进程长时间得不到资源而处于资源匮乏的状态。</p><p>ii) 撤销进程法：</p><p>强制撤销部分甚至所有死锁进程。</p><p>【撤销原则可以按进程优先级和撤销进程代价高低进行。】</p><p>iii) 进程回退法：</p><p>让一个或多个进程回退到足以回避死锁的地步，进程回退时主动释放资源而非被剥夺。</p><p>【要求保持进程的历史信息，设置还原点。】</p><p>​</p><p>⑤“饥饿”&amp;死锁：</p><p>死锁是多个进程因抢占互斥资源而产生无终止的循环等待，“饥饿”是指系统对于资源的分配不公平时，某些进程因得不到资源而长期等待。（当“饥饿”到一定程度的进程即使完成任务也无意义时，称该进程被“饿死”。）</p><p>进入“饥饿”状态的进程可以只有一个，而因循环等待条件进入死锁状态的进程至少是两个；</p><p>处于“饥饿”状态的进程可以是一个就绪进程，而处于死锁的进程必定是阻塞进程。</p><h2 id="Q23：作业-amp-进程"><a href="#Q23：作业-amp-进程" class="headerlink" title="Q23：作业 &amp; 进程"></a>Q23：作业 &amp; 进程</h2><p>进程是系统资源的使用者，系统的大部分资源是以进程为单位分配的。而用户使用计算机是完成一串相关的任务，通常将用户要求计算机完成的这一串任务称为作业。</p><p>①批处理系统中作业和进程的关系：</p><p>批处理系统通过 磁记录或卡片机 向系统提交批作业，由系统的 SPOOLing输入进程 将作业放入磁盘的 输入井，作为后备作业。</p><p>作业调度程序（一般也作为独立的进程运行）每当选择一道后备作业运行时，首先为该作业创建一个进程（称为该作业的根进程）。</p><p>该进程将执行作业控制语言解释程序，解释该作业的作业说明书。父进程在运行过程中可以动态地创建一个或多个子进程，执行说明书中的语句。因此，一个作业就动态转化为一组运行实体——进程族。</p><p>当父作业遇到作业说明书中的“撤出作业”语句时，将该作业从运行态改为完成态，将作业及相关作业输出送至磁盘的输出井。</p><p>作业终止进程将输出井中的作业利用打印机输出，回收作业所占用的资源，删除作业有关的数据结构，删除作业在磁盘输出井中的信息等。</p><p>作业终止进程撤除一道作业后，可向作业调度程序请求进行新的作业调度。</p><p>​</p><p>②分时系统中作业和进程的关系：</p><p>分时系统的用户通过命令语言逐条与系统应答式地输入命令，提交作业。每输入一条/组命令，就对应系统内部的一个/若干进程。</p><p>在系统启动时，系统为每个终端设备建立一个进程（称终端进程），该进程执行命令解释程序，命令解释程序从终端设备读入指令，解释执行用户输入的每条指令。</p><p>对于每条终端命令，可以创建一个子进程去具体执行。若当前的终端命令是一条后台命令，则可以和下一条终端命令并行处理。</p><p>终端命令对应的进程结束后，所有的终端命令也相应的执行完毕。用户通过一条登出命令立即结束上机过程。</p><p>​</p><p>③交互式的提交批作业：</p><p>在同时支持交互和批处理的系统中，通过一条提交命令将作业提交到作业队列，然后由系统中专门的调度程序负责选择一个作业、为其创建一个父进程运行命令解释程序，解释执行作业控制说明书文件中的命令</p><h1 id="CHAPTER-3"><a href="#CHAPTER-3" class="headerlink" title="CHAPTER 3"></a>CHAPTER 3</h1><h2 id="Q24：内存管理概念及功能"><a href="#Q24：内存管理概念及功能" class="headerlink" title="Q24：内存管理概念及功能"></a>Q24：内存管理概念及功能</h2><p>内存管理就是对内存进行合理的划分以及有效的动态分配。</p><p>​</p><p>内存管理的功能：</p><p>​ 内存空间的分配与回收</p><p>​ 地址转换 【在多道环境下，程序中的逻辑地址和物理地址有可能不同】</p><p>​ 内存空间扩充【利用虚拟存储技术或自动覆盖技术对内存进行扩充】</p><p>​ 存储保护 【保证各道程序在各自的存储空间中运行，互不干扰】</p><p>​</p><h2 id="Q25：程序的链接和装入"><a href="#Q25：程序的链接和装入" class="headerlink" title="Q25：程序的链接和装入"></a>Q25：程序的链接和装入</h2><p>将用户源程序变为内存中可以执行的程序需经历：</p><p>n 编译：</p><p>【由编译程序将用户源代码编译为若干个目标模块】</p><p>【各个目标模块的逻辑地址都从0开始】</p><p>n 链接：</p><p>【由链接程序将编译后的若干个目标模块以及所需的库函数链接在一起，形成一个完整的装入模块】</p><p>【整合各个目标模块逻辑地址，装入模块的逻辑地址以0开始】</p><p>n 装入：</p><p>【由装入程序将装入模块装入内存运行】</p><p>​</p><p>链接的方式：</p><p>​ ①静态链接：</p><p>【在程序运行之前，将各目标模块和所需的库函数链接成一个完整的装入模块，此后不再拆开】</p><p>​ ②装入时动态链接：</p><p>【将各目标模块在装入时采用边链接边装入的方式】</p><p>​ ③运行时动态链接：</p><p>【对于某些目标模块的链接，是在程序执行中需要目标模块时进行的】</p><p>【优点：便于修改与更新，实现对目标模块的共享】</p><p>​</p><p>装入的方式：</p><p>​ ①绝对装入：</p><p>【在编译时，若知道程序将驻留在内存的某个位置，则编译程序将产生绝对地址的目标代码】</p><p>【绝对装入程序按照模块中的地址将程序和数据装入内存】</p><p>【只适用于单道程序环境】</p><p>【程序中所用的绝对地址，可在编译或汇编时给出，也可由程序员直接赋予。通常情况下，程序中采用的是符号地址，在编译或汇编时在转为绝对地址】</p><p>②静态重定位装入/可重定位装入：</p><p>【在多道程序环境下，多个目标模块的起始地址通常是从0开始，程序中其他地址都是相对于始址而言的，此时应采用可重定位装入方式】</p><p>【重定位：是指在装入目标程序时对其的程序与数据的修改】</p><p>【静态：是指地址转换是在装入时一次性完成的】</p><p>【特点：一个作业装入内存时，必须给它分配它所要求的全部内存空间，若没足够的内存则不装入。作业一旦进入内存，在整个运行期间不能在内存中移动，也不能再申请内存空间】</p><p>③动态重定位装入/动态运行时装入：</p><p>【装入程序装入装入模块后，并不立即把装入模块的相对地址变换成绝对地址，这种变换推迟到程序真正要执行时才进行】</p><p>【需要一个重定位寄存器的支持】</p><p>【特点：可以将程序分配到不连续的存储区中；在程序运行前装入它的部分代码即可运行，然后在运行期间，根据需要动态申请分配内存；便于程序段的共享，可以向用户提供一个比实际存储空间大的多的地址空间】</p><p>​</p><h2 id="Q26：逻辑地址空间-amp-物理地址空间"><a href="#Q26：逻辑地址空间-amp-物理地址空间" class="headerlink" title="Q26：逻辑地址空间&amp;物理地址空间"></a>Q26：逻辑地址空间&amp;物理地址空间</h2><p>编译后，各目标模块都是从0号单元开始编址（即相对地址/逻辑地址）。</p><p>链接程序将各个目标模块链接成一个完整的可执行目标程序时，链接程序顺序依次序按各个模块的相对地址构成统一的从0号单元开始的逻辑地址空间。</p><p>【内存管理的具体机制对应用程序和用户完全透明】</p><p>【不同进程可以有相同的逻辑地址】</p><p>​</p><p>物理地址空间是指内存中物理单元集合。</p><p>【进程在运行时执行指令和访问数据，最后都要通过物理地址从内存中存取】</p><p>【地址重定位：当装入程序将可执行代码装入内存时，必须通过地址转换将逻辑地址变换为物理地址】</p><p>​</p><h2 id="Q27：内存保护"><a href="#Q27：内存保护" class="headerlink" title="Q27：内存保护"></a>Q27：内存保护</h2><p>内存分配前，需要保证OS不受用户进程的影响，同时保护用户进程不受其他用户进程的影响。内存保护采用办法：</p><p>①在CPU上设置一对上、下限寄存器，存放用户作业在内存中下限、上限地址；每当CPU要访问一个地址时，分别和两寄存器值相比，判断是否越界。</p><p>②采用重定位寄存器/基地址寄存器和界地址寄存器/限长寄存器。</p><p>【重定位寄存器含最小的物理地址值，界地址寄存器含最大的逻辑地址值】</p><p>【内存管理机构动态地将逻辑地址和界地址寄存器进行比较，若未发生地址越界，则加上重定位寄存器中值映射成物理地址，再送交内存单元】</p><p>​</p><h2 id="Q28：覆盖-amp-交换"><a href="#Q28：覆盖-amp-交换" class="headerlink" title="Q28：覆盖&amp;交换"></a>Q28：覆盖&amp;交换</h2><p>覆盖和交换是在多道环境下扩充内存的两种办法。</p><p>覆盖的基本思想： 【同一进程内】 【对用户或程序员不透明】</p><p>由于程序运行时并非任何都要访问程序及数据的各个部分，因此可以将用户空间划分成一个固定区和若干个覆盖区。将经常活跃的部分放在固定区，其余部分按调用关系分段。首先将那些即将访问的段放入覆盖区，其他段放到外存，在需要调用时，系统再将其从外存调入覆盖区，替换覆盖区原有的段。</p><p>特点：</p><p>打破了一个必须将一个进程的全部信息全部装入内存才能运行的限制，但当同时运行程序的代码量大于内存时依然不能运行，另外内存中能够更新的只有覆盖区，其他中的段将会常驻内存。</p><p>​</p><p>交换/对换的基本思想：【不同进程间】</p><p>换出：把处于等待状态（或在CPU调度原则下被剥夺运行权利）的程序从内存移出到辅存，腾出内存空间。</p><p>换入：把准备好竞争CPU运行的程序从辅存移入内存。</p><pre><code>交换注意问题：
</code></pre><p>①交换需要备份存储，通常是快速磁盘。它必须足够大，并提供对这些内存映像的直接访问。</p><p>②为了有效使用，需要使进程的执行时间比交换时间长。影响交换时间的主要是转移时间，转移时间和所交换的内存空间成正比。</p><p>③若换出进程，必须保证该进程完全处于空闲状态。</p><p>④交换空间通常作为磁盘的一整块，且独立于文件系统，因此使用起来比较快。</p><p>⑤交换通常在有许多进程运行且内存吃紧时启动，在内存有了空闲时暂停。</p><h2 id="Q29：连续分配管理方式"><a href="#Q29：连续分配管理方式" class="headerlink" title="Q29：连续分配管理方式"></a>Q29：连续分配管理方式</h2><p>①单一连续分配：</p><p>【内存在此方式下分为系统区和用户区；系统区供OS使用，通常在低地址部分；用户区是为用户提供的内存空间】</p><p>【内存中永远只有一道程序，因此无需内存保护】</p><p>【优点：简单、无外部碎片，可以采用覆盖技术，不需要额外的技术支持】</p><p>【缺点：只能用于单用户、单任务的OS中，有内部碎片，存储器利用率极低】</p><p>②固定分区分配：</p><p>【存在内零头，不能实现多进程共享一个主存区】</p><p>【最简单的一种多道程序存储管理方式】</p><p>【它将用户内存空间划分成若干大小固定的区域，每个区只能装入一道作业】</p><p>【当有空闲分区时，从外存的后备队列中选择合适大小的作业装入分区】</p><p>​</p><p>划分分区的方法：</p><p>分区大小相等：</p><p>【用于利用一台计算机去控制相同对象的场合，灵活性差】</p><p>分区大小不等：</p><p>【划分多个较小分区、适量中等分区、少量大分区】</p><p>【为了便于内存分配，通常将分区按大小排队，并为之建立一张分区说明表，表项包括：分区号、分区大小、分区始址、分区状态】</p><p>【当有用户程序装入时，检索该表，以便找到合适分区并给予分配并设置状态为“已分配”，未找到时拒绝该程序的装入】</p><p>​</p><p>存在问题：</p><p>①程序可能太大而放不进任何一个分区，此时用户不得不使用覆盖技术来使用内存空间。</p><p>②程序小于固定分区大小，则存在内部碎片，这样分区内存存在浪费。</p><p>③动态分区分配/可变分区分配：【存在外零头】</p><p>不预先划分内存，而是在进程装入内存时，根据进程大小动态的创立分区，并使分区大小正好符合进程的需要。</p><p>【动态分区分配会出现很多小的外零头，通过紧凑compaction技术解决，即OS不时的对进程进行移动和整理。需要动态重定位寄存器支持，且相对费时。】</p><p>在进程装入或换入内存时，若内存有多个足够大小的空闲块，则OS应确定将哪个内存块分给进程使用：【找到第一个符合要求空闲分区】</p><p>①首次适应算法FF：【空闲分区以地址递增的次序链接】</p><p>②最佳适应算法BF：【空闲分区以容量递增的次序链接】</p><p>③最坏适应算法WF/最大适应算法LF：【空闲分区以容量递减的次序链接】</p><p>④邻近适应算法NF/循环首次适应算法：【分配时从上次查找结束的位置开始查找】</p><p>算法比较：</p><p>FF是最简单的，通常也是最好、最快的。但是FF会使内存低地址部分出现很多小的空闲分区，而每次查找的时候都要经过这些分区，增加了查找的开销。</p><p>NF试图解决FF的问题，但它常常导致内存的末尾空间分裂成小碎片（在一遍扫描中，内存前面部分分配后释放，不会参与分配），它通常比FF性能差。</p><p>BF性能通常很差，因为每次最佳分配会留下很小的碎片，会产生很多的内部碎片。</p><p>WF将最大的连续内存划分开，会导致很快没有可用的大内存块，性能也非常差。</p><p>FF和NF只需简单查找即可，BF和WF需要对可用块进行排序或遍历查找。在算法实现时，使用数组或链表进行管理。</p><div class="table-container"><table><thead><tr><th></th><th>作业道数</th><th>内零头</th><th>外零头</th><th>硬件支持</th><th>可用空间管理</th><th>解决碎片办法</th><th>解决内存不足</th><th>提高作业道数</th></tr></thead><tbody><tr><td>单道连续分配</td><td>1</td><td>有</td><td>无</td><td>界地址寄存器、越界检查机构</td><td>——</td><td>——</td><td>覆盖</td><td>交换</td></tr><tr><td>多道固定分区分配</td><td>&lt;=N(用户空间划分为N块)</td><td>有</td><td>无</td><td>①上、下限寄存器、地址变换机构②重定位寄存器、界地址寄存器、地址变换机构</td><td>——</td><td>——</td><td>——</td><td>——</td></tr><tr><td>多道可变分区分配</td><td>——</td><td>无</td><td>有</td><td>①上、下限寄存器、地址变换机构②重定位寄存器、界地址寄存器、地址变换机构</td><td>数组/链表</td><td>紧凑</td><td>——</td><td>——</td></tr></tbody></table></div><h2 id="Q30：非连续分配管理方式"><a href="#Q30：非连续分配管理方式" class="headerlink" title="Q30：非连续分配管理方式"></a>Q30：非连续分配管理方式</h2><p>采用非连续的分配方式，需要额外空间去存储它们（分散区域）的索引，使得非连续分配方式的存储密度低于连续分配方式。</p><p>①分页存储管理方式：</p><p>1) 基本分页存储管理方式：</p><p>l 分页的思想：</p><p>由于固定分区会产生内零头，可变分区会产生外零头，这两种技术对内存的利用率都比较低。因此，把主存空间划分大小相同且固定的块，块相对较小，作为主存的基本单位。每个进程也以块为单位进行划分，进程在执行时，以块为单位逐个申请主存中的块空间。</p><p>l 分页和固定分区区别：</p><p>块相对分区比较小，并且在进程也按照块进行划分，进程运行时按块申请主存可用块空间。这样，进程只会在为最后一个不完整块申请主存块空间时才产生内零头，并且产生的内部碎片相对于整个进程来说比较小，每个进程平均只产生半块大小内部碎片（页内碎片）。</p><p>​</p><p>l 基本概念：</p><p>页(Page)：进程中的块。</p><p>页框(Page Frame,页帧)：内存中的块。</p><p>块(Block)：外存中的块。</p><p>页面大小：2的指数幂（方便地址转换）。</p><p>【页面太小会使进程的页面数过多，这样页表就会过长，占用大量内存，而且也会增加硬件地址转换的开销，降低页面换入/换出效率】</p><p>【页面太大，会使页内碎片增多，降低内存利用率】</p><p>地址结构： （高位） 页号+页内偏移量 （低位）</p><p>页表：</p><p>由页表项组成。记录页面在内存中对应物理块号，一般存放于内存中。</p><p>页表项：页号+页框号。</p><p>【页表项大小不是任意的，在32位逻辑地址空间、字节编址单位、页面大小4KB，要保证页表项指向所有页的话，页表项大小应&gt;= log_2_(2^32B/4KB) / 8】</p><p>​ 物理地址：页框号+页内偏移量。</p><p>l 基本地址变换机构：</p><p>在系统中通常设置一个页表寄存器(PTR)，存放页表在内存的起始地址F和页表长度M。进程未执行时，页表的始址和页表长度存放于PCB中，当进程执行时，才将其存入PTR。</p><p>n 逻辑地址 转换 物理地址 的过程:</p><p>由逻辑地址及页面大小计算得到页号P和页内偏移量W。然后比较页号P和页表长度M，若P&gt;=M则发生越界中断，否则继续执行。由页表在内存的始址F和页号P计算出对应页表项地址。然后从页表项中找到对应页号的页框号，由页框号和页内偏移量W组成物理地址。</p><p>【页式管理的地址空间是一维的（页面大小是固定的，给一个逻辑地址就可计算出一个物理地址）】</p><p>l 基于上述地址变换机构的分页管理存在的问题：</p><p>①每次访存操作都要进行逻辑地址到物理地址的转换，地址转换必须足够快，否则会降低访存速度。</p><p>②每个进程引入页表，用于存储映射机制，页表不能太大，否则内存利用率会降低。</p><p>l 具有快表的地址变换机构：</p><p>在上面的地址变换机构中，若页表全部放在内存中，则存取一个数据或一条指令至少要访问2次内存，第一次访问页表，确定所存取数据或指令的物理地址，第二次是根据该物理地址存取数据或指令。为此，在地址变换机构中增加一个具有并行查找能力的高速缓冲器——快表/相联存储器TLB。用于存放当前访问的若干页表项，加速地址变换的过程。</p><p>n 逻辑地址 转换 物理地址 的过程:</p><p>①CPU给出逻辑地址后，由硬件进行地址转换，将页号送入高速缓存寄存器，并将此页号与快表中所有页号进行比较。</p><p>②若找到匹配的页号，说明所要访问的页表项在快表中，则直接从中读出对应的页框号，与页内偏移量拼接形成物理地址。这样，存取数据仅一次访存即可实现。</p><p>③若未找到，则需访问主存的页表，在读出页表项后，应将其存入快表，以便以后可能再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换。</p><p>【有的处理机设计为快表和慢表同时查找，若在快表中查找成功则终止慢表的查找】</p><p>【快表的有效性基于局部性原理】</p><p>l 两级页表：</p><p>由于引入了分页管理，每个进程执行时不需要将所有页面调入内存页框，而只需将保存有映射关系的页表调入内存。考虑页表大小，</p><p>以32位逻辑地址空间、字节编址单位、页面大小4KB、页表项为4B为例，若要实现进程对全部逻辑地址空间的映射，则每个进程需要2^20个页表项，即每个进程仅页表就需要4MB，显示不符合实际。</p><p>即便不考虑对全部逻辑地址空间的映射，那么对于一个逻辑地址空间稍大的进程而言，以40MB为例，则页表项总共40KB，页表项需要10个页框，而进程大小约1万个页面，实际运行时只需几十个页面进入内存页框即可运行，若要求10个页面大小的页表全部进入内存，则相对于实际上只需几十个页面进入内存页框即可运行而言，降低了内存利用率；从另一方面来说这10页的页表项也并不需要同时保存在内存，因为在大多情况下，映射所需要的页表项都在页表的一个页面中。</p><p>为了压缩页表，进一步延伸页表映射的思想，将页表的多个页面也进行地址映射，建立上一级页表，用于存储页表的映射关系。</p><p>在进程执行时，只需要将这一页的上一级页表调入内存即可，进程的页表和进程本身的页面可在后面的执行中再调入执行。</p><p>【顶级页表只能有一个页面】</p><p>逻辑地址空间的格式：</p><p>（高位） 一级页号 + 二级页号 + 页内偏移量 （低位）</p><p>建立多级页表的目的：</p><p>建立索引，以便不用浪费主存空间去存储无用的页表项，也不用盲目地顺序式查找页表项。</p><p>​</p><p>2) 请求调页存储管理方式</p><p>​</p><p>②分段存储管理方式：</p><p>1) 基本分段存储管理方式：</p><p>【分页通过硬件机制实现，对用户完全透明】</p><p>【分段管理方式的提出是考虑了用户和程序员，以满足方便编程、信息保护和共享、动态增长及动态链接等多方面的需要】</p><p>分段：</p><p>段式管理方式按照用户进程中的自然段划分逻辑空间。段内要求连续、段间不要求连续。</p><p>逻辑地址结构：段号+段内偏移量。</p><p>【页式系统中，逻辑地址的页号和页内偏移量对用户是透明的】</p><p>【段式系统中，段号和段内偏移量必须由用户显示提供，在高级程序设计语言中，这个工作由编译程序完成】</p><p>段表：</p><p>由段表项组成。每个进程都有一张逻辑空间与内存空间映射的段表。</p><p>【配置段表后，执行中的进程可以通过段表，找到每段对应的内存区】</p><p>段表项：</p><p>段号+段长+本段在主存中的地址。</p><p>【每个段表项对应进程的一段】</p><p>地址变换机构：</p><p>段表寄存器：段表始址、段表长度。</p><p>逻辑地址 转换 物理地址 的过程:</p><p>从逻辑地址中取出前几位为段号S，后几位为段内偏移量W。然后比较段号S和段表长度M，若S&gt;=M则发生越界中断，否则继续执行。</p><p>由段表在内存的始址F和段号S计算出对应段表项地址。然后将段内偏移量W和段表项中的段长C比较，若W&gt;=C则发生越界中断，否则继续执行。</p><p>由段在内存的地址和段内偏移量相加构成物理地址。</p><p>【段式管理的地址空间是二维的（段长是不确定的，因此段号和段内偏移量要显示给出）】</p><p>​</p><p>​ 段的共享：</p><p>【分段系统中，段的共享是通过两个作业的段表中相应段表项指向被共享段的同一个物理副本来实现的】</p><p>【当一个作业正在从共享段中读取数据时，必须防止另一个作业修改此共享段中的数据】</p><p>【可重入代码/纯代码（：不能修改的代码，不属于临界资源）和不能修改的数据可以共享，而可修改代码和数据不可共享】</p><p>​</p><p>段的保护：</p><p>【存取控制保护】【越界保护】</p><p>​</p><p>③段页式存储管理方式：</p><p>1) 基本段页式存储管理方式：</p><p>页式存储管理有效地提高了内存利用率，段式存储管理能反映程序的逻辑结构并有利于段的共享。</p><p>【作业的地址空间分为若干个逻辑段，每个段有自己的段号，然后将每个段分成若干个固定大小的页】</p><p>【对内存划分和分页存储管理一样，将其划分成若干个页面大小相同的存储块，对内存的分配以存储块为单位】</p><p>逻辑地址结构：（高位） 段号+页号+页内偏移量 （低位）</p><p>地址变换机构：</p><p>【每个进程有唯一的段表和若干个页表】</p><p>段表表项：段号、页表长度、页表始址等。</p><p>页表表项：页号、页框号等。</p><p>段表寄存器：段表始址、段表长度。</p><p>逻辑地址 转换 物理地址 的过程:</p><p>从逻辑地址中取出前几位为段号S，接着几位为页号P，然后为页内偏移量W。将段号S和段表寄存器中的段表长度M相比较，若S&gt;=M则发生越界中断，否则继续执行。</p><p>由段表始址和段号计算出对应段表项的地址，将页号P和段表项中的页表长度Mp比较，若P&gt;=Mp则发生越界中断，否则继续执行。将段表项中的页表始址和页号计算出对应的页表项地址，然后查找到对应页表项，将页框号和页内偏移量拼接组成物理地址。</p><p>【段页式管理的地址空间是二维的】</p><p>​ 快表：其关键字是：段号和页号，值是：页帧号和保护码。</p><p>​</p><p>​</p><h2 id="Q31：虚拟存储管理"><a href="#Q31：虚拟存储管理" class="headerlink" title="Q31：虚拟存储管理"></a>Q31：虚拟存储管理</h2><p>l 传统存储管理方式特征：</p><p>①一次性：</p><p>作业必须一次性全部装入内存后，才能执行。</p><p>②驻留性：</p><p>作业被装入内存后，就一直驻留在内存中，其任何部分都不会被换出，直至程序运行结束。运行中的进程可以因等待I/O而被阻塞，可能处于长期等待状态。</p><p>l 局部性原理：</p><p>n 时间局部性:</p><p>程序中的某条指令一旦执行，不久后该指令可能再次执行；某数据被访问后，不久后该数据可能再次被访问。</p><p>【产生时间局部性的原因是程序中存在着大量的循环操作】</p><p>n 空间局部性：</p><p>一旦程序访问了某个存储单元，则不久后，其附近的存储单元也将被访问。</p><p>【通常指令是顺序存放的、顺序执行的，数据一般是以数组、向量、表等形式簇聚存储的】</p><p>【时间局部性通过将近来使用的指令和数据存放在高速缓冲存储器中，并使用高速缓存的层次结构实现】</p><p>【空间局部性通常使用较大的高速缓存，并将预取机制集成化到高速缓存控制逻辑中实现】</p><p>​</p><p>l 虚拟存储器：</p><p>基于局部性原理，在程序装入时，只将程序的一部分装入内存，其余部分留在外存，就可启动程序执行。在程序执行过程中，当所访问的信息不在内存时，由OS将所需的部分从外存调入内存，然后执行。另一方面，OS将内存中暂时不适用的部分调到外存上，腾出内存空间以便将要调入的部分调入内存中。因此，系统为用户提供了一个比实际存储空间大得多的存储器。</p><p>特征：【虚拟存储器的大小由计算机的地址结构决定】</p><p>①多次性：作业在运行时无须一次性地全部装入内存，而是允许被分成多次调入内存。</p><p>②对换性：作业无须一直驻留在内存，而是可以换入和换出。</p><p>③虚拟性：逻辑上扩充。</p><p>虚拟存储技术的实现：</p><p>虚拟内存技术允许一个作业分多次调入内存。采用连续分配方式，会使相当一部分内存处于暂时或“永久”空闲状态，造成内存资源的严重浪费，也无法从逻辑上扩充内存。</p><p>因此，虚拟内存的实现是建立在离散分配的内存管理方式基础上。</p><p>实现方式：请求分页存储管理、请求分段存储管理、请求段页式存储管理。</p><p>虚拟存储技术需要硬件支持，一般需要：</p><p>①一定量的内存和外存空间</p><p>②页表机制或段表机制</p><p>③中断机构，当所要访问的部分未调入内存时，产生中断</p><p>④地址变换机构</p><p>​</p><h2 id="Q32：请求分页存储管理"><a href="#Q32：请求分页存储管理" class="headerlink" title="Q32：请求分页存储管理"></a>Q32：请求分页存储管理</h2><p>l 页表机制：</p><p>页表项：页号、物理块号、状态位、访问字段、修改位、外存地址。</p><p>状态位：</p><p>用于指示该页是否已调入内存，供程序访问时参考。</p><p>访问字段：</p><p>用于记录本页在一段时间内被访问次数或记录本页有多长时间未被访问，供置换算法换出页面时参考。</p><p>修改位：</p><p>表示该页被调入内存后是否修改过。</p><p>外存地址：</p><p>指出该页在外存中的地址，供调入该页时参考。</p><p>​</p><p>l 缺页中断机制：</p><p>在请求分页存储管理方式中，当所要访问页面不在内存时，便产生一个缺页中断，请求该OS将所需的页调入内存，此时应将缺页的进程阻塞，若内存中有空闲块，则分配一个块，将要调入的页装入该块，并修改页表中相应表项。若此时内存中无空闲块，则要淘汰某页（若淘汰的页在内存期间被修改过，则需要写回外存）。</p><p>【内中断，指令执行期间产生的中断请求】</p><p>【一条指令在执行期间，可能产生多次缺页中断】</p><p>​</p><p>l 地址变换机构：</p><p>程序请求访问某一页，</p><p>比较页号P和页表长度M，若P&gt;=M则产生越界中断，否则继续执行。</p><p>CPU检索快表，若该页号对应的页表项在快表中，则修改访问位和修改位，然后由页帧号和页内偏移量拼接成物理地址。</p><p>若不在快表中，则由页表始址和页号得到页表项地址访问页表，若该页在内存中中，则修改快表中相应表项，然后，修改访问位和修改位，然后由页帧号和页内偏移量拼接成物理地址。</p><p>若该页不在内存中，则产生缺页中断。由缺页中断处理程序保护CPU现场。然后从外存中找到该页。若内存有空闲，则OS命令CPU从外存读缺页，启动I/O硬件，将一页从外存调入内存，修改页表，然后重新执行指令。</p><p>若内存已满，则需要选择一页换出，若该页修改过则还需写回外存，然后，OS命令CPU从外存读缺页，启动I/O硬件，将一页从外存调入内存，修改页表，然后重新执行指令。</p><p>​</p><p>l 页面置换算法：（决定换入哪页、换出哪页）</p><p>①最佳OPT置换算法:</p><p>【淘汰：以后永久不使用或在最长时间内不再被访问的页面】</p><p>【无法实现，一般用来评价其他算法】</p><p>②先进先出FIFO置换算法：</p><p>【淘汰：最先进入内存的页面，即内存中驻留时间最久的页面】</p><p>【实现简单，只需将调入内存的页面根据先后次序链接成队列，设置一个指针总指向最早的页面】</p><p>【Belady异常：分配物理块增多而页故障数不减反增】</p><p>③最近最久未使用LRU置换算法：</p><p>【淘汰：最近最长时间未访问过的页面】</p><p>【基于局部性原理，认为过去一段时间内未使用，则在最近的将来可能也不会使用】</p><p>【该算法为每个页面设置一个访问字段，用来记录页面自上次访问以来所经历的时间】</p><p>【LRU算法性能较好，但需要寄存器和栈的硬件的支持】</p><p>【LRU算法是堆栈类算法】</p><p>【理论上可证明堆栈类算法不会产生Belady异常】</p><p>④时钟CLOCK算法:</p><p>1) 简单的CLOCK算法/最近未用NRU算法：</p><p>【为每个帧关联一个附加位，即使用位】</p><p>【将替换的帧的集合视为一个循环缓冲区，并有一指针与之关联】</p><p>初始时，将所有帧的使用位置为0。</p><p>当某页首次装入内存时，将其对应帧的使用位置为1。</p><p>当该页随后再次被访问，将其使用位置1。</p><p>当某页被替换时，该指针指向缓冲区的下一帧。</p><p>当需要进行替换一页时，OS扫描帧缓冲区，以查找使用位为0的帧。每当遇到使用位为1的帧，将其使用位置为0。若查找失败，则重新扫描，直至找到所要淘汰的页。</p><p>2) 改进的CLOCK算法：</p><p>【使用位u、修改位m】</p><p>初始时，将所有帧置u=0,m=0。</p><p>当某页首次装入内存时，将其对应帧的使用位置为1。</p><p>当该页随后再次被访问，将其使用位置1。</p><p>当某页在内存期间被修改则置对应帧的修改位为1。</p><p>当某页被替换时，该指针指向缓冲区的下一帧。</p><p>当需要进行替换一页时，</p><p>step1：OS扫描帧缓冲区，以查找u=0,m=0的帧，在此次查找过程中对使用位不进行任何修改。</p><p>step2：若查找失败，则重新扫描，查找u=0,m=1的帧。每当遇到使用位为1的帧，将其使用位置为0。</p><p>若查找失败，则重新扫描，循环step1与step2操作，直至找到所要淘汰的页。</p><p>l 页面分配策略：</p><p>①驻留集大小：</p><p>进程的驻留集：OS为每一个进程分配的物理页框的集合。</p><p>【考虑点1：分配给一个进程的存储量越小，则任何时刻驻留在内存中的进程数目就越多，从而可以提高CPU的利用效率】</p><p>【考虑点2：若一个进程在内存中的页面过少，尽管有局部性原理，页错误率仍然相对较高】</p><p>【考虑点3：若页数过多，则由局部性原理，给特定的进程分配过多的主存空间对进程的页错误率没有明显的影响】</p><p>​</p><p>现代OS采用的策略：</p><p>1) 固定分配局部置换：</p><p>【为每一个进程分配一定数目的物理块，在进程执行期间不发生改变】</p><p>【若进程在运行时发生缺页，则只能从该进程在内存的页面中选出一页换出，然后调入页面】</p><p>【难以确定合适的物理块数目，过少会频繁出现缺页中断，过多会降低CPU和其他资源利用率】</p><p>2) 动态分配全局置换</p><p>【为每个进程分配一定数目的物理块，OS保持一个空闲物理块队列】</p><p>【当发生缺页时，OS从空闲地物理块队列中取出一个物理块分配给该进程，并将要调入的页装入该物理块中】</p><p>【缺点：会盲目地给进程增加物理块，从而使得系统多道程序的并发性下降】</p><p>​</p><p>3) 动态分配局部置换：</p><p>【为每个进程分配一定数目的物理块】</p><p>【当发生缺页时，允许该进程在内存的页面中选出一页换出，因此不会影响其他进程运行】</p><p>【若进程在运行时频繁发生缺页，则系统再为进程分配若干个物理块，直至该进程缺页率区域适当程度】</p><p>【若进程的缺页率极低，则可适当地减少给进程分配的物理块】</p><p>【优点：既保证了进程不会出现过多缺页的同时，又保持了系统的多道程序并发能力】</p><p>​</p><p>②页面调入时机：</p><p>1) 预调入策略：</p><p>根据局部性原理，一次调入相邻的若干页可能会比一次调入一页更高效。但当调入的一批页面中大多未访问时，又是低效的。</p><p>【目前预调页成功率仅约50%。主要用于进程的首次调入，由程序员指定调入哪些页】</p><p>​</p><p>2) 请求调入策略：</p><p>【易于实现，缺点是每次只调入一页，当调入/调出页面过多时会增加过多的I/O开销】</p><p>​</p><p>③从何处调入页面：</p><p>请求分页存储管理系统在外存分为两部分：</p><p>文件区（用于存放文件）【通常采用离散存储方式】</p><p>对换区（用于存放对换页面）【通常采用连续存储方式】</p><p>​</p><p>1) 系统有足够的对换空间：</p><p>【可以全部从对换区调入所需页面，以提高页调入速度】</p><p>【在进程运行之前，将与该进程相关的文件从文件区拷贝到对换区】</p><p>2) 系统缺少足够的对换空间：</p><p>【凡不会修改的文件都从文件区调入】</p><p>【当换出页面时，若未修改则不必换出；否则，将其换出时必须调到对换区，以后需要时从对换区调入】</p><p>3) UNIX方式：</p><p>【与进程有关的文件都放在文件区，因此未运行过的页面直接从文件区调入】</p><p>【那些曾经运行过但被换出的页面放在对换区，因此下次调入时从对换区调入】</p><p>【进程请求的共享页面被其他进程调入内存，则无需再从对换区调入】</p><p>​</p><p>l 抖动：</p><p>刚刚换出的页面马上需要换入内存，刚刚换入的页面马上需要换出内存，这种频繁的页面调度行为。</p><p>【若一个进程在换页上用的时间多于执行时间，则该进程就在抖动】</p><p>频繁发生缺页中断（抖动）原因：</p><p>某个进程频繁要访问的页面数高于可用的物理块数目。</p><p>​</p><p>​</p><p>l 工作集：</p><p>某段时间间隔内，进程要访问的页面集合。由时间和工作集窗口大小确定。</p><p>【实际应用中，工作集窗口会设置很大，而工作集一般比工作集窗口小很多】</p><p>【工作集反映了进程在接下来一段时间可能进行频繁访问的页面集合，因此，若分给进程的物理块数小于工作集大小，则进程可能出现频繁缺页。因此，一般驻留集大小大于工作集大小】</p><p>工作集模型原理：</p><p>让OS去跟踪每个进程的工作集，并为进程分配大于工作集大小的物理块。在工作集中页面可能需要调入驻留集中，不在其中的页面可能需要从驻留集中换出。若还有空闲的物理块，则可通过再调一个进程进入内存来提高多道程序度。当所有进程的工作集大小总和超过了可用物理块数目，则OS会暂停一个进程，将其页面调出并将其物理块分配给其他进程，防止出现抖动现象。</p><p>​</p><p>l 地址结构：</p><p>虚拟地址： 虚拟页号（TLB标记 + TLB索引） + 页内偏移量</p><p>eg,TLB为四路组相联，共有16个条目，则， TLB索引为log_2_(16/4) = 2位。</p><p>物理地址： 物理页号（cache标记 + cache索引 + 偏移量） + 页内偏移量</p><p>eg,cache是物理寻址、直接映射的，行大小为4B，共有16组，则，块偏移为log_2_(4)= 2位，cache索引为log_2_(16)= 4位。</p><p>​</p><h2 id="Q33：覆盖、交换和虚拟存储技术区别"><a href="#Q33：覆盖、交换和虚拟存储技术区别" class="headerlink" title="Q33：覆盖、交换和虚拟存储技术区别"></a>Q33：覆盖、交换和虚拟存储技术区别</h2><p>覆盖与虚拟技术区别：</p><p>覆盖程序段的最大长度受内存存量大小限制，而虚拟存储器中程序最大长度只受地址结构限制。</p><p>覆盖技术中的覆盖段由程序员设计，且要求覆盖段中各个覆盖具有相对独立性，不存在直接联系或相互交叉访问，而虚拟存储技术没有这种要求。</p><p>​</p><p>交换与虚拟存储技术区别：</p><p>交换技术调入/调出是整个进程，因此一个进程的大小要受内存存量大小的限制，而虚拟存储技术中使用的调入/调出技术在内存与外存之间交换的是页面或段，而不是整个进程，从而使得进程的地址映射具有更大的灵活性。且允许进程大小比可以的内存空间大。</p><h1 id="CHAPTER-4"><a href="#CHAPTER-4" class="headerlink" title="CHAPTER 4"></a>CHAPTER 4</h1><h2 id="Q34：文件及文件系统概念"><a href="#Q34：文件及文件系统概念" class="headerlink" title="Q34：文件及文件系统概念"></a>Q34：文件及文件系统概念</h2><p>文件：是以计算机硬盘为载体的在计算机上的信息集合。</p><p>【计算机在运行时是以进程为基本调度单位，而在用户的输入/输出时是以文件为基本单位的】</p><p>【文件可以是数字、字母、二进制代码。基本访问单元可以是字节、行或记录。文件可以长期存储在硬盘或其他二级存储器中，允许可控制进程间共享，能被组织成复杂的结构】</p><p>文件系统：</p><p>​ OS中负责管理和存储文件信息的软件机构称为文件管理系统。</p><p>【由与文件管理有关的软件、被管理文件以及实施文件管理所需的数据结构组成】</p><p>【从用户角度看，文件管理系统是OS中重要的一部分。用户只关心如何命名、分类及查找文件，如何保证文件数据的安全性以及对文件进行哪些操作】</p><p>【文件管理系统提供与二级存储有关的资源抽象，使得用户在不了解文件的各种属性、文件在存储介质上的存储方式及存储位置的情况，方便快捷的使用文件】</p><p>​</p><p>l 从下往上看文件的组织：</p><p>数据项：是文件系统中最低级的数据组织形式。</p><p>基本数据项：用于描述一个对象的某一种属性。</p><p>组合数据项：由多个基本数据项组合而成。</p><p>记录：是一组相关的数据项的集合。</p><p>文件：是创建者所定义的一组相关信息的集合。</p><p>【逻辑上可分为有结构文件/记录式文件和无结构文件/流式文件，有结构文件由一组相似的记录组成，无结构文件被视为一个字符流】</p><p>​</p><p>l 文件的属性：</p><p>①名称</p><p>【文件名唯一，以易读取的形式保存】</p><p>②标识符</p><p>【标识文件系统内文件的唯一标识，通常为数字，对人不可读的一种内部名称】</p><p>③类型</p><p>【被支持不同类型的文件系统使用】</p><p>④大小</p><p>【文件当前大小，也可包含文件允许的最大值】</p><p>⑤位置</p><p>【指向设备和设备上文件的指针】</p><p>⑥保护</p><p>【对文件进行保护的访问控制信息】</p><p>​ ⑦时间、日期和用户标识</p><p>【文件创建、上次修改和上次访问的相关信息，用于保护和跟踪文件的使用】</p><p>【文件的所有相关信息保存在目录结构中，而目录结构保存在外存，在需要时调入到内存】</p><p>​</p><p>l 文件的基本操作：</p><p>【OS通过系统调用来对文件进行创建、读、写、删除、重定位、截断等操作】</p><p>①创建文件</p><p>②写文件</p><p>【为了写文件，执行一个系统调用，指明文件名称和要写入文件的内容】</p><p>【对于给定的文件名称，系统搜索目录以查找文件位置】</p><p>【系统必须为该文件维护一个写位置的指针，每当发生写操作时，便于更新写指针】</p><p>③读文件</p><p>【为了读文件，执行一个系统调用，指明文件名称和要读入文件块的内存位置】</p><p>【对于给定的文件名称，系统搜索目录以查找文件位置】</p><p>【系统必须为该文件维护一个读位置的指针，每当发生读操作时，便于更新读指针】</p><p>【一个进程通常只对一个文件进行读/写操作，因此当前操作位置可作为进程当前文件位置的指针。由于读、写操作使用同一个指针，节省了空间，降低了系统的复杂度】</p><p>④删除文件</p><p>【先从目录中找到要删除文件的目录项，使之成为空项，然后回收文件所占的存储空间】</p><p>⑤文件重定位（文件寻址）</p><p>【按某条件搜索目录，将当前文件位置设置为给定值，不进行读/写操作】</p><p>⑥截断</p><p>【允许文件的所有属性不变，删除文件内容，将其长度设为0并且释放其空间】</p><p>​</p><p>l 文件的打开和关闭：</p><p>【文件的许多操作都会涉及到为给定文件搜索目录以找到相对应的目录项，因此大多系统要求在首次使用文件时，使用系统调用open将指明文件的属性（也包括该文件在外存上的位置）从外存复制到内存的打开文件表的一个表目中，将该表目的编号（索引）返回给用户】</p><p>【当用户需要一个文件操作时，通过该表的一个索引指定文件，因此省略了搜索环节。当文件不再使用时，进程可以关闭它，OS从文件打开表中删除该条目】</p><p>【大部分OS要求在使用文件之前显示地打开文件】</p><p>【操作open会根据文件名称搜索目录，并将相应的目录条目复制到系统打开文件表。若调用open的请求（创建、只读、读写、添加等）得到允许，则进程就可打开文件，而open通常返回一个指向系统打开文件表中一个条目的指针，只通过该指针（而非文件名）进行所有I/O操作】</p><p>【一个进程打开一个文件，系统打开文件表就会为相应文件增加一个条目。当另一进程执行open操作时，只不过是在其进程的打开文件表中增加一个条目，并指向系统打开文件表中对应的条目】</p><p>【一个进程在打开一个文件时，首先遍历系统打开文件表】</p><p>【通常，系统打开文件表的每个文件时，还用到一个打开计数器，已记录多少进程打开该文件】</p><p>【每个关闭操作close使得count递减，当打开计数器为0时，表示该文件不在被使用，系统就回收分配该文件的内存空间等资源。若文件被修改过，则将文件写回外存，并将系统打开文件表中相应表项删除，最后释放其FCB】</p><p>​</p><p>n 每个打开文件都有如下关联信息：</p><p>文件指针：</p><p>【系统跟踪上次文件读写位置作为当前文件位置的指针】【对进程来说是唯一的，必须与磁盘文件属性分开保存】</p><p>文件打开计数：</p><p>文件磁盘位置：</p><p>【该信息保存在内存，以免每个操作都要从磁盘读取】</p><p>访问权限：</p><p>【保存在进程的打开文件表中，以便OS能够允许或拒绝之后的I/O请求】</p><p>​</p><h2 id="Q35：文件的逻辑结构"><a href="#Q35：文件的逻辑结构" class="headerlink" title="Q35：文件的逻辑结构"></a>Q35：文件的逻辑结构</h2><p>①无结构文件（流式文件）</p><p>【将数据按顺序组织成记录并积累、保存，它是有序相关信息项的集合】</p><p>【以字节为单位】</p><p>【对记录的访问只能以穷举搜索的方式进行，对大多数应用不适用；但管理简单，用户可以很方便地对其进行操作】</p><p>【适用于对基本信息单位操作不多的文件，如源程序文件、目标代码文件等】</p><p>​</p><p>②有结构文件（记录式文件）</p><p>1) 顺序文件：</p><p>【文件中的记录按一个接一个顺序排列，记录通常是定长的，可以以数组或链表的方式存储】</p><p>【访问时以顺序搜索文件】</p><p>【对记录进行批量操作，即每次要读或写一大批记录时，顺序文件的效率是所有逻辑文件中最高的】</p><p>【只有顺序文件才能存储在磁带上，并能有效地工作】</p><p>【但顺序文件对查找、删除、增加、修改单条记录的操作比较困难】</p><p>​</p><p>a) 串结构</p><p>【记录之间的顺序与关键字无关，通常由时间决定，即按存入的先后时间排列】</p><p>b) 顺序结构</p><p>【所有的记录以关键字的顺序进行排列】</p><p>2) 索引文件：</p><p>【对于定长的记录文件，可以很方便地得到某一条记录据第一条记录的位置】</p><p>【而对于可变长的记录文件，需要通过顺序地查找某条记录之前所有记录才能得到其的位置】</p><p>【变长文件只能顺序查找，系统开销大，为此，通过建立一张索引表以加快检索的速度】</p><p>【索引表是一个定长记录的顺序文件】</p><p>【索引表的表项由索引表编号、记录长度、指向逻辑文件中记录的位置的指针组成】</p><p>​</p><p>3) 索引顺序文件：</p><p>【将顺序文件中的记录分成若干组，为顺序文件建立一张索引表】</p><p>【索引表的表项由每组记录中第一条记录的关键字和指向该记录的指针组成】</p><p>【组间关键字必须连续】</p><p>【对于含N条记录的顺序文件，查找某条记录时平均需查找N/2次；若将其划分成sqrt(N)组，查找某条记录时先查找索引表以确定其所在组的第一条记录位置，然后顺序查找其顺序文件中所在的组，平均查找sqrt(N)次】</p><p>4)直接文件/散列文件：</p><p>【给定记录的键值或通过散列函数转换的键值直接决定记录的物理地址】</p><p>【没有顺序的特性】</p><p>【有很高的存取速度，但会引起冲突，即不同关键字的散列函数值相同】</p><p>​</p><h2 id="Q36：目录及目录结构"><a href="#Q36：目录及目录结构" class="headerlink" title="Q36：目录及目录结构"></a>Q36：目录及目录结构</h2><p>l 目录管理的基本要求：</p><p>从用户角度看，目录在用户（应用程序）所需的文件和文件名提供一种映射，即目录应实现“按名存取”；</p><p>目录的检索会直接影响到系统效率，因此应提高目录的检索速度；</p><p>在共享系统中，目录还需提供用于控制访问文件的信息；</p><p>文件名重名也是用户合理和必然的要求，因此通过树形结构来解决和实现的；</p><p>​</p><p>l 文件控制块(FCB):</p><p>【用来存放控制文件需要的各种信息的数据结构，以实现“按名存取”】</p><p>【FCB的有序集合称为文件目录。一个FCB就是一个文件目录项】</p><p>①基本信息：</p><p>【文件名、文件的物理位置、文件的逻辑结构、文件的物理结构等】</p><p>②存取控制信息：</p><p>【文件存取权限等】</p><p>③使用信息：</p><p>【文件建立时间、修改时间等】</p><p>​</p><p>l 索引结点(i node)：</p><p>【在检索目录文件过程中，只用到了文件名，仅当找到一个匹配的目录项时，才需从该目录项中读出文件的物理位置】</p><p>【因此，有的系统（如UNIX）采用了将文件名和文件描述信息分开的办法，文件描述信息单独构成一个索引结点】</p><p>【在文件目录中的每个目录项由文件名和指向该文件对应的索引结点的指针构成】</p><p>【一个盘块是1KB，一个FCB是64B，那么一个盘块可以存放16个FCB；而在UNIX系统中，一个FCB使16B，那么一个盘块可以存放64个FCB，因此减少了查找文件时平均启动磁盘的次数，降低了系统开销】</p><p>【连续存放的】</p><p>​</p><p>磁盘索引结点：</p><p>【UNIX系统中每个文件都有唯一的磁盘索引结点】</p><p>①文件主标识符</p><p>【拥有该文件的个人或小组的标识符】</p><p>②文件类型</p><p>【普通文件、目录文件、特殊文件（如UNIX中的输入/输出设备）】</p><p>③文件存取权限</p><p>【各用户对该文件的存取权限】</p><p>④文件物理地址</p><p>【每个索引结点有13个地址项，直接或间接地给出数据文件所在盘块的编号】</p><p>⑤文件长度</p><p>【以字节为单位】</p><p>⑥文件的链接计数</p><p>【在本文件系统中所有指向该文件的文件名的指针计数】</p><p>⑦文件的存取时间</p><p>【本文件最近被进程存取的时间、最近被修改的时间及索引结点最近被修改的时间】</p><p>​</p><p>在文件被打开时，磁盘索引结点赋值到内存的索引结点中，方便使用。增加了，</p><p>①索引结点编号</p><p>【用于标识内存索引结点】</p><p>②状态</p><p>【指示索引结点是否上锁或被修改】</p><p>③访问计数</p><p>【每当一进程要访问该结点时，计数加一】</p><p>④逻辑设备号</p><p>【文件所属文件系统的逻辑设备号】</p><p>⑤链接指针</p><p>【设置分别指向空闲链表和散列队列的指针】</p><p>​</p><p>l 目录层次上要执行的操作：</p><p>搜索：</p><p>【当用户使用一个文件时，需要搜索目录，以找到该文件对应的目录项】</p><p>创建文件：</p><p>【用户创建一个文件时，需要在其目录中增加一个相应的目录项】</p><p>删除文件：</p><p>【用户删除一个文件时，需要在其目录中删除一个相应的目录项】</p><p>显示目录：</p><p>【用户可以通过请求显示目录中内容，如显示该用户目录中所有文件及属性】</p><p>修改目录：【某些文件属性保存在目录中，因而这些属性的变化需要相应地改变目录中的内容】</p><p>​</p><p>l 目录结构：</p><p>①单级目录结构：</p><p>【整个系统中只存在一张目录表，每个文件占一个目录项】</p><p>【当访问一个文件时，首先根据文件名在该目录中查找相应的FCB，经合法检查后继续执行其他相关操作】</p><p>【当建立一个文件时，首先遍历整个目录以确保不存在“重名”的情况，然后在目录中增加一个目录项】</p><p>【当删除一个文件时，首先查找目录找到删除文件相应的目录项，然后回收文件所占的内存空间等资源，删除相应的目录项】</p><p>【实现了“按名存取”，但存在查找速度慢，文件不允许重名，不便于文件共享，显然对多用户的OS不适用】</p><p>​</p><p>②两级目录结构：</p><p>【将文件目录划分为主文件目录MFD和用户文件目录两级UFD】</p><p>【主文件目录的目录项记录用户名及相应用户文件目录所在的位置】</p><p>【用户文件目录的目录项由用户文件的FCB有序组成】</p><p>【允许多用户之间文件重名；文件系统可以在目录上实现访问限制；但不灵活，不能对文件进行分类】</p><p>​</p><p>③多级（树形）目录结构：</p><p>【用户访问某文件时，用文件的路径名来标识文件】</p><p>【文件路径名是一个字符串】</p><p>【绝对路径由从根目录出发都所找文件路径上所有的目录名和数据文件名称用“/”连接而成】</p><p>【当层次较多时，每次从根目录出发都会浪费时间，因此引入了当前目录/工作目录】</p><p>【当前目录存于内存】</p><p>【相对路径由从当前目录出发都所找文件路径上所有的目录名和数据文件名称用“/”连接而成】</p><p>【通常每个用户都有自己的工作目录，用户登录后进入了自己的当前目录中；OS提供一条专门的系统调用，用户可以随时地改变当前目录】</p><p>【层次清晰，便于对文件进行分类，也能有效地对文件进行保护和管理；但不便于实现文件共享】</p><p>​</p><p>④无环图目录结构：</p><p>【为了实现文件共享而引入】【在树形目录结构的基础上增加了一些指向同一结点的有向边】</p><p>【当某用户删除一个共享文件时，若只是简单的删除共享文件，则当另一共享用户访问时就会出错，因此在每个共享结点中设置一个共享计数器，记录所共享文件的用户（进程）数】</p><p>【每当增加一个指向共享结点的共享链时，该共享结点的共享计数器加1】</p><p>【每当一个用户要删除一个共享文件时，该共享文件的共享计数器减1，然后只删除该用户到共享文件的共享链；直到共享计数器为0时，系统才删除该共享文件，释放其FCB所占空间】</p><p>【共享：实际只存在一个文件，逻辑上存在多个；拷贝：存在多个文件】</p><h2 id="Q37：文件共享"><a href="#Q37：文件共享" class="headerlink" title="Q37：文件共享"></a>Q37：文件共享</h2><p>l 静态共享：</p><p>①基于索引结点的共享（硬链接）</p><p>【在树形目录结构，当两个用户或多个用户要共享一个文件或子目录时，要将共享文件或子目录链接到两个用户或多个用户的目录中，以方便地找到该文件】</p><p>【这种共享方式将文件的名称和文件描述信息分开，目录的目录项中只包含文件名和指向其对应i结点的指针，而文件描述信息存放于i结点中，i结点包括一个链接计数器，用来表示链接到该索引结点上的用户目录项的数目】</p><p>【当用户删除一个共享文件时，若将其共享文件对应的索引结点删除，则会导致其他共享该文件的用户指针悬空；因此引入链接计数器】</p><p>【只当链接计数器为0时，系统才会删除该共享文件对应的索引结点】</p><p>​</p><p>②基于符号链的共享（软链接）</p><p>【当其他用户需要共享文件主创建的文件时，系统创建一个LINK类型的文件，名称和要共享的文件名称相同，并且将新文件写入到其用户目录中】</p><p>【新文件的内容只包含要共享的文件的路径名】</p><p>【在基于符号链的共享方式中，只有文件拥有者才有指向其文件的索引结点的指针；而其他用户访问共享文件时，是通过访问LINK类型文件得到共享文件路径名，然后根据路径名对其进行访问】</p><p>【当文件拥有者删除其共享文件时，删除其索引结点；而当其他用户访问该共享文件时，会出现访问失败，系统将会将其符号链删除，不会导致其他影响】</p><p>【存在的问题：当文件主删除其共享文件后，在其他用户访问该共享文件之前，又在共享文件所在的目录下创建了一个和共享文件同名的新文件，则会导致其他用户所访问内容不是其所需的】</p><p>【缺点：用户（非文件主）访问共享文件时，会增加访问磁盘的次数，增加系统开销；并且会占用额外的存储空间】</p><p>【最大的优点是网络共享只需要提供文件所在机器的网络地址和在该机器中的文件位置即可】</p><p>​</p><p>l 动态共享：多个进程对同一个文件进行访问。</p><p>​</p><h2 id="Q38：文件保护"><a href="#Q38：文件保护" class="headerlink" title="Q38：文件保护"></a>Q38：文件保护</h2><p>【口令保护和加密保护是为了防止用户文件被他人存取或窃取】</p><p>【访问控制是控制用户对文件的访问方式】</p><p>【对多级目录结构而言，不仅对单个的文件要进行保护，而且需要对子目录内文件进行保护，即提供对目录的保护机制；由于目录和文件操作不同，所需的保护机制也不同】</p><p>​</p><p>①口令保护：</p><p>【用户在创建一个文件时提供一个口令，系统为其创建FCB并附上相应的口令，同时告知共享该文件的用户在访问时必须提供相应的口令】</p><p>【时空开销小，不安全（口令存在于系统内部）】</p><p>②加密保护：</p><p>【用户对文件进行加密和解密，文件被访问时需要使用秘钥】</p><p>【保密性强，节省了一定存储空间；但加密和解密要占用一定的时间】</p><p>③访问控制：</p><p>n 访问控制方式：</p><p>读、写、执行、添加、删除、列表清单（列出文件名和文件属性）</p><p>此外，还可以对文件重名、复制、编辑等加以控制，这些高层功能可以通过底层功能来实现；因此，可以只在底层实现保护。</p><p>​</p><p>【解决访问控制最常用的方法是基于用户身份进行访问控制】</p><p>【而实现基于用户身份访问最简单的方法就是为每个文件和目录增加一个访问控制列表ACL，以规定每个用户名和其所允许的访问类型】</p><p>【优点：可以实现复杂的访问方法】</p><p>【缺点：表长无法估计，可能会导致复杂的空间管理】</p><p>【解决方法：精简的访问列表（拥有者、组、其他三种用户类型）】</p><p>【文件拥有者在创建文件时，说明创建者的用户名和其所在的组的名称。系统在创建文件时，将文件主的名称和其所在的组名列在该文件的FCB】</p><p>【多用户对一个文件进行访问时是通过存取控制矩阵来进行的】</p><p>​</p><h2 id="Q39：文件系统的层次结构"><a href="#Q39：文件系统的层次结构" class="headerlink" title="Q39：文件系统的层次结构"></a>Q39：文件系统的层次结构</h2><p>【现代OS有不同的文件系统类型，如FAT32、NTFS、ext2、ext3、ext4等】</p><p>①用户调用接口：</p><p>【文件系统为用户提供与文件及目录有关的调用，如新建、打开、读写、关闭、删除文件等，建立、删除目录等】</p><p>【该层是由若干的数据模块组成，每个数据模块对应一个系统调用，用户发出系统调用，控制权就转给相应的模块】</p><p>②文件目录系统：</p><p>【主要功能是管理文件目录。其任务有管理活跃文件打开表、管理读写状态信息表、管理用户进程的文件打开表、管理存储设备上的文件目录结构以及调用下一层控制模块】</p><p>③存取访问验证模块：</p><p>【实现文件保护主要由该层完成。将用户的访问请求和文件FCB中对用户访问控制权限进行对比，以确保访问的合法性】</p><p>④逻辑文件系统及文件信息缓冲区：</p><p>【主要功能是将逻辑文件中要读写的逻辑记录转换成文件逻辑结构内相应的块号】</p><p>⑤物理文件系统：</p><p>【主要功能是将逻辑记录相应的块号映射成实际的物理地址】</p><p>⑥辅助分配模块：</p><p>【主要功能是分配空闲辅存空间、回收辅存空间等】</p><p>⑦设备管理程序模块：</p><p>【主要功能是分配设备、分配设备读写的缓冲区、磁盘调度、启动设备、处理设备中断、释放设备读写的缓冲区、释放设备等】</p><h2 id="Q40：目录实现"><a href="#Q40：目录实现" class="headerlink" title="Q40：目录实现"></a>Q40：目录实现</h2><p>【在读文件之前要打开文件，OS根据其路径名找到对应的目录项，其中有文件的物理地址】</p><p>【目录查询是通过在磁盘上反复搜索完成，需要不断地进行I/O操作，开销大；因此为了减小开销，通常将当前使用文件目录存入内存】</p><p>①线性列表</p><p>【最简单的目录实现方法是使用存储文件名和数据块指针构成的线性表】</p><p>【在创建文件时，要遍历目录以确保没有同名的文件存在；再删除文件时，要根据删除文件名称搜索目录以找到相应目录项，使其为空项，回收空间等资源】</p><p>【通过采用线性链表的方式，在删除时操作简单，但由于线性表的特性，比较费时】</p><p>​</p><p>n 重用目录项的方法：</p><p>1) 可以将目录项标记为不再使用</p><p>2) 可以将其加在空闲目录项表中</p><p>3) 可以将目录的最后一个目录项移到空目录项位置</p><p>​</p><p>②哈希表</p><p>【根据文件名得到一个值，并返回指向线性列表中某个元素的指针】</p><p>【优点：查找迅速，插入、删除简单】</p><p>【缺点：需要一定的措施解决冲突；哈希表表长固定，且哈希函数和哈希表表长的依赖性】</p><p>​</p><p>​</p><h2 id="Q41：文件实现——分配方式"><a href="#Q41：文件实现——分配方式" class="headerlink" title="Q41：文件实现——分配方式"></a>Q41：文件实现——分配方式</h2><p>①连续分配：</p><p>【每个文件占用一组连续的块】</p><p>【作业访问磁盘时寻道数和寻道时间最小】</p><p>【一个文件的目录条目包括开始块地址和该文件所分配区域的长度】</p><p>【支持顺序访问和直接访问】</p><p>【优点：实现简单、存取速度快】</p><p>【缺点：文件长度不宜动态增加；反复地分配和回收会导致外部碎片的产生；很难确定一个文件需要的空间大小，适用于长度固定的文件】</p><p>【访问第n条记录时，需访问1次磁盘】</p><p>②链接分配：</p><p>【没有外部碎片产生】</p><p>1) 隐式链接：</p><p>【每个文件对应一个磁盘块的链表】</p><p>【除了最后一个磁盘块其他的都有指向下一块磁盘块的指针，指针对用户透明】</p><p>【目录结构包含了文件的第一块指针和最后一块的指针】</p><p>【只支持按块链顺序访问】</p><p>【缺点：无法直接访问；指针占用了一定的存储空间；稳定性比较差，系统在运行过程中由于软件或硬件出现错误而导致链接指针损坏或丢失，会导致文件数据的丢失】</p><p>【访问第n条记录时，最多需访问次磁盘n次】</p><p>​</p><p>2) 显示链接：</p><p>【支持直接访问和顺序访问】</p><p>【将用于链接各块的指针提取出来，存放在内存的一张链接表中，该表在磁盘中仅设置一张，即文件分配表FAT】</p><p>【FAT和全部的磁盘块一一对应，可以用-1来表示是文件最后一块，可以用-2表示磁盘块是空闲的】</p><p>【FAT不仅记录了文件的各块先后链接关系，还记录了当前空闲的磁盘块信息】</p><p>【FAT在系统启动时就会被读入内存，因此对FAT的查找是在内存中进行的，提高了检索速度，减少了访问磁盘的次数】</p><p>​</p><p>③索引分配：</p><p>【没有外部碎片产生】</p><p>【将每个文件的所有盘块集中存放一起构成索引块，即磁盘地址构成的数组】</p><p>【每个文件都有索引块】</p><p>【初始时文件索引块的指针全置为空】</p><p>【支持直接访问】</p><p>【缺点：索引块占用了一定的存储空间开销；由于每个文件都有索引块，因此索引块不应过大，而索引块过小会无法支持大文件】</p><p>【访问第n条记录时，需访问次磁盘m+1次（m级索引）】</p><p>【访问某条记录时，首先要访问索引块找到对应数据块的物理地址，为了加快文件的访问速度，通常将文件的索引块读入到内存的缓冲区中】</p><p>解决索引块过小无法支持大文件办法：</p><p>1) 链接方案：</p><p>【通常一个索引块为一个磁盘块，因此可以直接读写；为了支持大文件，可以将多个索引块链接起来】</p><p>2) 多级索引</p><p>3) 混合索引：</p><p>UNIX的索引结点包含13个地址项，10个地址项用于直接地址，一个用于一次间接地址，一个用于二次间接地址，一个用于三次间接地址。</p><p>​</p><h2 id="Q42：文件实现——存储空间管理："><a href="#Q42：文件实现——存储空间管理：" class="headerlink" title="Q42：文件实现——存储空间管理："></a>Q42：文件实现——存储空间管理：</h2><p>l 文件存储空间的划分和初始化：</p><p>【一般来说，一个文件存在于一个文件卷中，一个文件卷可以是物理盘的一部分，也可以是整个物理盘，支持超大型文件的文件卷也可由多个物理盘组成】、</p><p>【在一个文件卷中，文件数据信息空间（文件区）和存放文件控制信息FCB的空间（目录区）是分离的】</p><p>【逻辑卷在提供文件服务前，必须由对应的文件程序进行初始化，划分好文件区和目录区，建立空闲空间管理表格以及存放逻辑卷信息的超级块】</p><p>​</p><p>①空闲表法：</p><p>【属于连续分配方式】</p><p>【为每个文件分配一块连续的存储空间】</p><p>【系统为外存上所有空闲区建立一张空闲盘块表，每个空闲区对应一个空闲表项】</p><p>【表项由表项序号、该空闲区的第一个盘块的盘块号、该区的空闲盘块数组成；所有空闲区按起始盘块号递增顺序排列】</p><p>​</p><p>②空闲链表法：</p><p>1) 空闲盘块链：</p><p>【将所有空闲的盘块以盘块为单位拉成一条链】</p><p>【分配和回收操作简单，但为一个文件分配盘块时可能要重复多次操作】</p><p>2) 空闲盘区链：</p><p>【将所有空闲的盘块以盘区（包含若干个空闲盘块）为单位拉成一条链】</p><p>【在每个盘区除了有指向下一块盘区的指针还有指明本盘块大小（盘块数）信息】</p><p>③位示图法：</p><p>【用二进制的一位来表示磁盘中一个盘块的分配与回收，“1”表示已分配，“0”表示空闲】</p><p>④成组链表法：</p><p>【空闲表法和空闲链表法都不是用于大型文件系统，主要是因为表长太大】</p><p>【把顺序的n个空闲扇区地址保存在第一个空闲扇区内，其后的一个空闲扇区内则保存另一个顺序空闲扇区的地址，依次继续】</p><p>​</p><p>【表示文件存储器空闲空间的“位向量”表或第一个成组链块，以及卷中文件区和目录区的划分信息都需存放在存储器中，一般放在卷头位置，在UNIX系统中称为超级块】</p><p>【在对卷中的文件进行操作之前，超级块应预先读入系统空闲的主存，并经常保持主存中的超级块与辅存卷中的超级块的一致性】</p><p>​</p><h2 id="Q43：磁盘结构"><a href="#Q43：磁盘结构" class="headerlink" title="Q43：磁盘结构"></a>Q43：磁盘结构</h2><p>磁盘：由表面涂有磁性物质的金属或塑料构成的圆形盘片。</p><p>【通过一个称为磁头的导体线圈来从磁盘上存取数据】</p><p>【在读写期间，磁头固定，磁盘在下面进行高速旋转】</p><p>【磁盘的密度从最外道向里增加，磁盘的存储能力受限于最内道的最大记录密度】</p><p>磁道：磁盘上的数据存储在一组同心圆中。</p><p>【磁道和磁头一样宽，一个盘面上有上千个磁道】</p><p>扇区：一个扇区称为一个盘块。</p><p>【一个磁道分为几百个扇区】</p><p>【每个扇区固定存储大小（通常为512B）】</p><p>【磁道间、扇区间存在间隙，以避免精度错误】</p><p>磁盘驱动器：磁头臂、用于旋转磁盘的主轴、用于数据输入/输出的电子设备组成。</p><p>【多个磁盘垂直重叠构成磁盘组，所有盘面上相同位置的磁道构成柱面】</p><p>【每个盘面对应一个磁头，所有的磁头固定在一起，与磁盘中心距离相同且一起移动】</p><p>磁盘地址：柱面号·盘面号·扇区号</p><p>【扇区是磁盘可寻址的最小存储单位】</p><p>按磁头相对于盘片的径向是否可以移动分：</p><p>固定头磁盘（每个磁道一个磁头）、活动头磁盘</p><p>按磁盘在磁盘驱动器中是否可以更换分：</p><p>固定盘磁盘、可换盘磁盘</p><p>​</p><h2 id="Q44：一次磁盘读-写的时间"><a href="#Q44：一次磁盘读-写的时间" class="headerlink" title="Q44：一次磁盘读/写的时间"></a>Q44：一次磁盘读/写的时间</h2><p>①寻道时间：</p><p>活动头磁盘在读写信息前，将磁头移动到指定磁道的时间。</p><p>【包括将磁头移到指定磁道所需的时间及启动磁头臂的时间（约为2ms）】</p><p>②旋转延迟时间：</p><p>将磁头定位到某一扇区所需的时间。</p><p>【1/(2r)，磁盘转速r】</p><p>③传输时间：</p><p>从磁盘读出或向磁盘写入的时间。</p><p>【取决于要读/写的字节数b以及磁盘转速r，b/(rN)，N是一个磁道上的字节数】</p><p>​</p><p>优化方法：</p><p>针对寻道时间：磁盘调度算法。</p><p>针对旋转延迟时间：对盘面的扇区交替编号及磁盘组的不同盘面错位命名。</p><h2 id="Q45：磁盘调度算法"><a href="#Q45：磁盘调度算法" class="headerlink" title="Q45：磁盘调度算法"></a>Q45：磁盘调度算法</h2><p>①FCFS：</p><p>【进程请求访问磁盘的先后顺序】【具有公平性】</p><p>【若只有少量进程需要访问，且大部分请求都是访问簇聚的文件扇区，则有望达到较好的性能】</p><p>【若有大量进程竞争使用磁盘，则FCFS算法趋近于随机调度】</p><p>②SSTF：</p><p>【磁道与当前磁头所在磁道距离最近】【会产生“饥饿”现象】</p><p>③SCAN：</p><p>【在磁头当前移动方向上与磁头所在磁道距离最近的磁道】</p><p>【SCAN算法对最近访问过的磁道具有不公平性，因此在访问局部性方面不如FCFS、SSTF】</p><p>【偏向于处理接近最里或最外的磁道的请求】</p><p>④C-SCAN：</p><p>【在SCAN基础上，磁头在回返时快速移动至起始端，而不服务任何请求】</p><p>⑤LOOK：</p><p>【在SCAN基础上，要求磁头只需移动到最远端的一个请求后就立即返回，不需要到达磁盘终点】</p><p>⑥C-LOOK：</p><p>【在C-SCAN基础上，要求磁头只需移动到最远端的一个请求后就立即返回，不需要到达磁盘终点】</p><p>⑦N-STEP-SCAN：</p><p>【在SCAN基础上，将请求队列的所有请求划分为长度为N的子队列，处理顺序以FIFO进行】</p><p>【当正在处理一个子队列时，新到的I/O请求加入到其他的子队列中】</p><p>​ ⑧FSCAN：</p><p>【使用两个子队列，扫描开始时，所有的请求都在一个子队列中，其后到达的所有新请求都放在另一个子队列中】</p><p>【用SCAN算法处理旧请求，新请求的处理延迟在旧请求之后】</p><p>​</p><h2 id="Q46：磁盘管理"><a href="#Q46：磁盘管理" class="headerlink" title="Q46：磁盘管理"></a>Q46：磁盘管理</h2><p>①磁盘的初始化：</p><p>【一块新的磁盘只是一个含磁性物质的空白圆片】</p><p>【低级格式化/物理分区：在磁盘存储数据之前，它必须划分成扇区以便磁盘控制器进行读/写操作】</p><p>【低级格式化为磁盘的每个扇区采用了特别的数据结构，每个扇区的数据结构由头部、数据区域（通常为512B）、尾部组成】</p><p>【头部和尾部包含了一些磁盘控制器所使用的信息】</p><p>为了使用磁盘存储文件，OS还需将自己的数据结构保存在磁盘上：</p><p>1) 将一个磁盘分成由一个或多个柱面组成的分区</p><p>2) 对物理分区进行逻辑格式化，OS将初始化文件系统的数据结构存储在磁盘上，包括空闲和已分配的空间及一个初始为空的目录</p><p>②引导控制块&amp;分区控制块：</p><p>计算机在启动时需运行一个初始化程序（自举程序），它初始化CPU、寄存器、设备控制器和内存等，接着启动OS。为此，自举程序应找到磁盘上的OS内核，载入内存，并转到起始地址，从而开始OS运行。</p><p>【自举程序通常保存在ROM中，为了避免改动自举程序而需要改变ROM硬件的问题，只在ROM中保留很小的自举装入程序】</p><p>【将完整的自举程序保存在磁盘的启动块上，启动块位于磁盘的固定位置，包含启动分区的磁盘称为启动磁盘/系统磁盘】</p><p>引导控制块包含系统从该分区引导OS所需的信息。</p><p>【若磁盘无OS则其为空】</p><p>【通常为分区的第一块】</p><p>【UFS称为引导块，NTFS称为分区引导扇区】</p><p>分区控制块包括分区详细信息。</p><p>如分区的块数、块的大小、空闲块的数量、空闲FCB数量等。</p><p>【UFS称为超级块，NTFS称为主控文件表】</p><p>③坏块：</p><p>【由于磁盘有移动部件且容错能力弱，因此容易导致一个或多个扇区损坏】</p><p>【对于简单磁盘，如电子集成驱动器IDE，坏扇区可手动处理。坏扇区在FAT表会标明，因此程序不会使用】</p><p>【对于复杂磁盘，如小型计算机系统接口SCSI，其控制器维护一个磁盘坏块链表】【在出厂低级格式化时就已初始化】</p><p>【扇区备用：低级格式化将一些扇区保留作为备用，对OS透明，控制器可用备用块来逻辑替换坏块】</p><p>​</p><h2 id="Q47：内存结构"><a href="#Q47：内存结构" class="headerlink" title="Q47：内存结构"></a>Q47：内存结构</h2><p>内存分区：包含所有安装分区的信息。</p><p>内存目录结构用来保存最近访问过的目录信息。对于安装分区的目录，可以包括一个指向分区表的指针。</p><h2 id="Q48：文件系统实现概述"><a href="#Q48：文件系统实现概述" class="headerlink" title="Q48：文件系统实现概述"></a>Q48：文件系统实现概述</h2><p>为了创建一个文件，应用程序调用逻辑文件系统。它将为文件分配一个新的FCB，并把相应目录写入内存，用新的文件名更新目录和FCB，并将结果写回磁盘。</p><p>一旦文件创建就能用于I/O，不过在使用文件之前要打开文件。</p><p>调用open将文件名传给文件系统，文件系统根据给定文件名搜索目录结构。</p><p>【为了加快检索速度，部分目录缓存在内存中】</p><p>找到文件后，将FCB复制到系统范围的打开文件表。</p><p>【该表不仅存储FCB，还存储打开该文件进程数目的条目】</p><p>然后，在进程的打开文件表中增加一个条目，并通过指针将系统范围的打开文件表中的相应条目和其他域（文件当前位置的指针、文件的打开模式等）相连。</p><p>调用open返回一个指向进程的打开文件表中合适条目的指针，所有的文件操作都通过该指针进行。</p><p>【对于访问打开文件表的索引，UNIX称为文件描述符，Windows2000称为文件句柄】</p><p>当一个进程关闭文件时，就会删除进程的打开文件表中的一个条目，系统范围打开文件表中的打开数递减。</p><p>当打开文件的所有用户都关闭了一个文件时，更新的文件信息会复制在磁盘的目录结构中，系统范围打开文件表相应的条目也会删除。</p><p>【在实际中，系统调用open时会首先检索系统范围打开文件表，以确保文件是否已被其他进程所使用】</p><p>​</p><p>​</p><h1 id="CHAPTER-5"><a href="#CHAPTER-5" class="headerlink" title="CHAPTER 5"></a>CHAPTER 5</h1><h2 id="Q49：I-O设备分类"><a href="#Q49：I-O设备分类" class="headerlink" title="Q49：I/O设备分类"></a>Q49：I/O设备分类</h2><p>按使用属性：</p><p>①人机交互设备：</p><p>【如打印机、键盘、鼠标、显示器等】</p><p>【数据交换速度相对较慢】</p><p>【通常以字节为单位进行数据交换】</p><p>②存储设备：</p><p>【如磁盘、磁带、光盘等】</p><p>【数据交换速度相对较快】</p><p>【通常以多字节组成的块为单位进行数据交换】</p><p>③网络通信设备：</p><p>【如各种网络接口、调制解调器等】</p><p>按信息交换单位：</p><p>①块设备：</p><p>【如磁盘等】</p><p>【有结构设备】</p><p>【传输速率较高、可寻址，即对它可任意读/写某一块】</p><p>【输入/输出时采用DMA控制方式】</p><p>②字符设备：</p><p>【如打印机等】</p><p>【无结构设备】</p><p>【传输速率低、不可寻址】</p><p>【输入/输出时采用中断驱动方式】</p><p>按传输速率：</p><p>①低级设备：</p><p>【如键盘、鼠标等】</p><p>【每秒几字节至几百字节】</p><p>②中级设备：</p><p>【如打印机等】</p><p>【每秒几千字节至上万字节】</p><p>③高级设备：</p><p>【如磁盘机、磁带机、光盘机等】</p><p>【每秒几百千字节至千兆字节】</p><p>按访问方式：</p><p>①基于互斥访问的互斥设备</p><p>②基于分时共享访问的共享设备：</p><p>【如磁盘等】【必须可寻址、可随机访问】</p><p>③基于SPOOLING技术访问的虚拟设备：</p><p>​</p><h2 id="Q50：I-O控制方式"><a href="#Q50：I-O控制方式" class="headerlink" title="Q50：I/O控制方式"></a>Q50：I/O控制方式</h2><p>①程序直接控制方式：</p><p>【计算机从外部设备读取数据到存储器，每次读一个字的数据，对读入的每个字，CPU需要对外设状态进行循环检查，直到确定该字已经在I/O控制器的数据寄存器中】</p><p>【CPU之所以不断地循环检查外设状态，是因为CPU未采用中端机构，使得I/O设备无法向CPU报告已完成一个字的输入操作】</p><p>【简单易于实现，但由于CPU和I/O设备只能串行工作，导致CPU的利用率比较低】</p><p>②中断驱动方式：</p><p>【允许I/O设备主动打断CPU地运行并请求提供服务】</p><p>从I/O控制器角度看，</p><p>【I/O控制器从CPU接收一个读命令，然后从外围设备读数据】</p><p>【一旦数据读入该I/O控制器的数据寄存器，便通过控制线给CPU发出一个中断信号，表示数据已准备好，然后等待CPU请求该数据】</p><p>【I/O控制器接收到CPU发出的数据请求后，将数据放到数据总线上，传至CPU的寄存器中】</p><p>从CPU角度看，</p><p>【CPU发出读命令，然后保存当前运行程序的上下文，转而执行其他程序】</p><p>【在每个指令周期的末尾，CPU检查中断；当有来自I/O控制器的中断时，CPU保存当前正在运行进程的上下文，转去执行中断处理程序以处理该中断】</p><p>【这时，CPU从I/O控制器中读一个字的数据传送至寄存器，并存入主存】</p><p>【接着，CPU恢复发出I/O命令的程序或其他程序的上下文，然后继续运行】</p><p>​</p><p>③DMA控制方式：</p><p>【在I/O设备和内存间开辟直接的数据交换通路】</p><p>【基本单位是数据块】</p><p>【所传的数据是从设备直接到内存的，或者相反】</p><p>【仅在传送一个数据块或多个数据块的开始和结尾，才需CPU干预，整块数据的传送是在DMA控制器下完成的】</p><p>【CPU接收到I/O设备的DMA请求时，它给I/O控制器发出一条命令，启动DMA控制器，然后转而执行其他工作】</p><p>【之后CPU将控制权交给DMA控制器，DMA控制器直接与存储器交互，传送整个数据块，该过程不需CPU参与】</p><p>【传送完成后，DMA控制器发送一个中断信号给CPU】</p><p>​</p><p>n DMA控制器中的寄存器：</p><p>1) 控制寄存器/状态寄存器(CR)：</p><p>【用于接收从CPU发出的I/O命令或有关控制信息，或设备的状态】</p><p>2) 数据寄存器(DR)：</p><p>【用于暂存从设备到内存或从内存到设备的数据】</p><p>3) 数据计数器(DC)：</p><p>【存放本次传送数据的字节数】</p><p>4) 内存地址寄存器(MAR)：</p><p>【在输入时，存放从设备到内存的起始目标地址】</p><p>【在输出时，存放从内存到设备的内存源地址】</p><p>​</p><p>④通道控制方式：</p><p>【I/O通道是指专门负责输入/输出的处理机】</p><p>【通道的指令类型单一】</p><p>【通道所执行的通道程序是放在主机的内存中】</p><p>【没有自己的内存，与CPU共享内存】</p><p>【把对一个数据块的读/写为单位的干预减少为对一组数据块的读/写和有关管理和控制为单位的干预】</p><p>【实现CPU、通道和I/O设备并行操作】</p><p>【当CPU要执行一组相关读/写操作及有关控制时，只需向I/O通道发送一条I/O指令，指明所要执行的通道程序的首地址和要访问的设备】</p><p>【通道接到该指令后，执行通道程序便可完成CPU指定的I/O任务，数据传送结束时向CPU发送中断请求】</p><p>与DMA控制方式区别：</p><p>DMA方式需要CPU来控制传输的数据块大小、传输内存位置，而通道方式中由通道控制；</p><p>每个DMA控制器对应一个设备，而一个通道可控制多个设备与内存进行数据交换；</p><p>通道类型：字节多路通道、数组选择通道、数组多路通道</p><h2 id="Q51：I-O系统层次结构"><a href="#Q51：I-O系统层次结构" class="headerlink" title="Q51：I/O系统层次结构"></a>Q51：I/O系统层次结构</h2><p>①用户层I/O软件：</p><p>【实现与用户交互的接口】</p><p>【用户可以直接调用在用户层提供的、与I/O有关的库函数，对设备进行操作】</p><p>【用户可以通过系统调用的方式请求OS提供服务】</p><p>②设备独立软件：</p><p>【实现用户程序与设备驱动器的统一接口、设备命令、设备保护、设备的分配与回收、同时为设备的管理和数据的传送提供必要的存储空间】</p><p>1) 执行所有设备的公共操作：</p><p>【设备的分配与回收、将逻辑设备名映射成物理设备名、对设备进行保护，避免用户直接访问设备、缓冲管理、差错控制、提供独立于设备的大小统一的逻辑块】</p><p>2) 向用户层（文件层）提供统一接口：</p><p>【例如对各种设备的读/写操作，在应用程序中统一使用read/write命令等】</p><p>设备独立性，即设备无关性，使得应用程序独立于具体使用的物理设备。</p><p>【在应用程序中使用逻辑设备名来使用某些设备，而在系统实际执行的过程中，需要将逻辑设备名映射成物理设备名使用】</p><p>【使用逻辑设备名的好处：1)增加设备分配的灵活性2)易于实现I/O重定向（是指用于I/O操作的设备可更换，无需改变应用程序）】</p><p>​</p><p>③设备驱动软件：</p><p>【具体实现系统对设备发出的命令】</p><p>【每类设备配置一个设备驱动程序】</p><p>【是I/O进程和设备控制器之间通信程序，通常以进程形式存在】</p><p>④中断处理程序：</p><p>【进行进程上下文切换、对处理中断信号源进行测试、读取设备状态、修改进程状态等】</p><p>⑤硬件层：</p><p>【I/O设备通常包括一个机械部件和一个电子部件】</p><p>【为了达到设计的模块性和通用性，一般将其分开】</p><p>【电子部件称为设备控制器（适配器），在个人计算机中，通常是一块插入主板扩充槽的印刷电路板】</p><p>【机械部件即为设备本身】</p><h2 id="Q52：设备控制器"><a href="#Q52：设备控制器" class="headerlink" title="Q52：设备控制器"></a>Q52：设备控制器</h2><p>【设备控制器通过寄存器与CPU通信，有的计算机中，这些寄存器占用内存的一部分，称为内存映像I/O；而在其他计算中，采用I/O专用地址，寄存器独立编址】</p><p>​</p><p>【OS向控制器寄存器写命令字来执行I/O功能】</p><p>【控制器接收到一条命令时，CPU转而执行其他工作，而让设备控制器自行完成I/O功能】</p><p>【当命令执行完毕后，控制器发出一个中断信号，OS重新获得CPU的控制权并检查运行结果】</p><p>【CPU仍旧从控制权中读取信息来获得执行结果和设备的状态信息】</p><p>​</p><p>设备控制器的主要功能：</p><p>①接收和识别CPU或通道发出的命令</p><p>②实现数据交换</p><p>【设备和控制器间的数据传输】</p><p>【通过数据总线或通道，控制器和内存间的数据传输】</p><p>③发现和记录设备以及设备自身状态，供CPU处理使用</p><p>④设备地址识别</p><p>设备控制器组成：</p><p>①设备控制器与CPU接口</p><p>【该接口有三类信号线：数据线（DR、CR）、地址线、控制线】</p><p>②设备控制器与设备接口</p><p>【一个接口连接一个设备】</p><p>【每个接口存在数据、状态、控制三种类型的信号】</p><p>③I/O控制逻辑</p><p>【用于实现设备控制】</p><p>【通过一条控制线和CPU交互，对从CPU收到的I/O命令进行译码】</p><p>【CPU启动设备时，将启动命令发送给设备控制器，同时通过地址线将地址发送给控制器，由控制器的I/O逻辑对地址进行译码，并相应地选择设备进行控制】</p><h2 id="Q53：I-O核心子系统"><a href="#Q53：I-O核心子系统" class="headerlink" title="Q53：I/O核心子系统"></a>Q53：I/O核心子系统</h2><p>I/O子系统：</p><p>由于I/O设备种类繁多，功能和传输速率也有较大差异，因此需要多种办法来对设备进行控制，这些方法共同组成OS内核的I/O子系统。</p><p>​ 主要的功能有：</p><p>I/O调度、磁盘高速缓存和缓冲区、设备的分配与回收、SPOOLing系统等。</p><h2 id="Q54：I-O调度"><a href="#Q54：I-O调度" class="headerlink" title="Q54：I/O调度"></a>Q54：I/O调度</h2><p>【应用程序所发出的系统调用顺序不一定是最佳的，通过I/O调度来改善系统整体系统，使进程间公平地对共享设备进行访问，减少I/O完成所需要的平均等待时间】</p><p>【OS为每个设备维护一个请求队列来实现调度】</p><p>【当一个应用程序执行I/O调用阻塞时，该请求就加到相应设备的请求队列上】</p><p>​</p><h2 id="Q55：高速缓存及缓冲区："><a href="#Q55：高速缓存及缓冲区：" class="headerlink" title="Q55：高速缓存及缓冲区："></a>Q55：高速缓存及缓冲区：</h2><p>l 磁盘高速缓存：</p><p>【提供磁盘的I/O速度】</p><p>【逻辑上在磁盘，物理上在内存】</p><p>【高速缓存上有的数据，低速设备上必然有】</p><p>在内存的两种形式：</p><p>1) 在内存开辟一个单独的、大小固定的存储空间作为磁盘高速缓存；</p><p>2) 把未利用的内存空间作为一个缓冲池，供请求调页系统和磁盘I/O时共享；</p><p>​</p><p>l 缓冲区：</p><p>n 引入缓冲区的目的：</p><p>1) 缓和CPU与I/O设备速度不匹配的矛盾</p><p>2) 减少CPU的中断频率，放宽对CPU中断响应时间的限制</p><p>3) 解决基本数据单元（即数据粒度）不匹配的问题</p><p>4) 提供CPU和I/O设备之间的并行性</p><p>n 实现方法：</p><p>1) 采用硬件缓冲器，价格高昂，一般不采用；</p><p>2) 内存建立缓冲区；</p><p>n 特点：</p><p>只有当缓冲区为空时才可以写，只有当缓冲区满时才可以读；读操作是一次性的操作。</p><p>​</p><p>n 单缓冲：</p><p>【在设备和处理机之间建立一个缓冲区，设备与处理机交换数据时，先把交换数据写入缓冲区，然后设备或处理机从缓冲区中将数据拿走】</p><p>在研究各种缓冲技术对每块的处理时间时，首先假定一个初始状态，然后计算下一次达到相同状态所需的时间。</p><p>【初始状态：工作区满的，缓冲区为空】</p><p>（T：在块设备输入时，假定从磁盘把一块数据输入到缓冲区的时间为T）</p><p>（M：OS将该缓冲区的数据传送到用户区的时间为M）</p><p>（C：CPU对这一块数据的处理时间为C）</p><p>T&gt;C时，</p><p>把一块数据从磁盘输入缓冲区，花费时间为T，此时缓冲区已满，而工作区为空；因此将缓冲区数据传送到工作区花费时间为M，此时工作区满、缓冲区为空，故对一个数据块的处理时间为T+M。</p><p>T&lt;C时，</p><p>把一块数据从磁盘输入缓冲区，花费时间为T，此时缓冲区已满，而工作区非空，因此等待CPU完成数据处理，此时整体花费时间为C，缓冲区为满，工作区为空；和上述操作相同，得到对一个数据块处理时间为C+M。</p><p>故，单缓冲对一个数据块的处理时间为 (max(T,C)+M)。</p><p>n 双缓冲：</p><p>【初始状态：工作区为空的，缓冲区1满，缓冲区2为空】</p><p>T&gt;M+C时，</p><p>此时将缓冲区1的数据传送到工作区，而磁盘向缓冲区2输入数据块；当数据从缓冲区1传送到工作区后，此时花费时间为M，而缓冲区2未冲满，继续将数据从磁盘冲入缓冲区2，此时CPU处理工作区的数据;当CPU处理完工作区数据时，缓冲区2未冲满，继续将数据从磁盘冲入缓冲区2，直至缓冲区2冲满，此时总共花费时间为T，缓冲区2满，缓冲区1为空，工作区为空，故对一个数据块的处理时间为T。</p><p>T&lt;M+C时，</p><p>此时经历M时间，缓冲区1将数据传送到工作区，然后经历C时间，CPU处理数据，工作区为空。此时工作区为空，缓冲区2满，缓冲区1为空，故对一个数据块的处理时间为M+C。</p><p>​</p><p>【注意：当在T时间时，缓冲区2冲满，此时若缓冲区1为空，那么由于只有一个I/O设备，缓冲区1虽然为空，但不能冲入数据】</p><p>【只有当CPU处理完缓冲区1中的数据，此时缓冲区1才可以冲入数据】</p><p>故，双缓冲对一个数据块的处理时间为max(T,M+C)。</p><p>​</p><p>n 循环缓冲：</p><p>【包含大小相等的缓冲区，每个缓冲区中有一个链接指针指向下一个缓冲区，最后一个缓冲区的指针指向第一个缓冲区】</p><p>【循环缓冲用于输入/输出时，还需要两个指针in和out】</p><p>【in指针指向可以输入数据的第一个空缓冲区】</p><p>【out指针指向可以输出数据的第一个满缓冲区】</p><p>n 缓冲池：</p><p>【由多个系统公用的缓冲区组成】</p><p>缓冲区按其使用状况分为三个队列：</p><p>空缓冲队列、输入队列、输出队列。</p><p>还应具有四种缓冲区：</p><p>用于收容输入数据的工作缓冲区、用于提取输出数据的工作缓冲区、用于提取输入数据的工作缓冲区、用于收容输出数据的工作缓冲区。</p><p>【当输入进程需要输入数据时，从空缓冲队列的队首取下一个缓冲区作为收容输入数据的工作缓冲区，将要输入的数据冲入，然后将其挂在输入队列的队尾】</p><p>【当计算进程需要数据时，从输入队列取下一个缓冲区作为提取输入数据的工作缓冲区，计算进程从中提取数据，提取完后将其挂在空缓冲队列的队尾】</p><p>【当计算进程需要输出数据时，从空缓冲队列队首取下一个缓冲区作为收容输出数据的工作缓冲区，将要输出的数据冲入，然后将其挂在输出队列的队尾】</p><p>【当要输出数据时，从输出队列取下一个缓冲区作为提取输出数据的工作缓冲区，将数据输出完后，将其挂在空缓冲队列的队尾】</p><p>​</p><h2 id="Q56：设备的分配与回收"><a href="#Q56：设备的分配与回收" class="headerlink" title="Q56：设备的分配与回收"></a>Q56：设备的分配与回收</h2><p>①设备分配的数据结构：</p><p>设备控制表DCT：</p><p>【一个设备控制表描述了一个设备，控制表中表项为设备的各个属性】</p><p>控制器控制表COCT：</p><p>【现代OS的I/O控制采用的都是通道方式，因此在COCT的某个表项中存放指向相应CHCT的指针】</p><p>通道控制表CHCT：</p><p>【由于通道可为多个设备控制器服务，CHCT中必有一个指针指向一个表，该表上的信息是CHCT提供服务的设备控制器】</p><p>系统设备表SDT：</p><p>【整个系统只有一张SDT，记录已连接到系统中的所有物理设备的情况，每个物理设备占一个表目】</p><p>​</p><p>②设备分配策略：</p><p>n 分配原则参考因素：</p><p>I/O设备的固有属性、I/O设备的分配算法、I/O设备分配的安全性、I/O设备的独立性。</p><p>​</p><p>n 设备分配原则：</p><p>既要充分发挥设备的使用效率，又要避免造成进程死锁，还要将用户程序和具体的物理设备分开。</p><p>n 设备分配方式：</p><p>1) 静态分配：</p><p>【主要用于对独占设备的分配】</p><p>【在用户作业开始执行之前，由系统一次性分配该作业所要求的的全部设备、控制器（如通道等）】</p><p>【一旦分配，这些设备、控制器就会一直被该作业占用，直至该作业被撤销】</p><p>【不会出现死锁，但设备的使用效率低】</p><p>2) 动态分配：</p><p>【在进程执行的过程中根据需求进行分配】</p><p>【当进程需要设备时，通过系统调用命令向系统提出设备请求，由系统按事先规定的策略为进程分配所需的设备、I/O控制器】</p><p>【一旦用完，立即释放】</p><p>【有利于提高设备的使用效率，但有可能会造成进程死锁】</p><p>​</p><p>n 设备分配算法：用于动态分配的算法：先请求先分配、优先级高者优先等。</p><p>【独占设备：即可采用静态分配，又可采用动态分配，但往往采用静态分配】</p><p>【共享设备：一般采用动态分配方式，但在每个I/O传输的单位时间内只能被一个进程所占有】</p><p>​</p><p>③设备分配的安全性：</p><p>【设备分配的安全性是指设备分配中应防止发生进程死锁】</p><p>1) 安全分配方式：</p><p>【每当发出I/O请求后便立即进入阻塞态】</p><p>【直至其I/O操作完成才被唤醒】</p><p>【优点：设备分配安全】</p><p>【缺点：CPU和I/O设备时串行工作的（对同一进程而言）】</p><p>2) 不安全的分配方式：</p><p>【进程发出I/O请求后继续执行，仅当进程所请求的设备已被占用时才进入阻塞态】</p><p>【优点：一个进程可以同时操作多个设备】</p><p>【缺点：可能会造成进程死锁】</p><p>④逻辑设备名到物理设备名的映射：</p><p>【为了实现设备独立性，在系统中设置一张逻辑设备表LUT，用于将逻辑设备名映射成物理设备名】</p><p>【LUT的表项包括：逻辑设备名、物理设备名、设备驱动程序的入口地址】</p><p>【当进程用逻辑设备名来请求分配设备时，系统为其分配相应的物理设备，并在LUT中增加一个表项】</p><p>【以后进程再利用逻辑设备名来请求I/O操作时，系统通过查找LUT来寻找相应的物理设备和设备驱动程序】</p><p>​</p><p>在系统中建立逻辑设备表的两种方式：</p><p>1) 在整个系统中建立一张LUT</p><p>【所有的设备分配情况都在该表中，因此不允许有相同的逻辑设备名，只适用于单用户系统】</p><p>2) 为每个用户建立一张LUT</p><p>【用户在登录时，系统为该用户建立一个进程，同时也为之建立一张LUT，并将其存放于该进程的PCB中】</p><h2 id="Q57：SPOOLING技术（假脱机技术）"><a href="#Q57：SPOOLING技术（假脱机技术）" class="headerlink" title="Q57：SPOOLING技术（假脱机技术）"></a>Q57：SPOOLING技术（假脱机技术）</h2><p>脱机输入/输出技术：</p><p>（为了缓和CPU的高速性和I/O设备的低速性之间的矛盾而引入）</p><p>该技术利用专门的外围控制机，将低速I/O设备上的数据传送到高速磁盘上，或者相反。</p><p>​</p><p>SPOOLing又称假脱机输入/输出技术，是OS中采用的一项将独占设备改造成共享设备的技术。</p><p>【实质上就是对I/O操作进行批处理】</p><p>【以空间换时间的技术】</p><p>【广泛的应用于多用户系统和局域网络】</p><p>【特点：提高了I/O的速度；将独占设备改造为共享设备；实现了虚拟设备功能】</p><p>输入井：</p><p>【位于磁盘】</p><p>【模拟脱机输入时的磁盘，用于收容I/O设备输入的数据】</p><p>输出井：</p><p>【位于磁盘】</p><p>【模拟脱机输出时的磁盘，用于收容用户进程输出的数据】</p><p>输入缓冲区：</p><p>【位于内存】</p><p>【暂存由输入设备送来的数据，以后在传送到传送井】</p><p>输出缓冲区：</p><p>【位于内存】</p><p>【暂存由输出井送来的数据，以后在传送到输出设备】</p><p>输入进程：</p><p>【模拟脱机输入时的外围控制机】</p><p>【将用户要求输入的数据从输入机通过输入缓冲区再送到输入井。当CPU需要输入数据时，直接将数据从输入井读入内存】</p><p>输出进程：</p><p>【模拟脱机输出时的外围控制机】</p><p>【将用户要求输出的数据从内存送到输出井，待输出设备空闲时，在将输出井中的数据经过输出缓冲区送到输出设备】</p><p>​</p><p>用户请求打印输出时，SPOOLing系统做：</p><p>①由输出进程在输出井中为之申请一个空闲磁盘块区，并将要打印的数据送入其中；</p><p>②输出进程再为用户申请一张空白的用户请求打印表，并将用户的打印要求填入其中，在将该表挂到请求打印队列上。</p><h1 id="CHAPTER-6"><a href="#CHAPTER-6" class="headerlink" title="CHAPTER 6"></a>CHAPTER 6</h1><h2 id="Q58：RAID技术"><a href="#Q58：RAID技术" class="headerlink" title="Q58：RAID技术"></a>Q58：RAID技术</h2><p>用于解决二级存储传送速度和内存、处理机传送速度的不匹配的技术。</p><p>【RAID将一列物理磁盘驱动视为一个逻辑驱动】</p><p>【数据是以条带的形式分布在各个磁盘驱动上】</p><p>【使用冗余磁盘保存奇偶校验信息，当一个磁盘失效时，数据具有可恢复性】</p><p>RAID技术实现高数据传送能力及实现高I/O请求率：</p><p>①对于需要高传送率的应用程序而言，应满足：</p><p>1) 高数据传送能力必须存在于主机存储器和单个磁盘驱动器的整个路径中，包括内部控制总线、主机系统I/O总线、I/O适配器、主机存储器总线。</p><p>2) 应用程序必须能够产生有效地使用磁盘阵列的I/请求。</p><p>若请求的是大量逻辑上连续的条带，则单个I/O请求可并行处理，提高了数据传送能力。</p><p>②在面向事务处理环境下，用户对响应时间的关注超过了对传送速率：</p><p>对于一个关于少量数据的单个I/O请求，I/O时间主要由寻道时间和延迟时间决定；</p><p>在面向事务处理环境中，每秒可能有上百条I/O请求。磁盘阵列通过平衡多个磁盘的I/O负载来提供较高的执行速率；</p><p>只有存在多个未完成的I/O请求，才能实现有效的负载平衡，即存在多个进行I/O请求的应用进程或存在一个能产生多个异步I/O请求的面向事务的应用程序；</p><p>条带大小也可影响I/O请求率，当条带相对较大时，一个I/O请求请求的数据可能在一个条带中，那么多个I/O请求请求的数据位于不同的条带上，即这些I/O请求可以并行处理，提高了I/O请求率；</p><p>冗余性：</p><p>发生磁盘故障时，通过访问奇偶校验磁盘，并从其余设备中重建数据。替换失效磁盘时，丢失的数据可恢复到新的驱动器上，并继续执行。</p><p>l RAID 0</p><p>【用户数据和系统数据分布在所有磁盘中】</p><p>相对于单一大磁盘而言，当两个不同的I/O请求请求数据而被挂起时，被请求的数据可能位于两个不同的磁盘上，因此这两个I/O请求可以并行发出，减少因I/O排队等待产生的平均时间。</p><p>【数据以条带的形式分布在所有可用磁盘上】</p><p>所有的用户数据和系统数据被视为存储在一个逻辑磁盘上，这个逻辑磁盘被划 分为多个条带(strip)；</p><p>一个条带可能是物理块、扇区或其他某种单元；</p><p>一组逻辑上连续的条带，若恰好一个条带映射到一个阵列成员磁盘上，那么称其为一条条带(stripe)；</p><p>当一个I/O请求请求的数据分布在不同的磁盘上时，这个I/O请求可以并行处理，减少了I/O的传送时间。</p><p>l RAID 1</p><p>【通过临时复制所有数据来实现冗余】</p><p>【一个逻辑条带映射到两个单独的磁盘上，阵列包含磁盘相同数据的镜像磁盘】</p><p>①对于读请求，可能由包含被请求数据的任意一个磁盘提供服务，而不管哪个磁盘具有最短的寻道时间和延迟时间。</p><p>②对于写请求，需要对两个相应的条带进行更新。写性能由两个写操作中具有最大寻道时间和延迟时间的决定。</p><p>【RAID 1 不存在“写性能损失(write penalty)”】</p><p>③磁盘失效的恢复实现简单。即当一个磁盘失效时，可以从另一个磁盘驱动中访问数据。</p><p>【在面向事务处理环境中，若有许多读请求，则RAID1的性能接近RAID0的两倍】</p><p>【在需要高传送率的应用程序中，若请求大多为读请求，则RAID1具有比RAID0更好的性能】</p><p>l RAID 2</p><p>【使用了并行访问技术】</p><p>【条带非常小，通常只有一个字节或一个字】</p><p>【在并行访问阵列时，所有磁盘成员都参与每个I/O请求的执行】</p><p>【包含多个奇偶检验磁盘，对每个数据磁盘的相应位计算一个错误校正码】</p><p>【通常错误校正码使用汉明码，能纠正一位错误检测双位错误】</p><p>【冗余磁盘的数量和数据磁盘数量的对数成正比】</p><p>①对于一次读，所有的磁盘都被访问到，被请求的数据及相关的错误校正码被送到阵列控制器。若有一个位错误，则阵列控制器可立即识别并改正这个错误，不会减少一次读的存取时间。</p><p>②对于写操作，必须访问所有的数据磁盘和奇偶检验磁盘。</p><p>【单个磁盘和磁盘驱动器的可靠性很高时，RAID2往往会出现矫枉过正的现象】</p><p>l RAID 3</p><p>【使用了并行访问技术】</p><p>【条带非常小，通常只有一个字节或一个字】</p><p>【在并行访问阵列时，所有磁盘成员都参与每个I/O请求的执行】</p><p>【只包含一个冗余磁盘，对所有数据磁盘的相应位异或计算一个奇偶检验码】</p><p>①缩减模式：磁盘失效时，在该模式下仍可以得到所有的数据。</p><p>对于读操作，丢失的数据仍可在运行中通过异或运算重新生成；</p><p>对于写操作，必须为以后的重新生成维持一致的奇偶校验；</p><p>②完全模式：要从缩减模式恢复到完全模式，则要替换失效磁盘，并在新磁盘中重新生成失效磁盘的所有内部数据。</p><p>【由于条带非常小，任何一个I/O请求都会从所有的数据磁盘并行传送，数据传送速率比较高；对于大量数据的传送，性能提升也很明显】</p><p>【由于一次只能执行一个I/O请求，因此性能在面向事务处理环境中并不可观】</p><p>l RAID 4</p><p>【使用了一种独立访问技术】</p><p>【数据条带相对较大】<br>【在独立访问阵列时，每个磁盘单独运转，则不同的I/O请求可以并行地得到满足】</p><p>【对于每个数据磁盘中相应的条带计算一个逐位奇偶校验，并将奇偶校验位保存在奇偶校验磁盘相应的条带中】</p><p>【存在“写损失”，当执行很小的I/O写请求时，每当写操作发生时，阵列驱动器不仅更新用户数据，还要更新相应的奇偶校验位】</p><p>【计算新的奇偶校验时，要先读取旧的用户数据条带和相应的奇偶校验条带，然后和新的用户数据计算得到新的奇偶校验并更新这两个条带，进行两次读和写】</p><p>【对于涉及到所有数据磁盘的大数据量I/O请求，奇偶校验信息即可通过新的数据计算得到，即奇偶校验的更新可以和数据一起并行地更新】</p><p>【不管哪种情况下，每次写操作都必须涉及奇偶校验磁盘，因此奇偶校验磁盘可能成为瓶颈】</p><p>l RAID 5</p><p>【相对于RAID4，奇偶校验条带依次循环地存放于各个磁盘中】</p><p>l RAID 6</p><p>【相对于RAID4，采用了两种不同的奇偶校验计算，并保存在不同磁盘的不同块中；一种是RAID4与RAID5使用的异或计算，另一种是独立数据校验算法】</p><p>【提供极高的数据可用性，在MTTR(平均故障时间)内，三个磁盘同时失效时数据才会丢失】</p><p>【RAID6会导致严重的写性能损失】</p><h2 id="Q59：Disk-Cache"><a href="#Q59：Disk-Cache" class="headerlink" title="Q59：Disk Cache"></a>Q59：Disk Cache</h2><p>【高速缓冲存储器(cache memory)通常指比内存小但比内存快的存储器，介于内存和处理器之间；利用了局部性原理来减少平均存储器存取时间】</p><p>【磁盘高速缓存是在内存中为磁盘扇区设置的一个缓冲区，包含磁盘某些扇区的副本】</p><p>【对一特定扇区进行I/O请求时，首先会进行检测，以确保该扇区是否在磁盘高速缓存中；若在，则该请求通过这个高速缓存来满足；否则，则把被请求的扇区从磁盘读到磁盘高速缓存中】</p><p>设计考虑因素一：</p><p>当一个I/O请求从磁盘高速缓存中得到满足时，磁盘高速缓存中的数据必须传送到发送请求的进程。</p><p>实现方法：</p><p>①在内存中将这一块数据从磁盘高速缓存传送到分配给该进程的存储空间</p><p>②使用一个共享内存，传送指向磁盘高速缓存中相应项的指针</p><p>设计考虑因素二：</p><p>当一个新扇区被读入到磁盘高速缓存时，必须换出一个已存在的块。</p><p>实现算法：</p><p>①最近最久使用页面置换算法LRU：未被访问的时间最长的块。</p><p>②最不常使用页面置换算法LFU：访问次数最少的块。<br>【可通过给每个块关联一个计数器实现】</p><p>【当一个块被读入时，其计数器置为1】</p><p>【每当访问到这一块时，计数器加1】</p><p>【需要置换时选择计数器最小的块】</p><p>存在问题：可能存在着一些块，整体上看很少出现对其的访问。但当其被访问时，由于局部性原理，会在一段时间内出现多次重复访问，导致计数器的值很高，而过了这段时间计数器的值难以解释。</p><p>​ 改进：</p><p>块在逻辑上被组织成一个栈，栈顶的一部分作为新区。出现一次高速缓存命中时，被访问的块移到栈顶。若该块已在新区，则计数器值不变，否则计数器值加1。</p><p>若发生一次未命中时，访问计数器值最小，并且不再新区中的块被选择出；若有多个则选择近期最少使用的块。</p><p>存在问题：</p><p>出现一次磁盘高速缓存未命中，一个新块被读取到新区，计数器置为1；只要该块留在新区，其计数器值保持为1；最终该块的年龄超过新区，但其计数器仍为1；若该块未被很快地再次访问，则其很有可能被置换。</p><p>​</p><p>进一步改进：</p><p>把栈划分为新区、中间区和老区。位于新区的块，其访问计数器不会增加；只有老区中的块才符合置换条件。</p><p>假设有足够大的中间区，这就使得相对比较频繁地被访问到的块，在变为符合置换条件块之前有机会增加自己的访问计数器值。</p><p>​</p><p>置换发生的时间：</p><p>按需发生：只有当需要用到存储槽时才置换扇区。</p><p>预先发生：一次可以释放多个存储槽。【与写回扇区的要求相关】</p><p>【若一扇区读入到磁盘高速缓存中仅用于读，则置换时不需写回磁盘；若其已被修改，那么在换出前要写回磁盘。此时成簇地写回来降低寻道时间】</p><p>​</p><p>​</p><p>​</p><p>​</p><p>​</p><p>​</p><p>​</p><p>​</p><p>​</p><p>​</p><p>​</p><p>​</p><p>​</p><p>​</p></div><div class="reward-container"><div></div><button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'>打赏</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="/images/wechatpay.png" alt="blue_dawn 微信支付"><p>微信支付</p></div></div></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------本文结束<i class="fa fa-heart"></i>感谢您的阅读-------------</div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>blue_dawn</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="http://www.bluedawn1.space/2021/11/24/OS_NOTES/" title="OS_NOTES.md">http://www.bluedawn1.space/2021/11/24/OS_NOTES/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E8%80%83%E7%A0%94/" rel="tag"><i class="fa fa-tag"></i> 考研</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"><i class="fa fa-tag"></i> 操作系统</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2021/03/14/c_notes/" rel="prev" title="C_NOTES_1.md"><i class="fa fa-chevron-left"></i> C_NOTES_1.md</a></div><div class="post-nav-item"></div></div></footer></article></div></div><script>window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#CHAPTER-1"><span class="nav-number">1.</span> <span class="nav-text">CHAPTER 1</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Q1：What-is-OS"><span class="nav-number">1.1.</span> <span class="nav-text">Q1：What is OS?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q2：OS的基本特征"><span class="nav-number">1.2.</span> <span class="nav-text">Q2：OS的基本特征</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q3：OS的目标及功能"><span class="nav-number">1.3.</span> <span class="nav-text">Q3：OS的目标及功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q4：OS的发展"><span class="nav-number">1.4.</span> <span class="nav-text">Q4：OS的发展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q5：内核主要包括"><span class="nav-number">1.5.</span> <span class="nav-text">Q5：内核主要包括</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q6：中断-amp-异常"><span class="nav-number">1.6.</span> <span class="nav-text">Q6：中断&amp;异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q7：OS的体系结构"><span class="nav-number">1.7.</span> <span class="nav-text">Q7：OS的体系结构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CHAPTER-2"><span class="nav-number">2.</span> <span class="nav-text">CHAPTER 2</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Q8：为什么引入进程？"><span class="nav-number">2.1.</span> <span class="nav-text">Q8：为什么引入进程？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q9：进程的概念"><span class="nav-number">2.2.</span> <span class="nav-text">Q9：进程的概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q10：进程的特征"><span class="nav-number">2.3.</span> <span class="nav-text">Q10：进程的特征</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q11：进程的状态及状态转换"><span class="nav-number">2.4.</span> <span class="nav-text">Q11：进程的状态及状态转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q12：进程的控制"><span class="nav-number">2.5.</span> <span class="nav-text">Q12：进程的控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q13：进程的组织"><span class="nav-number">2.6.</span> <span class="nav-text">Q13：进程的组织</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q14：进程的通信"><span class="nav-number">2.7.</span> <span class="nav-text">Q14：进程的通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q15：线程及多线程模型"><span class="nav-number">2.8.</span> <span class="nav-text">Q15：线程及多线程模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q16：调度层次"><span class="nav-number">2.9.</span> <span class="nav-text">Q16：调度层次</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q17：调度的基本准则"><span class="nav-number">2.10.</span> <span class="nav-text">Q17：调度的基本准则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q18：典型的调度算法"><span class="nav-number">2.11.</span> <span class="nav-text">Q18：典型的调度算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q19：进程同步"><span class="nav-number">2.12.</span> <span class="nav-text">Q19：进程同步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q20：实现临界区互斥的基本方法"><span class="nav-number">2.13.</span> <span class="nav-text">Q20：实现临界区互斥的基本方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q21：经典同步问题"><span class="nav-number">2.14.</span> <span class="nav-text">Q21：经典同步问题</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#"><span class="nav-number">2.14.0.0.0.1.</span> <span class="nav-text">#</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#-1"><span class="nav-number">2.14.0.0.0.2.</span> <span class="nav-text">#</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#-2"><span class="nav-number">2.14.0.0.0.3.</span> <span class="nav-text">#</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#0"><span class="nav-number">2.14.0.0.0.4.</span> <span class="nav-text">## 0</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#-3"><span class="nav-number">2.14.0.0.0.5.</span> <span class="nav-text">#</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#0-1"><span class="nav-number">2.14.0.0.0.6.</span> <span class="nav-text">## 0</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#-4"><span class="nav-number">2.14.0.0.0.7.</span> <span class="nav-text">#</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#1"><span class="nav-number">2.14.0.0.0.8.</span> <span class="nav-text">## 1</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#-5"><span class="nav-number">2.14.0.0.0.9.</span> <span class="nav-text">#</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#0-2"><span class="nav-number">2.14.0.0.0.10.</span> <span class="nav-text">## 0</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#-6"><span class="nav-number">2.14.0.0.0.11.</span> <span class="nav-text">#</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#1-1"><span class="nav-number">2.14.0.0.0.12.</span> <span class="nav-text">## 1</span></a></li></ol></li></ol></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#Q22：死锁"><span class="nav-number">2.15.</span> <span class="nav-text">Q22：死锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q23：作业-amp-进程"><span class="nav-number">2.16.</span> <span class="nav-text">Q23：作业 &amp; 进程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CHAPTER-3"><span class="nav-number">3.</span> <span class="nav-text">CHAPTER 3</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Q24：内存管理概念及功能"><span class="nav-number">3.1.</span> <span class="nav-text">Q24：内存管理概念及功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q25：程序的链接和装入"><span class="nav-number">3.2.</span> <span class="nav-text">Q25：程序的链接和装入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q26：逻辑地址空间-amp-物理地址空间"><span class="nav-number">3.3.</span> <span class="nav-text">Q26：逻辑地址空间&amp;物理地址空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q27：内存保护"><span class="nav-number">3.4.</span> <span class="nav-text">Q27：内存保护</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q28：覆盖-amp-交换"><span class="nav-number">3.5.</span> <span class="nav-text">Q28：覆盖&amp;交换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q29：连续分配管理方式"><span class="nav-number">3.6.</span> <span class="nav-text">Q29：连续分配管理方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q30：非连续分配管理方式"><span class="nav-number">3.7.</span> <span class="nav-text">Q30：非连续分配管理方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q31：虚拟存储管理"><span class="nav-number">3.8.</span> <span class="nav-text">Q31：虚拟存储管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q32：请求分页存储管理"><span class="nav-number">3.9.</span> <span class="nav-text">Q32：请求分页存储管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q33：覆盖、交换和虚拟存储技术区别"><span class="nav-number">3.10.</span> <span class="nav-text">Q33：覆盖、交换和虚拟存储技术区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CHAPTER-4"><span class="nav-number">4.</span> <span class="nav-text">CHAPTER 4</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Q34：文件及文件系统概念"><span class="nav-number">4.1.</span> <span class="nav-text">Q34：文件及文件系统概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q35：文件的逻辑结构"><span class="nav-number">4.2.</span> <span class="nav-text">Q35：文件的逻辑结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q36：目录及目录结构"><span class="nav-number">4.3.</span> <span class="nav-text">Q36：目录及目录结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q37：文件共享"><span class="nav-number">4.4.</span> <span class="nav-text">Q37：文件共享</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q38：文件保护"><span class="nav-number">4.5.</span> <span class="nav-text">Q38：文件保护</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q39：文件系统的层次结构"><span class="nav-number">4.6.</span> <span class="nav-text">Q39：文件系统的层次结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q40：目录实现"><span class="nav-number">4.7.</span> <span class="nav-text">Q40：目录实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q41：文件实现——分配方式"><span class="nav-number">4.8.</span> <span class="nav-text">Q41：文件实现——分配方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q42：文件实现——存储空间管理："><span class="nav-number">4.9.</span> <span class="nav-text">Q42：文件实现——存储空间管理：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q43：磁盘结构"><span class="nav-number">4.10.</span> <span class="nav-text">Q43：磁盘结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q44：一次磁盘读-写的时间"><span class="nav-number">4.11.</span> <span class="nav-text">Q44：一次磁盘读&#x2F;写的时间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q45：磁盘调度算法"><span class="nav-number">4.12.</span> <span class="nav-text">Q45：磁盘调度算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q46：磁盘管理"><span class="nav-number">4.13.</span> <span class="nav-text">Q46：磁盘管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q47：内存结构"><span class="nav-number">4.14.</span> <span class="nav-text">Q47：内存结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q48：文件系统实现概述"><span class="nav-number">4.15.</span> <span class="nav-text">Q48：文件系统实现概述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CHAPTER-5"><span class="nav-number">5.</span> <span class="nav-text">CHAPTER 5</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Q49：I-O设备分类"><span class="nav-number">5.1.</span> <span class="nav-text">Q49：I&#x2F;O设备分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q50：I-O控制方式"><span class="nav-number">5.2.</span> <span class="nav-text">Q50：I&#x2F;O控制方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q51：I-O系统层次结构"><span class="nav-number">5.3.</span> <span class="nav-text">Q51：I&#x2F;O系统层次结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q52：设备控制器"><span class="nav-number">5.4.</span> <span class="nav-text">Q52：设备控制器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q53：I-O核心子系统"><span class="nav-number">5.5.</span> <span class="nav-text">Q53：I&#x2F;O核心子系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q54：I-O调度"><span class="nav-number">5.6.</span> <span class="nav-text">Q54：I&#x2F;O调度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q55：高速缓存及缓冲区："><span class="nav-number">5.7.</span> <span class="nav-text">Q55：高速缓存及缓冲区：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q56：设备的分配与回收"><span class="nav-number">5.8.</span> <span class="nav-text">Q56：设备的分配与回收</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q57：SPOOLING技术（假脱机技术）"><span class="nav-number">5.9.</span> <span class="nav-text">Q57：SPOOLING技术（假脱机技术）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CHAPTER-6"><span class="nav-number">6.</span> <span class="nav-text">CHAPTER 6</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Q58：RAID技术"><span class="nav-number">6.1.</span> <span class="nav-text">Q58：RAID技术</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q59：Disk-Cache"><span class="nav-number">6.2.</span> <span class="nav-text">Q59：Disk Cache</span></a></li></ol></li></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="blue_dawn" src="/images/avatar.gif"><p class="site-author-name" itemprop="name">blue_dawn</p><div class="site-description" itemprop="description">清风徐来, 水波不兴</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">36</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">22</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">17</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/bluedawn520" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;bluedawn520" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:2515294061@qq.com" title="E-Mail → mailto:2515294061@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a> </span><span class="links-of-author-item"><a href="/2515294061" title="QQ → 2515294061"><i class="fa fa-fw fa-qq"></i>QQ</a></span></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> 推荐阅读</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="http://www.alloyteam.com/nav/" title="http:&#x2F;&#x2F;www.alloyteam.com&#x2F;nav&#x2F;" rel="noopener" target="_blank">Web前端导航</a></li><li class="links-of-blogroll-item"><a href="http://www.chuangzaoshi.com/code" title="http:&#x2F;&#x2F;www.chuangzaoshi.com&#x2F;code" rel="noopener" target="_blank">创造狮导航</a></li><li class="links-of-blogroll-item"><a href="http://www.36zhen.com/t?id=3448" title="http:&#x2F;&#x2F;www.36zhen.com&#x2F;t?id&#x3D;3448" rel="noopener" target="_blank">前端书籍资料</a></li><li class="links-of-blogroll-item"><a href="http://e.xitu.io/" title="http:&#x2F;&#x2F;e.xitu.io&#x2F;" rel="noopener" target="_blank">掘金酱</a></li><li class="links-of-blogroll-item"><a href="https://www.v2ex.com/" title="https:&#x2F;&#x2F;www.v2ex.com&#x2F;" rel="noopener" target="_blank">V2EX</a></li><li class="links-of-blogroll-item"><a href="https://www.v2ex.com/" title="https:&#x2F;&#x2F;www.v2ex.com&#x2F;" rel="noopener" target="_blank">印记中文</a></li></ul></div></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2020 – <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">blue_dawn</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span title="站点总字数">180k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">2:43</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/jquery/2.1.3/jquery.min.js"></script><script src="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.min.js"></script><script src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script defer src="/lib/three/three.min.js"></script><script defer src="/lib/three/three-waves.min.js"></script><script defer src="/lib/three/canvas_sphere.min.js"></script><script src="/js/local-search.js"></script><script>if (document.querySelectorAll('div.pdf').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/pdfobject@2/pdfobject.min.js', () => {
    document.querySelectorAll('div.pdf').forEach(element => {
      PDFObject.embed(element.getAttribute('target'), element, {
        pdfOpenParams: {
          navpanes : 0,
          toolbar  : 0,
          statusbar: 0,
          pagemode : 'thumbs',
          view     : 'FitH'
        },
        PDFJS_URL: '/lib/pdf/web/viewer.html',
        height: element.getAttribute('height') || '500px'
      });
    });
  }, window.PDFObject);
}</script><script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script><link rel="stylesheet" href="/dist/APlayer.min.css"><div id="aplayer"></div><script type="text/javascript" src="/dist/APlayer.min.js"></script><script type="text/javascript" src="/dist/music.js"></script><canvas class="fireworks" style="position:fixed;left:0;top:0;z-index:1;pointer-events:none"></canvas><script src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script><script src="/js/cursor/explosion.min.js"></script><script type="text/javascript" src="/js/src/crash_cheat.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,model:{scale:1,hHeadPos:.5,vHeadPos:.618,jsonPath:"/live2dw/assets/wanko.model.json"},display:{superSample:2,width:150,height:300,position:"right",hOffset:0,vOffset:-20},mobile:{show:!0,scale:.5},react:{opacityDefault:.7,opacityOnHover:.2}})</script></body></html>