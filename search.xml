<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>local_search_heuristic_Select</title>
    <url>/2020/03/13/local-search-heuristic-Select/</url>
    <content><![CDATA[<!-- build time:Thu Mar 26 2020 23:48:51 GMT+0800 (GMT+08:00) --><p>&emsp;&emsp;GSAT、GSAT+walk、WALKSAT、WALKSAT/SKC、WalkSAT/TABU、WalkSAT/Novelty、WalkSAT/R Novelty、WalkSAT/Novelty+、WalkSAT/Novelty++;<br><a id="more"></a></p><p><strong>GSAT :</strong><br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">begin</span><br><span class="line">    for i &#x3D; 1 : MAX_TRIES</span><br><span class="line">        T &#x3D;  random generate a true assignment</span><br><span class="line">        for j &#x3D; 1 : MAX_FLIPS</span><br><span class="line">            if T satisfied  then return T</span><br><span class="line">            p &#x3D; 翻转之后使满足子句的个数增加最多的那个变量,若有多个则随机从中选一个;</span><br><span class="line">            T &#x3D; the assignment after flipping p;</span><br><span class="line">        end for</span><br><span class="line">    end for</span><br><span class="line">    return &quot;no find solution&quot;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p></p><p><strong>GSAT + walk :</strong><br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">begin</span><br><span class="line">    for i &#x3D; 1 : MAX_TRIES</span><br><span class="line">        T &#x3D;  random generate a true assignment</span><br><span class="line">        for j &#x3D; 1 : MAX_FLIPS</span><br><span class="line">            if T satisfied  then return T</span><br><span class="line">            r randomly generated from 0 to 1;</span><br><span class="line">            if r&lt;p </span><br><span class="line">                在不满足子句中随机选择一个变元并翻转;</span><br><span class="line">                &#x2F;&#x2F;(random walk)</span><br><span class="line">            else</span><br><span class="line">                p &#x3D; 翻转之后使满足子句的个数增加最多的那个变量,若有多个则随机从中选一个;</span><br><span class="line">                T &#x3D; the assignment after flipping p;</span><br><span class="line">                &#x2F;&#x2F;(GSAT)</span><br><span class="line">        end for</span><br><span class="line">    end for</span><br><span class="line">    return &quot;no find solution&quot;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p></p><p><strong>WalkSAT :</strong><br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">begin</span><br><span class="line">    for i &#x3D; 1 : MAX_TRIES</span><br><span class="line">         T &#x3D;  random generate a true assignment</span><br><span class="line">        for j &#x3D; 1 : MAX_FLIPS</span><br><span class="line">            if T satisfied  then return T</span><br><span class="line">            随机的选择一个不满足子句c;</span><br><span class="line">            r randomly generated from 0 to 1;</span><br><span class="line">            if r&lt;p </span><br><span class="line">                在不满足子句c中随机选择一个变元并翻转;</span><br><span class="line">            else</span><br><span class="line">                记break-count为子句c的变元翻转后由满足变为不满足的子句数;</span><br><span class="line">                选择break-count最小的变元v;</span><br><span class="line">                T &#x3D; the assignment after flipping v;</span><br><span class="line">        end for</span><br><span class="line">    end for</span><br><span class="line">    return &quot;no find solution&quot;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p></p><p><strong>WalkSAT/ SKC :</strong><br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">begin</span><br><span class="line">    for i &#x3D; 1 : MAX_TRIES</span><br><span class="line">         T &#x3D;  random generate a true assignment</span><br><span class="line">        for j &#x3D; 1 : MAX_FLIPS</span><br><span class="line">            if T satisfied  then return T</span><br><span class="line">            随机的选择一个不满足子句c;</span><br><span class="line">            记break-count为子句c的变元翻转后由满足变为不满足的子句数;</span><br><span class="line">            随机从c中选择一个变元v;</span><br><span class="line">            r randomly generated from 0 to 1;</span><br><span class="line">            if r&lt;p  </span><br><span class="line">                if break-count &#x3D;&#x3D; 0</span><br><span class="line">                    flip v;</span><br><span class="line">                else</span><br><span class="line">                    在不满足子句c中随机选择一个变元并翻转;</span><br><span class="line">            else</span><br><span class="line">                </span><br><span class="line">                选择break-count最小的变元v;</span><br><span class="line">                T &#x3D; the assignment after flipping v;</span><br><span class="line">        end for</span><br><span class="line">    end for</span><br><span class="line">    return &quot;no find solution&quot;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p></p><p><strong>WalkSAT/TABU :</strong><br>&emsp;&emsp;策略是选择一个变量,以最大程度地减少不满意子句的数量。但是,在每个步骤中,请拒绝翻转过去t步中已翻转的任何变量；如果所选不满意子句中的所有变量都是禁忌,请选择其他不满意子句。如果所有不满足的子句中的所有变量都是禁忌,则禁忌列表将被忽略。禁忌表长度t是噪声参数。</p><p><strong>WalkSAT/Novelty :</strong><br>&emsp;&emsp;这种策略按照不满意子句的总数对变量进行排序,就像G一样,但是为了最近最少翻转的变量而打破平局。考虑这种情况下的最佳和次佳变量。如果最好的变量不是子句中最近翻转的变量,请选择它。否则,以概率p选择次优变量,以概率1 p选择最佳变量。</p><p><strong>WalkSAT/R Novelty :</strong><br>&emsp;&emsp;与NOVELTY相同,但最佳变量是最近翻转的变量除外。在这种情况下,令n为最佳变量次最佳变量之间的目标函数之差。 然后有四种情况:</p><pre><code> * 当p &lt; 0.5 且 n&gt; 1时,选择最佳。
 * 当p &lt; 0.5且n = 1时,则概率为2p选择第二好的,否则选择最好的。
 * 当p &gt;= 0.5且n = 1时,选择第二好的。
 * 当p &gt;= 0.5且n&gt; 1时,则以2（p - 0.5）的概率选择第二好的,否则选择最好的。
</code></pre><p>&emsp;&emsp;R NOVELTY几乎是确定性的。为了打破搜索中的确定性循环，每翻转100次，策略将从子句中选择一个随机变量。尽管几乎没有涉及不确定性的翻转，但正如我们将看到的，R NOVELTY的性能仍然对参数p的设置非常敏感。</p><p><strong>WalkSAT/Novelty+ :</strong><br>&emsp;&emsp;With probability wp, randomly pick a variable from c (random walk), with probability 1-wp, do as Novelty.</p><p><strong>WalkSAT/Novelty++ :</strong><br>&emsp;&emsp;With probability dp (diversification probability), pick the least recently flipped variable in c (diversification), with probability 1-dp, do as Novelty.</p><hr><p>/<em>gsat</em>/</p><p>评估适应度，建立最好变元(最大的适应度值)的候选列表；从中随机选择一个变量进行翻转。</p><p>/<em>gwsat</em>/</p><p>以概率wp随机地从所有的不满足子句中选择一个变元翻转；否则，建立最好变元(最小的break-count - make-count)<br>的候选列表，从中随机选择一个变量进行翻转。</p><p>/<em>gsat-tabu</em>/<br>(确定禁忌表的长度；从初始开始，将每个翻转的变元存入禁忌表中，若禁忌表已满，则删除禁忌表中最前面的元素，<br>然后将最新翻转的变元添加进去。添加一次，禁忌表中的每个变元的值增1；在添加之前，判断禁忌表是否已满，若已满<br>则将禁忌表头元素删除，然后添加新变元，禁忌表中的每个变元的值增1。可以将禁忌表用队列数据结构表示，“FIFO”特性。<br>禁忌表中每个变元的值用vector模板表示)</p><p>对不是禁忌表中的所有变元，建立最好变元(最大的适应度值)的候选列表，从中随机选择一个变量进行翻转。</p><p>/<em>hsat</em>/<br>评估适应度，建立最好变元(若有多个变元，则选择翻转older的变元)的候选列表；从中随机选择一个变量进行翻转。</p><p>/<em>hwsat</em>/<br>以概率wp随机选择一个不满足子句，从中随机选择一个变元；否则，执行hsat操作。</p><p>/<em>walksat</em>/<br>随机地选择一个不满足子句；翻转这个子句的各个变元得到break-count。建立候选解列表。若所得最好的大于0，则以wp概率随机选择变元，否则从候选解中随机选择一个变量翻转 。</p><p>/<em>walksat-tabu</em>/<br>随机选择一个不满足子句；翻转这个子句的各个变元得到break-count。若break-count值为0则不放入禁忌表，建立候选解列表。若候选列表为空则执行一个null-flip。从候选解中随机选择一个变量翻转 。</p><p>/<em>novelty</em>/<br>随机地选择一个不满足子句；对所有该子句中的变元，通过增加的break-count-make-cout评分，建立最佳列表和次最佳列表；若最佳变元不是最近翻转列表中的元素，则翻转它；否则，以概率p选择次最佳变元。</p><p>/<em>novelty+</em>/<br>以概率wp随机地选择一个变元翻转；否则，以1-wp执行novelty操作。</p><p>/<em>novelty++</em>/<br>随机地选择一个不满足子句，以概率dp选择该子句中最近翻转的变元；否则，以1-wp执行novelty操作。</p><p>/<em>adaptnovelty</em>/<br>若一段时间未有所提高，则提高噪声；否则，减小噪声（wp:= wp - wp*phi/2）。</p><hr><div id="“refer-anchor”"></div><p>1 On_the_Run-time_Behaviour_of_Stochastic_Local_Search_Algorithms_for_SAT</p><p>2 Diversification_and_Determinism_in_Local_Search_for_Satisfiability</p><p>3 [‘UBCSAT’,<a href="http://ubcsat.dtompkins.com/home" target="_blank" rel="noopener">http://ubcsat.dtompkins.com/home</a>]</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>毕设</category>
        <category>文献阅读</category>
        <category>算法</category>
        <category>GA</category>
      </categories>
      <tags>
        <tag>毕设</tag>
        <tag>文献阅读</tag>
        <tag>笔记</tag>
        <tag>GA</tag>
      </tags>
  </entry>
  <entry>
    <title>An_Adaptive_Noise_Mechanism_for_WalkSAT</title>
    <url>/2020/03/13/An-Adaptive-Noise-Mechanism-for-WalkSAT/</url>
    <content><![CDATA[<!-- build time:Thu Mar 26 2020 23:48:51 GMT+0800 (GMT+08:00) --><p>&emsp;&emsp;WalkSAT算法基于迭代搜索过程,该过程在每个步骤随机选择给定SAT实例的当前不满意子句(均匀概率分布),选择出现子句中的变量并将其翻转,即将其真值从true更改为false,反之亦然。<a id="more"></a>在不满意的子句中使用不同的方法进行翻转选择,从而产生了各种WlkSAT算法(McAllester,Selman和Kautz,1997;Hoos,1999;Hoos和Stutzle,2000a)。所有这些都使用一个称为噪声参数的参数来控制变量选择过程中的贪婪程度,即可能选择的变量的程度,当翻转该变量时,不满足子句数量的最大减少。</p><h3 id="WalkSAT-with-Dynamic-Noise"><a href="#WalkSAT-with-Dynamic-Noise" class="headerlink" title="WalkSAT with Dynamic Noise"></a>WalkSAT with Dynamic Noise</h3><p>&emsp;&emsp;基于噪声设置对搜索过程的影响,似乎最佳噪声设置是在算法通过遵循局部梯度贪婪地找到解决方案的能力与从局部极小值以及吸收搜索对象的其他空间区域逃逸的能力取得良好平衡的设置。执行非贪婪搜索步骤所需要的标准静态噪声机制，以避开搜索将以恒定的概率停滞的情况。</p><p>&emsp;&emsp;这通常会导致目标函数值快速提高一系列，然后停滞（除非找到给定问题实例的解决方案）。在这种情况下，噪声值会增加。如果该增加不足以摆脱停滞情况，即，如果在一定数量的步骤内没有导致目标函数值的改善，则噪声值会进一步增加。甚至，噪声值应足够高，以使搜索过程克服停滞现象，此时可以逐渐降低噪声，直到检测到下一个停滞状况或找到给定问题实例的解决方案为止。</p><p>&emsp;&emsp;滞后检测机制:在经过a·m(m是给定问题实例的子句数)个搜索步骤后,观察到目标函数的是否改善。噪声增大机制:wp:= wp + (1 - wp)b;噪声减小机制:wp:= wp - wp·2b;</p><p>&emsp;&emsp;噪声设置的增加和减少之间的不对称性是由于以下事实引起的:检测搜索停滞在计算上比检测搜索进度更加昂贵,并且通过较早的观察发现,即从上方而不是从下方近似最佳噪声水平是有利的。 在增大或减小了噪声设置之后,当前的目标函数值将被存储并成为测量改进并因此用于检测搜索停滞的基础。 因此,噪声水平的增加之间总是存在一个相位持续时间，,在不进一步增加噪声的情况下,监视轨迹的搜索进度。 在连续降低噪声级之间不会存在此类延迟。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>毕设</category>
        <category>文献阅读</category>
        <category>算法</category>
        <category>GA</category>
      </categories>
      <tags>
        <tag>毕设</tag>
        <tag>文献阅读</tag>
        <tag>笔记</tag>
        <tag>GA</tag>
      </tags>
  </entry>
  <entry>
    <title>Evidence_for_Invariants_in_Local_Search</title>
    <url>/2020/03/13/Evidence-for-Invariants-in-Local-Search/</url>
    <content><![CDATA[<!-- build time:Thu Mar 26 2020 23:48:51 GMT+0800 (GMT+08:00) --><p>&emsp;&emsp;众所周知,随机局部搜索程序的性能取决于其噪声参数的设置,并且最佳设置随问题的分布而变化。介绍了两种随机本地搜索的统计方法,可以使人们更快地找到最优噪声设置。这种属性与随机本地搜索策略的详细信息无关,并且似乎相对于与问题域的结构也无关。<br><a id="more"></a></p><p>&emsp;&emsp;”noise”这种参数通过非最优移动决定了跳出局部最小的可能性。退火算法中,是temperature;在禁忌搜索中,是tenure(禁忌时间的长度);在GSAT中,是随机游走参数;在WSAT中,是noise。由于最佳噪声参数设置既取决于问题实例的特征,也取决于搜索程序的精良的细节,这些细节可能会受到其他参数的影响;而反复试验来找到给定问题分布的最佳参数设置需要大量的精力。因此,非常希望找到设置最优噪声的方法,使得其不会随特定的算法或特定的实例而改变。</p><p>&emsp;&emsp;首先,对于给定问题的类别,在最佳参数设置下,由目标函数值(不满足子句的个数)测得的“噪声水平”在整个解决方案策略中近似恒定。称其为”noise level invariant”。其次,发现了一个更通用的原理,该原理表明,最佳参数设置是一种将目标函数均值和其方差之比近似最小化的设置。</p><p>&emsp;&emsp;通过分析该策略的几次短期运行的统计特性,可以快速准确地估算出给定策略的噪声参数的最佳值。</p><h2 id="1-Local-Search-Procedures-for-Boolean-Satisfiability"><a href="#1-Local-Search-Procedures-for-Boolean-Satisfiability" class="headerlink" title="1. Local Search Procedures for Boolean Satisfiability"></a>1. Local Search Procedures for Boolean Satisfiability</h2><p>&emsp;&emsp;“随机3SAT”公式中的子句是通过随机地均匀地选择三个不同的文字,然后以相等的概率否定每个来产生的。 Mitchell et al.(1992)表明,当这种公式中的子句与变量之比约为4.3时,随机3SAT问题在计算上比较困难。</p><p>&emsp;&emsp;本地搜索SAT试图最小化的目标函数(不满意子句的总数)。搜索策略的特征使它做出的动作不是最佳的,即在某种意义上动作会增加或无法降低目标函数,即使在当前状态的本地附近也可以使用这种改进的动作—称为噪音。如前所述,噪声允许局部搜索过程脱离局部最优。</p><p>&emsp;&emsp;考虑了从子句中选择变量的六种启发式方法:</p><ul><li><p>G:以p的概率选择任何变量,否则选择一个使未满足子句总数最小的变量。p为噪声参数,取值范围为0〜1。</p></li><li><p>B:以概率p选择任何变量,否则选择一个变量,该变量将在当前状态下为true的子句的数量最小化,但是如果进行翻转,该变量将为false。在WSAT的原始描述中,这被称为“minimizing breaks”。同样,p是噪声参数。</p></li><li><p>SKC:和前一个一样,但是如果存在一个折中值为0的值,则不要随意移动。请注意,当break-value为0时,则保证移动也可以改善目标函数。这是Selman,Kautz和Cohen（1994）提出的原始WSAT策略。</p></li><li><p>TABU:策略是选择一个变量,以最大程度地减少不满意子句的数量。但是,在每个步骤中,请拒绝翻转过去t步中已翻转的任何变量；如果所选不满意子句中的所有变量都是禁忌,请选择其他不满意子句。如果所有不满足的子句中的所有变量都是禁忌,则禁忌列表将被忽略。禁忌表长度t是噪声参数。</p></li><li><p>NOVELTY:这种策略按照不满意子句的总数对变量进行排序,就像G一样,但是为了最近最少翻转的变量而打破平局。考虑这种情况下的最佳和次佳变量。如果最好的变量不是子句中最近翻转的变量,请选择它。否则,以概率p选择次优变量,以概率1 p选择最佳变量。</p></li><li><p>R NOVELTY:与NOVELTY相同,但最佳变量是最近翻转的变量除外。在这种情况下,令n为最佳变量次最佳变量之间的目标函数之差。 然后有四种情况:</p><ul><li>当p &lt; 0.5 且 n&gt; 1时,选择最佳。</li><li>当p &lt; 0.5且n = 1时,则概率为2p选择第二好的,否则选择最好的。</li><li>当p &gt;= 0.5且n = 1时,选择第二好的。</li><li>当p &gt;= 0.5且n&gt; 1时,则以2（p - 0.5）的概率选择第二好的,否则选择最好的。</li></ul></li></ul><p>&emsp;&emsp;NOVELTY的直觉是要避免反复反复翻转相同的变量。R NOVELTY背后的直觉是目标函数应影响最佳变量和次佳变量之间的选择————目标函数的较大差异有利于最佳变量。请注意,R NOVELTY几乎是确定性的。为了打破搜索中的确定性循环，每翻转100次，策略将从子句中选择一个随机变量。尽管几乎没有涉及不确定性的翻转，但正如我们将看到的，R NOVELTY的性能仍然对参数p的设置非常敏感。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>毕设</category>
        <category>文献阅读</category>
        <category>算法</category>
        <category>GA</category>
      </categories>
      <tags>
        <tag>毕设</tag>
        <tag>文献阅读</tag>
        <tag>笔记</tag>
        <tag>GA</tag>
      </tags>
  </entry>
  <entry>
    <title>一个求解结构SAT问题的高效局部搜索算法</title>
    <url>/2020/03/11/%E4%B8%80%E4%B8%AA%E6%B1%82%E8%A7%A3%E7%BB%93%E6%9E%84SAT%E9%97%AE%E9%A2%98%E7%9A%84%E9%AB%98%E6%95%88%E5%B1%80%E9%83%A8%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<!-- build time:Thu Mar 26 2020 23:48:51 GMT+0800 (GMT+08:00) --><p>&emsp;&emsp;对GSAT+walk算法进行了改进,除去了其中的GSAT部分的“平移”;其次,对没一个子句进行赋权,并在搜索过程中动态调整子句的权。<br><a id="more"></a></p><h2 id="1-一般的GSAT算法"><a href="#1-一般的GSAT算法" class="headerlink" title="1. 一般的GSAT算法"></a>1. 一般的GSAT算法</h2><h3 id="1-1-GSAT伪代码"><a href="#1-1-GSAT伪代码" class="headerlink" title="1.1 GSAT伪代码:"></a>1.1 GSAT伪代码:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">begin</span><br><span class="line">    for i &#x3D; 1 : MAX_TRIES</span><br><span class="line">        T &#x3D;  random generate a true assignment</span><br><span class="line">        for j &#x3D; 1 : MAX_FLIPS</span><br><span class="line">            if T satisfied  then return T</span><br><span class="line">            p &#x3D; 翻转之后使满足子句的个数增加最多的那个变量,若有多个则随机从中选一个;</span><br><span class="line">            T &#x3D; the assignment after flipping p;</span><br><span class="line">        end for</span><br><span class="line">    end for</span><br><span class="line">    return &quot;no find solution&quot;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="1-2-GSAT-walk的局部搜索算法"><a href="#1-2-GSAT-walk的局部搜索算法" class="headerlink" title="1.2 GSAT + walk的局部搜索算法"></a>1.2 GSAT + walk的局部搜索算法</h3><blockquote><p>随机游走 + 贪心算法</p></blockquote><p>&emsp;&emsp;算法中引入了一个参数p,在选择翻转变量的时候,以概率p在不满足子句中随机选择一个变量翻转,以概率1-p按照GSAT的策略翻转,即允许翻转之后的目标值比当前的目标值差<br>(适当后退,防止陷入局部最优);</p><h3 id="1-3-WalkSat"><a href="#1-3-WalkSat" class="headerlink" title="1.3 WalkSat"></a>1.3 WalkSat</h3><p>&emsp;&emsp;在Random Walk上做了改变,在选择变量时,首先随机选择一个不满足子句c,将翻转变量限制在这个子句中,记变量反转之后由满足变为不满足的子句个数为break-count;若break-count = 0,则翻转该变量;否则,以噪声概率p在子句c中最忌选择一个变量,以1-p在子句c中选择break-count最小的变量。<br>&emsp;&emsp;（考虑了变量翻转后满足子句变为不满足的个数,尽可能使其低;只考虑了降低变坏的风险。）</p><h3 id="1-4-TSAT"><a href="#1-4-TSAT" class="headerlink" title="1.4 TSAT"></a>1.4 TSAT</h3><p>&emsp;&emsp;在搜索过程中维持了一个固定长度的禁忌表,记录翻转过的变量,每翻转一个变量就更新一次,防止一段时间之内反复的翻转同一个位置,避免陷入局部极小,保证了变量在搜索空间的均匀分布;</p><hr><h2 id="2-本文的改进"><a href="#2-本文的改进" class="headerlink" title="2. 本文的改进"></a>2. 本文的改进</h2><h3 id="2-1-去掉GSAT-walk的“平移”操作"><a href="#2-1-去掉GSAT-walk的“平移”操作" class="headerlink" title="2.1 去掉GSAT+walk的“平移”操作"></a>2.1 去掉GSAT+walk的“平移”操作</h3><p>&emsp;&emsp;在不加权的GSAT中平台大量存在,搜索过程往往需要经过多次平移通过一个平台,并使不满足子句个数进一步减少。因此在不加权的GSAT中,平移是必须的,并且占了大部分。<br>&emsp;&emsp;在GSAT+walk中,随机行走允许上移,即不满足子句的个数增加。因此,随机行走策略使得搜索过程不会陷入某一平台或局部极小点。但平移依旧存在,并且约占所有移动的一半。<br>通过大量实验证实了GSAT部分的平移不再是必需的,去掉使得算法效率提高了。</p><p><strong>去掉GSAT部分的平移后的GSAT+walk算法:</strong><br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">随机产生一个真值指派作为搜索的起点;</span><br><span class="line">while 在当前指派下还有不满足的子句 do begin</span><br><span class="line">    产生一个[0,1)范围内的随机数r;</span><br><span class="line">    if(r &lt; p) then begin</span><br><span class="line">        在所有的不满足子句中随机挑选一个子句,在该子句中随机选择一个变元翻转(random walk)</span><br><span class="line">    end else begin</span><br><span class="line">        从所有变元中选取这样一个变元,使得翻转这个变元前不满足子句个数减去翻转后不满足子句个数的差达到最大。若这个差所能达到的最大值是0和负数,则不做任何事,否则将该变元的值翻转。(GSAT)</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;GSAT+walk可以很好的解决随机3SAT问题,但对于结构SAT问题,往往会反复地陷入局部极小点或平台中。在GSAT+walk中,由于引入了随机游走,使得一些子句时而满足时而不满足。显示了在结构SAT实例中的子句不对称性,解决办法就是对子句加权。<p></p><p><strong>GSAT(子句加权):</strong><br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">所有子句的权初始化为1;</span><br><span class="line">for i &#x3D;1 to MAXTRIES do begin</span><br><span class="line">    随机产生一个真值指派,作为搜索的起点; </span><br><span class="line">    for j&#x3D;1 to MAXFLIPS do begin</span><br><span class="line">        if 不满足子句的个数&#x3D;0 then 求解成功并输出当前指派;</span><br><span class="line">        从所有变元中选出这样一个变元,使得翻转这个变元前不满足子句的权之和减去翻转后不满足子句的权之和的差达到最大。</span><br><span class="line">        将该变元的值翻转翻转;</span><br><span class="line">    endfor</span><br><span class="line">    若不满足子句的个数不为0,则将所有不满足子句的权加1;否则,求解成功并输出当前指派;</span><br><span class="line">endfor</span><br></pre></td></tr></table></figure><p></p><p><strong>GSAT+walk(子句加权):</strong><br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">所有子句的权初始化为1;</span><br><span class="line">for i &#x3D;1 to MAXTRIES do begin</span><br><span class="line">    随机产生一个真值指派,作为搜索的起点; </span><br><span class="line">    for j&#x3D;1 to MAXFLIPS do begin</span><br><span class="line">        if 不满足子句的个数&#x3D;0 then 求解成功并输出当前指派;</span><br><span class="line">        产生一个[0,1)范围内的随机数r;</span><br><span class="line">        if(r &lt; p) then begin</span><br><span class="line">            在所有的不满足子句中随机挑选一个子句,在该子句中随机选择一个变元翻转(random walk)</span><br><span class="line">        end else begin</span><br><span class="line">            从所有变元中选出这样一个变元,使得翻转这个变元前不满足子句个数减去翻转后不满足子句个数的差达到最大。若这个差所能达到的最大值是0和负数,则不做任何事,否则将该变元的值翻转;</span><br><span class="line">            若不满足子句的个数不为0,则从所有不满足子句中随机挑选一个子句,并将它的权加1;</span><br><span class="line">    end</span><br><span class="line">    if 不满足子句的个数&#x3D;0 then 求解成功并输出当前指派;</span><br><span class="line">endfor</span><br><span class="line">求解失败;</span><br></pre></td></tr></table></figure><p></p><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>毕设</category>
        <category>文献阅读</category>
        <category>算法</category>
        <category>GA</category>
      </categories>
      <tags>
        <tag>毕设</tag>
        <tag>文献阅读</tag>
        <tag>笔记</tag>
        <tag>GA</tag>
      </tags>
  </entry>
  <entry>
    <title>基于改进的遗传算法求解3_SAT问题</title>
    <url>/2020/03/08/%E5%9F%BA%E4%BA%8E%E6%94%B9%E8%BF%9B%E7%9A%84%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A33-SAT%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<!-- build time:Thu Mar 26 2020 23:48:51 GMT+0800 (GMT+08:00) --><p>&emsp;&emsp;基于局部搜索算法策略与SGA算法的基础上将三路划分快速排序算法相结合一种改进。首先通过适应度函数对基准调节，运用改进的三路划分快速排序，重新生成新的种群。</p><h2><a href="#" class="headerlink"></a><a id="more"></a></h2><h2 id="1-LSA"><a href="#1-LSA" class="headerlink" title="1. LSA"></a>1. LSA</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">step 1: rand(X);    &#x2F;&#x2F;随机产生P的一个指派</span><br><span class="line">step 2: t(X);       &#x2F;&#x2F;计算适应度函数值</span><br><span class="line">step 3: X1 &lt;- X;</span><br><span class="line">step 4: For j&#x3D;1 to N Do;</span><br><span class="line">step 5: X&#39; &lt;- NegT(X,j)   &#x2F;&#x2F;从上代群体选择个体加入X1</span><br><span class="line">step 6: If t(X&#39;) &gt;&#x3D; t(X1) then X1&lt;-X&#39;;</span><br><span class="line">step 7: 返回最优个体及相应适应度函数值。</span><br></pre></td></tr></table></figure><hr><h2 id="2-改进的遗传算法"><a href="#2-改进的遗传算法" class="headerlink" title="2. 改进的遗传算法:"></a>2. 改进的遗传算法:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">step 1: 使用随机函数生成一组大小为POPSIZE的染色体组;</span><br><span class="line">step 2: t &lt;- 0;             &#x2F;&#x2F;初始迭代次数为0</span><br><span class="line">step 3: 评估染色体组;initevaluate(X(t)); </span><br><span class="line">step 4: While(not terminate condition) Do 进行交叉、变异、排序，选择产生新一代群体;</span><br><span class="line">step 4.1: 从上一代群体进行三路快速排序; T ~ Sort(X(t);)</span><br><span class="line">step 4.2: 从中选择出更优良的一半染色体组加入X1,淘汰掉另一半差的个体；X1 &lt;-Selection(X(t));</span><br><span class="line">step 4.3: 以概率Pt对X1中选择的染色体进行交叉操作生成X2;X2 &lt;- crossover(X2);</span><br><span class="line">step 4.4: 对X2中的染色体进行变异操作; X(t+1) &lt;- mutation(X2);</span><br><span class="line">step 5: for i&#x3D;0 to POPSIZE Do   &#x2F;&#x2F;对X(t+1)中后半部分个体综合LSA算法改变某个基因分量寻找最优解;  </span><br><span class="line">step 6: X4 &lt;- X(t+1);</span><br><span class="line">step 7: for j&#x3D;0 to N Do;</span><br><span class="line">step 8: X5 &lt;- NegT(X4,j);</span><br><span class="line">step 9: If t(X5)&gt;&#x3D;t(X4) then X5替代X4存活到下一代群体X(t+1)中;</span><br><span class="line">step 10: End While; </span><br><span class="line">step 11: 输出最优个体及相应适应度值。</span><br></pre></td></tr></table></figure><hr><h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><h3 id="排序策略"><a href="#排序策略" class="headerlink" title="排序策略:"></a>排序策略:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void T~Sort(int l, int r)&#123;</span><br><span class="line">    if(l &gt;&#x3D; r) return;          </span><br><span class="line">    &#x2F;&#x2F;选择pivot划分种群，并将其与r位置的染色体交换</span><br><span class="line">    int pivot;</span><br><span class="line">    pivot &#x3D; 1 + rand()%(r-l+1);</span><br><span class="line">    exchangeX(pivot, r);</span><br><span class="line">    &#x2F;&#x2F;双向扫描:left与right为主动移动,lflag与rflag为被动移动</span><br><span class="line">    int left &#x3D; 1, lflag &#x3D; 1;</span><br><span class="line">    int right &#x3D; r - 1, rflag &#x3D; r - 1;</span><br><span class="line">    while(true)&#123;</span><br><span class="line">        while(t(left) &lt;&#x3D; t(r) &amp;&amp; left &lt; r)&#123;</span><br><span class="line">            if(t(left) &#x3D;&#x3D; t(pivot))&#123;</span><br><span class="line">                exchangeX(left, lflag);</span><br><span class="line">                lflag++;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        while(t(right) &gt;&#x3D; t(r) &amp;&amp; right &gt;&#x3D; 1)&#123;</span><br><span class="line">            if(t(right) &#x3D;&#x3D; t(pivot))&#123;</span><br><span class="line">                exchangeX(right, rflag);</span><br><span class="line">                rflag--;</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        if(left &gt;&#x3D; right) break;</span><br><span class="line">        exchangeX(right, left);</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;*此时左右最边上是和t(pivot)相等的染色体,靠左中间是小于其的,靠右中间是大于其的*&#x2F;</span><br><span class="line">    lflag--;</span><br><span class="line">    left--;</span><br><span class="line">    while(lflag &gt;&#x3D; 1)&#123;</span><br><span class="line">        exchangeX(left, lflag);</span><br><span class="line">        left--;</span><br><span class="line">        lflag--;</span><br><span class="line">    &#125;</span><br><span class="line">    rflag++;</span><br><span class="line">    right++;</span><br><span class="line">    while(rflag &lt;&#x3D; r)&#123;</span><br><span class="line">        exchangeX(right, rflag);</span><br><span class="line">        right++;</span><br><span class="line">        rflag++;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;*此时左边上是小于t(pivot)的染色体,中间是等于其的,右边是大于其的*&#x2F;</span><br><span class="line">    &#x2F;&#x2F;最终递归处理左右子序列部分</span><br><span class="line">    selection(l, left);</span><br><span class="line">    selection(right, r);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="交叉操作"><a href="#交叉操作" class="headerlink" title="交叉操作:"></a>交叉操作:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void crossover()&#123;</span><br><span class="line">    &#x2F;&#x2F;以PXOVER概率进行杂交</span><br><span class="line">    for(......)&#123;</span><br><span class="line">        Generate a random number from 0 to 1;</span><br><span class="line">        if(rand() * (1.0&#x2F;(RAND_MAX + 1.0)) &lt; PXOVER)&#123;</span><br><span class="line">            Random access number of two chromosomes from the select action populations;</span><br><span class="line">            Random generated a conform to the starting point for the hybrid operation;</span><br><span class="line">            overType &#x3D; rand() % 3;</span><br><span class="line">            swith(overType)&#123;</span><br><span class="line">                case 1:         &#x2F;&#x2F;以2&#x2F;3的概率进行互换子串杂交</span><br><span class="line">                case 2: int logic &#x3D; rand() % 3;</span><br><span class="line">                swith(logic)&#123;</span><br><span class="line">                    case 0:         &#x2F;&#x2F;以1&#x2F;9的概率进行异或杂交</span><br><span class="line">                    case 1:         &#x2F;&#x2F;以1&#x2F;9的概率进行与杂交</span><br><span class="line">                    case 2:         &#x2F;&#x2F;以1&#x2F;9的概率进行或杂交</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>毕设</category>
        <category>文献阅读</category>
        <category>算法</category>
        <category>GA</category>
      </categories>
      <tags>
        <tag>毕设</tag>
        <tag>文献阅读</tag>
        <tag>笔记</tag>
        <tag>GA</tag>
      </tags>
  </entry>
  <entry>
    <title>一种新的自适应退火遗传算法</title>
    <url>/2020/03/08/%E4%B8%80%E7%A7%8D%E6%96%B0%E7%9A%84%E8%87%AA%E9%80%82%E5%BA%94%E9%80%80%E7%81%AB%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<!-- build time:Thu Mar 26 2020 23:48:51 GMT+0800 (GMT+08:00) --><a id="more"></a><h2 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h2><p>对于SAT问题,</p><ul><li><p>选择</p><ul><li>引入了一类时变选择策略 — 整体退火选择。通过父代横向的竞争，不仅可以保证算法的收敛性，而且比SA有更快地收敛速度，具有更强的逃脱局部极值和避免过早收敛的全局优化能力。</li><li><script type="math/tex">A_i \in G</script>,则被选的概率为<script type="math/tex">P_s(A_i) = \frac{e^{f(A_i)/T_k}}{\sum_{A_j \in G} e^{f(A_j)/T_k}}</script>。<script type="math/tex">T_k</script>为渐趋于0的退火温度,<center>$$T_k = T_0 \frac{(ln2)^{a-1}}{(ln(1+k))^{a-1}k^{2-a}} &emsp; \begin{cases} {k=1,2,3,\ldots}, & \text{}\\[2ex] a\in{1,2}, & \text{} \end{cases}$$</center>当a为1时，此时为快速模拟退火，提高算法的收敛速度；当a为2时，此时为经典模拟退火，以使算法以概率1收敛到全局最优点。</li></ul></li><li><p>交叉</p><ul><li>当前代种群中个体的适应度低于平均值时，就要提高交叉率；当适应度高于平均值时，就要降低交叉率；当适应度值越来越接近最大适应度时，交叉率越来越小； 当其等于最大适应度时，不能使交叉率为0，否则会对进化初期不利，增大了进化趋向局部最优解的可能性。</li><li><script type="math/tex;mode=display">P_c = \begin{cases} {P_{c1} - \frac{(P_{c1}-P_{c2})(f-f_{avg})}{f_{max}-f_{avg}}}, & \text{$f \geq f_{avg}$}\\[2ex] P_{c1}, & \text{$$f< f_{avg}$$} \end{cases}</script></li></ul></li><li><p>变异</p><ul><li><script type="math/tex;mode=display">P_m = \begin{cases} {P_{m1} - \frac{(P_{m1}-P_{m2})(f-f_{avg})}{f_{max}-f_{avg}}}, & \text{$f \geq f_{avg}$}\\[2ex] P_{m1}, & \text{$$f< f_{avg}$$} \end{cases}</script></li></ul></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>毕设</category>
        <category>文献阅读</category>
        <category>算法</category>
        <category>GA</category>
      </categories>
      <tags>
        <tag>毕设</tag>
        <tag>文献阅读</tag>
        <tag>笔记</tag>
        <tag>GA</tag>
      </tags>
  </entry>
  <entry>
    <title>一种基于有向交叉的遗传算法</title>
    <url>/2020/03/05/%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8E%E6%9C%89%E5%90%91%E4%BA%A4%E5%8F%89%E7%9A%84%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<!-- build time:Thu Mar 26 2020 23:48:51 GMT+0800 (GMT+08:00) --><p>&emsp;&emsp;从解空间的角度出发分析了交叉算子的作用，针对其盲目搜素的缺陷，提出了一种通过控制交叉子代的落点位置，使得交叉子代大概率地朝最优解的方向前进。</p><h2><a href="#" class="headerlink"></a><a id="more"></a></h2><h2 id="1-交叉操作的特征"><a href="#1-交叉操作的特征" class="headerlink" title="1.交叉操作的特征"></a>1.交叉操作的特征</h2><hr><h2 id="2-有向交叉"><a href="#2-有向交叉" class="headerlink" title="2.有向交叉"></a>2.有向交叉</h2><hr><p>对于SAT问题,<br>&emsp;&emsp;记个体<script type="math/tex">x:=\{x_1,x_2,\ldots,x_n\},y:=\{y_1,y_2,\ldots,y_n\};x,y \in \{0,1\}</script>;记翻转<script type="math/tex">x_i</script>后,<script type="math/tex">diff(x_i)</script>表示可满足子句的增加数;<br></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> each i:</span><br><span class="line">    <span class="keyword">if</span>(x_i == y_i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(diff(x_i) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            flip        <span class="comment">// 可以通过概率p来实现跳出局部最优</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">not</span> flip</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x_i &gt; y_i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x_i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                flip      <span class="comment">// 可以通过概率p来实现跳出局部最优</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">not</span> flip</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(x_i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                flip      <span class="comment">// 可以通过概率p来实现跳出局部最优</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">not</span> flip</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p></p><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>毕设</category>
        <category>文献阅读</category>
        <category>算法</category>
        <category>GA</category>
      </categories>
      <tags>
        <tag>毕设</tag>
        <tag>文献阅读</tag>
        <tag>笔记</tag>
        <tag>GA</tag>
      </tags>
  </entry>
  <entry>
    <title>基于竞争指数的模拟退火排序选择算子</title>
    <url>/2020/03/05/%E5%9F%BA%E4%BA%8E%E7%AB%9E%E4%BA%89%E6%8C%87%E6%95%B0%E7%9A%84%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E6%8E%92%E5%BA%8F%E9%80%89%E6%8B%A9%E7%AE%97%E5%AD%90/</url>
    <content><![CDATA[<!-- build time:Thu Mar 26 2020 23:48:51 GMT+0800 (GMT+08:00) --><p>&emsp;&emsp;竞争指数是对个体的适应度以及编码差异度综合评估而产生的一种个体质量评价指标,代表了个体的绝对价值;根据其的竞争指数对个体进行排名,然后模拟退火过程产生排序参数,将其作为个体的相对价值;然后,将绝对价值以及相对价值的加权平均值作为个体生存的概率。这种选择方式可以有效地控制群体在迭代过程中的选择压力,保持群体结构的合理性。<br><a id="more"></a></p><hr><h2 id="1-竞争指数"><a href="#1-竞争指数" class="headerlink" title="1. 竞争指数:"></a>1. 竞争指数:</h2><p>&emsp;&emsp;设群体的规模为n,L为个体编码的长度,m维个体<script type="math/tex">A_i = a_1 a_2 \ldots a_L</script>,<script type="math/tex">a \in \{0,1\}</script>的适应度为<script type="math/tex">F_i>0</script>,<script type="math/tex">F_{max}</script>和<script type="math/tex">F_{avg}</script>分别表示当前群体中最优适应度和平均适应度。<br><br>&emsp;&emsp;规定当前群体中最优个体的竞争指数为1,其余个体的竞争指数为:<center>$$Q(A_i,A_{best}) = Q_i = \begin{cases} 0, & \text{if $D_i=0$}\\[2ex] D_i^{\lambda \overline{R_i}}, & \text{otherwise} \end{cases}$$</center><br>&emsp;&emsp;其中,调节参数<script type="math/tex">\lambda\in \begin{cases} (0,1) & \text{$\overline{R}<1$}\\[2ex] [1,2) & \text{$\overline{R}\geq1$} \end{cases}</script>;个体<script type="math/tex">A_i</script>所具有的相对平均适应度比<script type="math/tex">R_i = \frac{F_max - F_i}{F_max - F_{avg}}</script>;<script type="math/tex">D_i</script>表示<script type="math/tex">A_i</script>与<script type="math/tex">A_{best}</script>的编码差异度。<br><br>&emsp;&emsp;相对平均适应度比可用于描述个体<script type="math/tex">A_i</script>在进化信息传递方面的价值;当<script type="math/tex">F_i>F_{avg}</script>时<script type="math/tex">0 \leq \overline{R_i} \leq 1</script>;当<script type="math/tex">F_i \leq F_{avg}</script>时,<script type="math/tex">\overline{R_i} \geq 1</script>。通常,认为大于平均适应度的个体所承载的进化信息是有价值信息。<br>&emsp;&emsp;<script type="math/tex">D_i</script>反映了个体<script type="math/tex">A_i</script>与最优个体<script type="math/tex">A_{best}</script>的编码差异。由于<script type="math/tex">D_i \in [0,1]</script>,当<script type="math/tex">R_i < 1</script>即<script type="math/tex">F_i > F_{avg}</script>时<script type="math/tex">Q_i>Di</script>;当<script type="math/tex">R_i \geq 1</script>即<script type="math/tex">F_i \leq F_{avg}</script>时<script type="math/tex">Q_i \leq D_i</script>。这种变化方式使得高于群体平均适应度且与群体中最优个体差异较大的个体将具有更接近1的竞争指数,反而低于群体平均适应度且与群体中最优个体差异较小的个体具有更接近0的竞争指数。<br><br>&emsp;&emsp;第k代群体的平均编码差异度为:<center>$$ \chi_k= \frac{1}{n-1} \sum_{i=1}^{n-1}(\frac{1}{n-i} \sum_{j=1}^{n-1}D_{ij}) $$</center><br>&emsp;&emsp;群体平均差异度量化了群体中个体编码的差异性。越接近1说明群体中个体编码差异度越大,群体多样性程度越高。</p><h2 id="2-基于竞争指数的模拟退火排序选择算子"><a href="#2-基于竞争指数的模拟退火排序选择算子" class="headerlink" title="2. 基于竞争指数的模拟退火排序选择算子"></a>2. 基于竞争指数的模拟退火排序选择算子</h2><h3 id="模拟退火算子的工作流程"><a href="#模拟退火算子的工作流程" class="headerlink" title="模拟退火算子的工作流程:"></a>模拟退火算子的工作流程:</h3><p><strong>(1)</strong> &nbsp;计算父个体群体与子个体群体的竞争指数,并依据其对个体队列进行降序排序操作;</p><p><strong>(2)</strong> &nbsp;规定队列中<script type="math/tex">h(1) = 1</script>,其余<script type="math/tex">k=2,\ldots,2n</script>位个体的排序未知参数为:</p><p><center>$$h(k) = \exp(-\chi / T_k)$$</center></p><blockquote><p>&emsp;&emsp;其中,<script type="math/tex">\chi</script>为当前父个体群体的多样性指标,队列中第k位个体的退火温度为<script type="math/tex">T_k=T_0\beta^k</script>;一般<script type="math/tex">T_0 = 2n</script>V,<script type="math/tex">\beta</script>是一个略小于1的数。</p></blockquote><p><strong>(3)</strong> &nbsp;按照队列顺序依次挑选下代个体,队列中第k位个体的选择概率为<script type="math/tex">P_s(k) = \sigma Q_k + (1 - \sigma)h(k)</script>&emsp;&emsp;其中,权值<script type="math/tex">\sigma \in (0,1)</script>用于个体的竞争指数和模拟退火参数对选择概率的影响程度。<br></p><h3 id="该选择过程的特点"><a href="#该选择过程的特点" class="headerlink" title="该选择过程的特点:"></a>该选择过程的特点:</h3><p>（1） &nbsp;<strong>综合评估个体价值产生选择概率;</strong><br><br>（2） &nbsp;<strong>具有精英选择特性:</strong><br></p><blockquote><p>&emsp;&emsp;当群体及其后代中最优个体<script type="math/tex">A_{best}</script>的竞争指数<script type="math/tex">Q_{best}=1,h(A_{best})=1</script>,则<script type="math/tex">A_{best}</script>将以概率1保留到下代群体中,保持了算法的收敛性。</p></blockquote><p>（3） &nbsp;<strong>保持群体多样性;</strong><br><br>（4） &nbsp;<strong>通过参数<script type="math/tex">\sigma</script>动态调节选择概率;</strong><br></p><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>毕设</category>
        <category>文献阅读</category>
        <category>算法</category>
        <category>GA</category>
      </categories>
      <tags>
        <tag>毕设</tag>
        <tag>文献阅读</tag>
        <tag>笔记</tag>
        <tag>GA</tag>
      </tags>
  </entry>
  <entry>
    <title>遗传算法研究进展    ---- 马永杰,云文霞</title>
    <url>/2020/03/01/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6%E8%BF%9B%E5%B1%95/</url>
    <content><![CDATA[<!-- build time:Thu Mar 26 2020 23:48:51 GMT+0800 (GMT+08:00) --><p>&emsp;&emsp;对遗传算法编码策略、遗传算子、参数确定、收敛性、欺骗问题等理论进行了分析;<br><a id="more"></a></p><hr><h2 id="1-GA介绍"><a href="#1-GA介绍" class="headerlink" title="1. GA介绍"></a>1. GA介绍</h2><ul><li>&emsp;&emsp;遗传算法是由美国的Holland教授在1975年在他的专著《自然界和人工系统的适应性》中首先提出的,它是一类借鉴生物界自然选择个自然遗传机制的随机搜素算法。遗传算法模拟自然选择和自然遗传过程中发生的繁殖、交叉和基因突变现象,在每次迭代中都保留一组候选解,并按某种指标从解群中选取较优的个体,利用遗传算子（选择、交叉和变异）对这些个体进行组合,产生新一代的候选解群,重复此过程,直至满足某种收敛指标为止。</li><li>&emsp;&emsp;与传统的启发式优化搜素算法相比,GA的主要本质特征在于群体搜索策略和简单的遗传算子。</li><li>&emsp;&emsp;群体搜索使遗传算法得以突破领域搜索的限制,可以实现整个解空间上的分布式信息的采集和探索;遗传算子仅仅利用适应值度量作为运算指标进行随机操作,降低了一般启发式算法在搜索过程中对人机交互的依赖。</li></ul><hr><h2 id="2-GA理论研究进展"><a href="#2-GA理论研究进展" class="headerlink" title="2. GA理论研究进展"></a>2. GA理论研究进展</h2><p>&emsp;&emsp;GA追求的是当前群体产生比现有个体更好个体的能力,即遗传算法的可进化性or群体可进化性。</p><h3 id="2-1-编码策略"><a href="#2-1-编码策略" class="headerlink" title="2.1 编码策略"></a>2.1 编码策略</h3><p>&emsp;&emsp;编码是把一个问题的可行解从其解空间转换到GA所能处理的搜索空间的转换方法。(对于SAT问题,我们采用二进制编码)</p><h3 id="2-2-遗传算子"><a href="#2-2-遗传算子" class="headerlink" title="2.2 遗传算子"></a>2.2 遗传算子</h3><p>&emsp;&emsp;包括选择、交叉和变异三大算子,模拟自然选择和遗传过程中发生的繁殖、杂交和突变现象。</p><ul><li><p><strong>选择算子:</strong><br>&emsp;&emsp;体现了适者生存的原理（通过适应度选择优质个体而抛弃劣质个体),作用是避免基因缺失,提高全局收敛性和计算效率;</p><ul><li>文献<a href="#refer-anchor"><sup>10</sup></a> — 提出了一种基于个体差异的局部竞争选择算子,通过保持种群的多样性增强了算法从局部最优中跳出的能力;</li><li>文献<a href="#refer-anchor"><sup>11</sup></a> — 提出了基于竞争指数的模拟退火排序选择算子,该算子能够有效的避免早熟收敛同时显著提高种群的搜索效率和稳定性;</li></ul></li><li><p><strong>交叉算子:</strong><br>&emsp;&emsp;使个体之间的遗传物质交换从而产生更好的个体;</p><ul><li>文献<a href="#refer-anchor"><sup>13</sup></a> — 提出了一种有向交叉遗传算子,通过优化控制交叉子代的落点位置,是交叉子代大概率地朝着最优解方向进化;</li></ul></li><li><p><strong>变异算子:</strong><br>&emsp;&emsp;能恢复个体失去的或未开发的遗传物质,以防止个体在形成最优解过程中过早的收敛;</p><ul><li>文献<a href="#refer-anchor"><sup>22</sup></a> — 设计了一个新的变异算子-贪婪子巡回变异算子CSTM,在新算子中存在两种不同的贪婪搜索方法和组件;</li></ul></li></ul><h3 id="2-3-参数确定"><a href="#2-3-参数确定" class="headerlink" title="2.3 参数确定"></a>2.3 参数确定</h3><p>&emsp;&emsp;主要包括染色体位串长度l(SAT中变元个数),群体规模n,交叉概率p_c,变异概率p_m;</p><ul><li>文献<a href="#refer-anchor"><sup>29</sup></a> — 针对早熟问题进行研究,提出以优势遗传的原则随个体适应的变化而适应地改变交叉和变异概率;</li></ul><h3 id="2-4-收敛性"><a href="#2-4-收敛性" class="headerlink" title="2.4 收敛性"></a>2.4 收敛性</h3><p>&emsp;&emsp;近几年,在遗传算法的全局收敛性的分析方面取得了突破,运用的主要工具是Markov链。<br>&emsp;&emsp;Rudolph（文献<a href="#refer-anchor"><sup>31</sup></a>）用齐次有限Markov链证明了带有选择、交叉、变异的经典遗传算法收敛不到全局最优解,但,若在遗传算法中保留每一代的最优个体,则算法将收敛到全局最优解;等</p><hr><h2 id="3-GA发展"><a href="#3-GA发展" class="headerlink" title="3. GA发展"></a>3. GA发展</h2><ul><li>文献<a href="#refer-anchor"><sup>62</sup></a> — 在标准GA的基础上,通过改进选择概率提出了一种自适应退火遗传算法;</li></ul><hr><p><br><br><br></p><div id="“refer-anchor”"></div><h2 id="4-References"><a href="#4-References" class="headerlink" title="4. References"></a>4. References</h2><p>[10] [乔家庆,付平,孟升卫.基于个体差异的遗传选择算子设计,2006]</p><p>[11] [陈皓,崔杜武,严太山等.基于竞争指数的模拟退火排序选择算子].2009</p><p>[13] [范青武,王普,高学金．一种基于有向交叉的遗传算法.2009]</p><p>[22] [MURAT A,NOVRUZ A.Development ａ new mutation operator to solve the tarveling saleman problem by aid of GA.2011]</p><p>[29] [陈世哲,刘国栋,浦欣,等．基于优势遗传的自适应遗传算法.2007]</p><p>[31] [RUDOLPH G.Convergence analysis of canonical genetic algorirhms.]</p><p>[62] [黄宜军,章卫国,刘小雄．一种新的自适应退火遗传算法.2006]</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>毕设</category>
        <category>文献阅读</category>
        <category>算法</category>
        <category>GA</category>
      </categories>
      <tags>
        <tag>毕设</tag>
        <tag>文献阅读</tag>
        <tag>笔记</tag>
        <tag>GA</tag>
      </tags>
  </entry>
  <entry>
    <title>基于个体差异的遗传选择算子设计    ---- 乔家庆,付平,孟升卫</title>
    <url>/2020/03/01/%E5%9F%BA%E4%BA%8E%E4%B8%AA%E4%BD%93%E5%B7%AE%E5%BC%82%E7%9A%84%E9%81%97%E4%BC%A0%E9%80%89%E6%8B%A9%E7%AE%97%E5%AD%90%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<!-- build time:Thu Mar 26 2020 23:48:51 GMT+0800 (GMT+08:00) --><p>&emsp;&emsp;采用基于局部竞争机制的选择算子不易跳出局部最优的问题,设计了一种基于个体差异的局部竞争选择算子,局部竞争作用的区域由种群的个体差异决定,有利于保持种群的多样性,增强算法从局部最优中跳出的能力。<a id="more"></a></p><hr><h2 id="1-一般选择算子及其特点"><a href="#1-一般选择算子及其特点" class="headerlink" title="1. 一般选择算子及其特点"></a>1. 一般选择算子及其特点</h2><p>&emsp;&emsp;在GA中,选择算子使搜索的重点放在适应值较高的个体上,使其获得较高的复制数目,充分利用了群体内当前具有的有效信息,但同时也是群体内个体失去多样性。</p><p>&emsp;&emsp;不同的选择算子导致了不同的选择压力,较大的选择压力使得最优个体具有较高的复制数目,从而使算法收敛速度快,但容易陷入局部最优;而较小的压力,不易陷入局部最优,但收敛速度慢。</p><h3 id="1-1-基于适应值比例"><a href="#1-1-基于适应值比例" class="headerlink" title="1.1 基于适应值比例:"></a>1.1 基于适应值比例:</h3><p>&emsp;&emsp;以个体在种群中的相对适应值为评价指标的选择策略;</p><ul><li>繁殖池: 根据相对适应值确定个体复制的个数,适应值较小的个体将被淘汰;</li><li>轮盘式选择: 根据相对适应值确定个体被选择的概率,群体中所有成员都有被选择的机会;</li></ul><h3 id="1-2-基于排名"><a href="#1-2-基于排名" class="headerlink" title="1.2 基于排名:"></a>1.2 基于排名:</h3><p>&emsp;&emsp;通过个体适应值在种群中的排名来计算其被选择的概率,然后根据这个概率使用轮盘选择;</p><h3 id="1-3-基于局部竞争"><a href="#1-3-基于局部竞争" class="headerlink" title="1.3 基于局部竞争:"></a>1.3 基于局部竞争:</h3><p>&emsp;&emsp;与其他两个相比,只涉及种群局部的个体间适应值的大小关系,而不涉及适应值信息。</p><p>&emsp;&emsp;竞标赛选择算子是基于此的一种选择算子,选择过程中先随随机的在群体中选择k（竞赛规模）个个体进行比较适应值,大的个体被选择。这种选择使得适应值大的个体有较大的的概率被选择,但选择的标准与适应值大小不直接成比例,因而也能避免群体中出现”超级个体”,可以在一定程度上避免出现早熟现象和停滞现象。</p><hr><h2 id="2-局部竞争机制的改进"><a href="#2-局部竞争机制的改进" class="headerlink" title="2. 局部竞争机制的改进"></a>2. 局部竞争机制的改进</h2><p>&emsp;&emsp;常用的选择算子通过利用个体的相对适应值或局部竞争机制避免算法的早收敛和停滞,但对于比较复杂的问题,如在全局最优解附近剧烈震荡的情况下,算法易陷入局部最优;</p><p>&emsp;&emsp;对于竞标赛选择算子而言,算法陷入局部最优的概率是由局部最优解在种群中所占的比例决定的;</p><h3 id="改进想法来源"><a href="#改进想法来源" class="headerlink" title="改进想法来源:"></a>改进想法来源:</h3><p>&emsp;&emsp;自然界的遗传竞争一般发生在相似或邻近的个体中,因此基于其可改进选择算子。</p><h3 id="理论实践"><a href="#理论实践" class="headerlink" title="理论实践:"></a>理论实践:</h3><p>&emsp;&emsp;在选择过程中,某一个体<script type="math/tex">x_i</script>与种群中各个个体差异表示为:<center>$$ L_{ij} = \sqrt{\sum_k (x_j(k) - x_i(k))^2} &emsp;,j=1,2,\cdots,N.$$</center>&emsp;&emsp;规定局部竞争作用发生在以<script type="math/tex">x_i</script>为中心区域,这一局部区域内适应值最大的个体被选择,并规定区域半径为:<center>$$ R_i = r \times max\{L_{ij}\} &emsp;,j=1,2,\cdots,N.$$</center>r是[0,1]上的平均分布的随机数。<br>&emsp;&emsp;选择作用的局部区域表示为:<script type="math/tex">S_i = \{x_j|L_{ij}<R_i\}</script>。<br>&emsp;&emsp;显然,<script type="math/tex">x_i</script>属于<script type="math/tex">S_i</script>,参与局部竞争的个体与<script type="math/tex">x_i</script>的差异小于<script type="math/tex">S_i</script>,即竞争发生在类似个体间。由于区域半经受随机数r的影响,使得局部竞争中的胜出者既可能是目前种群中最优的个体,也可能是与差异<script type="math/tex">x_i</script>较小的相对优秀的个体。设置局部最优个体<script type="math/tex">x^*</script>与<script type="math/tex">x_i</script>的差异为：<script type="math/tex">L^* = \lambda \times max\{L_{ij}\}</script>。<br></p><h3 id="理论结论"><a href="#理论结论" class="headerlink" title="理论结论:"></a>理论结论:</h3><p>&emsp;&emsp;显然<script type="math/tex">0 \leq \lambda \leq1</script>,若<script type="math/tex">\lambda=1</script>,<script type="math/tex">x^*</script>胜出的概率<script type="math/tex">p^* = 0</script>;<script type="math/tex">\lambda < 1</script>时,<script type="math/tex">p^* = p(L^* < R_i) = p(\lambda < r)</script>。由于r是[0,1]上的平均分布的随机数,易得<script type="math/tex">p^* = 1 - \lambda</script>。<br>&emsp;&emsp;局部最优解被选中则在比较中胜出的概率与局部最优解在种群中所占的比例无关,而且局部最优个体<script type="math/tex">x^*</script>与<script type="math/tex">x_i</script>的差异较大时,参与竞争的概率较小,有利于保持种群的多样性,即搜索从局部最优跳出的概率更大了。基于个体差异的选择算子,由于父代中每个个体都有一次机会作为局部竞争区域的中心,因此不会发生搜索发散。</p><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>毕设</category>
        <category>文献阅读</category>
        <category>算法</category>
        <category>GA</category>
      </categories>
      <tags>
        <tag>毕设</tag>
        <tag>文献阅读</tag>
        <tag>笔记</tag>
        <tag>GA</tag>
      </tags>
  </entry>
</search>
