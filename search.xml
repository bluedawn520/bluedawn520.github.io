<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>OS_NOTES.md</title>
    <url>/2021/11/24/OS_NOTES/</url>
    <content><![CDATA[<a id="more"></a><h1 id="CHAPTER-1"><a href="#CHAPTER-1" class="headerlink" title="CHAPTER 1"></a>CHAPTER 1</h1><h2 id="Q1：What-is-OS"><a href="#Q1：What-is-OS" class="headerlink" title="Q1：What is OS?"></a>Q1：What is OS?</h2><blockquote><p>OS是指 ①控制和管理计算机系统硬件资源、②合理的组织和调度计算机工作和资源的分配、③进而为用户以及其他应用软件提供方便的接口和环境的 <u>系统软件</u>。</p></blockquote><hr><h2 id="Q2：OS的基本特征"><a href="#Q2：OS的基本特征" class="headerlink" title="Q2：OS的基本特征"></a>Q2：OS的基本特征</h2><blockquote><p>① 并发：多个程序可以在同一时间段内同时执行</p><p>【并行：同一时刻同时执行，必须要有硬件资源或多处理机的支持】</p><p>【引入进程是为了更好地实现系统的并发性】</p><p>【OS的并发使得以分时实现的】</p><p>② 共享：即资源共享，系统中的资源可供多个进程共同使用</p><ul><li>互斥共享方式：规定同一时间段内只能由一个进程访问该资源（称临界/独占资源）</li><li>同步共享方式</li></ul><p>③ 虚拟：即将一个物理上的实体虚拟化为逻辑上的多个对应物</p><ul><li>空分复用技术：虚拟存储器</li><li>时分复用技术：处理机分时共享</li></ul><p>④ 异步：在多道程序环境下，允许多个进程并发执行，但由于资源的有限，进程的执行不是一往直前的，而是走走停停的，以不可预知的速度向前推进。</p><p>其中，并发和共享是OS最基本的特征，它们之间相互依存，即资源共享是以并发为前提的，没有多个程序并发执行，资源共享也无从谈起；若系统无法对资源进行有效的管理，那么程序的执行势必会受到影响，甚至无法执行。</p></blockquote><hr><h2 id="Q3：OS的目标及功能"><a href="#Q3：OS的目标及功能" class="headerlink" title="Q3：OS的目标及功能"></a>Q3：OS的目标及功能</h2><blockquote><p>① 作为系统资源的管理者</p><ul><li>进程管理、处理机管理、内存管理、文件管理、外设管理</li></ul><p>② 作为用户与硬件之间的接口</p><ul><li><p>命令接口：</p><ul><li><p>联机命令接口/交互式命令接口：</p><p>【由一组键盘操作组合而成】</p><p>【用户每输入一条指令，控制权就转给OS，由OS的命令解释程序解释并执行，然后返还控制权】</p><ul><li><p>脱机命令接口/批处理命令接口：</p><p>【由一组作业控制命令组成】</p><p>【用户不能直接干扰作业的运行】</p><p>【需事先将作业的操作命令写成一份作业说明书，连同作业一起交给OS】</p></li></ul></li></ul></li><li><p>程序接口：【由一组系统调用/广义指令组成】</p></li><li><p>图形接口：【严格地来说，它不属于OS，但其所调用的系统调用属于OS】</p></li></ul><p>③ 作为扩充机器</p></blockquote><hr><h2 id="Q4：OS的发展"><a href="#Q4：OS的发展" class="headerlink" title="Q4：OS的发展"></a>Q4：OS的发展</h2><blockquote><p>手工操作阶段：</p><p>【缺点：① 用户独占全机②CPU利用率极低】</p><p>批处理阶段：</p><ul><li><p>单道批处理系统：</p><p>【内存中仅保持一道作业】</p><p>【特点：自动性、顺序性、单道性】</p><p>【是为了解决人机矛盾以及CPU与I/O设备之间的不协调】</p></li><li><p>多道批处理系统：</p><p>【特点：多道、宏观上并行微观上串行】</p><p>【优点：资源利用率高、系统吞吐量大】</p><p>【缺点：用户响应时间长、不提供人机交互】</p><p>【是为了进一步提高CPU利用率和系统吞吐量】</p></li></ul><p>分时OS：是指多个用户通过终端连接在一台主机上，用户可同时与主机进行交互而不被干扰</p><p>【分时技术：将CPU的运行时间分成很小的时间片，通过时间片轮转的方式分配CPU】</p><p>【优点：同时性、交互性、独立性、及时性】</p><p>实时OS：</p><p>硬实时OS、软实时OS</p><p>【优点：安全性、可靠性】</p><p>分布式OS、网络OS、个人计算机…</p></blockquote><hr><h2 id="Q5：内核主要包括"><a href="#Q5：内核主要包括" class="headerlink" title="Q5：内核主要包括"></a>Q5：内核主要包括</h2><blockquote><p>① 时钟管理</p><p>【FUNC1 计时，系统提供标准化的时间给用户】</p><p>【FUNC2 通过时钟中断的管理，可以实现进程的切换】</p><p>【在分时OS中采用时间片轮转调度方式、在实时OS中按截止时间控制运行、在批处理系统中通过时钟管理来衡量一个进程的运行程度】</p><p>② 中断机制</p><p>【中断机制中，只有一小部分属于内核，负责保护和恢复中断现场的信息，然后将控制权转给相应的中断处理程序，这样可以减少中断处理的时间，提高系统并行处理的能力】</p><p>【中断机制最初的目的是为了实现多道程序的并发】</p><p>【通道：是一种控制一台或多台外部设备的硬件机构，它一旦被启动就独立于CPU运行，因而做到了I/O操作与CPU并行工作。】</p><p>【早期的CPU和通道的联络方法是由CPU向通道发出询问指令来了解通道工作是否完成。若未完成，则主机就循环询问一直到通道工作结束。因此，这种询问方式无法真正做到CPU和I/O操作并行。引入中断机制后，CPU启动通道传输数据之后就去执行其他程序的计算工作，而通道进行输入/输出工作，当通道工作结束时，通过中断机制向CPU发出中断请求，然后CPU暂停当前执行工作，处理中断请求后再继续原来工作。】</p><p>③ 原语</p><p>【按层系结构设计的OS，底层是一些可以被调用的公用小程序，各自完成一个功能】</p><p>【特性：原子性、处于OS最底层、处理时间短调用频繁】</p><p>④ 系统控制的数据结构及处理</p><p>【作业控制块、PCB、设备控制块、各类链表、消息队列、缓冲区、空闲区登记表、内存分配表】</p></blockquote><hr><h2 id="Q6：中断-amp-异常"><a href="#Q6：中断-amp-异常" class="headerlink" title="Q6：中断&amp;异常"></a>Q6：中断&amp;异常</h2><blockquote><p>中断/外中断：是指来自CPU指令以外的事件发生。</p><p>【时钟中断：表示一个固定的时间片已到，让处理机处理计时、启动定时运行的任务等】</p><p>【时钟中断的主要工作是处理和时间相关的信息（系统时间、进程的时间片、延时、使用CPU的时间、各种定时器）以及决定是否执行调度程序】</p><p>【I/O设备结束中断：表示设备的输入/输出已经完成，希望处理机向设备发送下一输入/输出请求，同时让完成输入/输出的程序继续执行】</p><p>异常/内中断：是指来自CPU指令内部事件的发生。</p><p>【程序的非法操作码、地址越界、算术溢出、虚拟系统的缺页、专门的trap指令引起的事件】</p><p>【对异常处理一般要依赖于当前程序的运行现场，而且异常不能被屏蔽，一旦出现就应立即处理】</p><p>中断处理过程：</p><p>①关中断</p><p>【CPU响应中断后，首先要保存程序的运行现场，而在保存过程中，不应该响应更高级中断源发送的中断请求】</p><p>②保存断点</p><p>【为了保证中断服务程序执行完后，能够正确返回到原来程序，必须将原来程序的断点（程序计数器PC）保存起来】</p><p>③中断服务程序寻址</p><p>【其实质是取出中断服务程序的入口地址送到程序计数器】【硬件找到该中断请求对应的中断向量，中断向量指明中断服务程序的入口地址（各中断向量统一存放在中断向量表中，该表由OS初始化）】</p><p>④保存现场和屏蔽字</p><p>【现场信息一般指程序状态字寄存器PSWR和某些通用寄存器的内容】</p><p>⑤开中断</p><p>【允许更高级的中断请求得到响应】</p><p>⑥执行中断服务程序</p><p>⑦关中断</p><p>【保证在恢复现场和屏蔽字的时候不被中断】</p><p>⑧恢复现场和屏蔽字</p><p>⑨开中断、中断返回</p><p>【中断服务程序的最后一条指令通常是一条中断返回指令，使其返回到原程序的断点处，使之继续运行】</p><p>【①②③是由硬件（中断隐指令）完成，④~⑨由中断服务程序（属于OS内核）完成】</p><p>访管指令&amp;访管中断：</p><p>处于用户态的用户程序使用访管指令时，系统根据访管指令的操作数执行访管中断处理程序，访管中断处理程序按照系统调用的操作数和参数转到相应的例行子程序。完成功能后，退出中断，返回到用户程序断点继续执行。</p><p>☆☆☆【由用户态进入核心态，不仅状态需要切换，而且所用到的堆栈也可能由用户堆栈切换成系统堆栈，并且这个系统堆栈也是属于该进程的】☆☆☆</p></blockquote><hr><h2 id="Q7：OS的体系结构"><a href="#Q7：OS的体系结构" class="headerlink" title="Q7：OS的体系结构"></a>Q7：OS的体系结构</h2><blockquote><p>【大内核：将OS的主要功能模块作为一个紧密联系的整体运行在核心态，从而为应用提供高性能的系统服务】</p><p>【微内核：将内核中最基本的功能保留，其他移到用户态】【缺点：需要频繁在用户态和核心态之间进行切换，OS执行开销大】</p></blockquote><hr><h1 id="CHAPTER-2"><a href="#CHAPTER-2" class="headerlink" title="CHAPTER 2"></a>CHAPTER 2</h1><h2 id="Q8：为什么引入进程？"><a href="#Q8：为什么引入进程？" class="headerlink" title="Q8：为什么引入进程？"></a>Q8：为什么引入进程？</h2><p>在多道程序环境下，允许程序并发执行，此时失去封闭性，并具有间断性、不可重现的特性。为此，引入进程，以便更好地描述和控制程序的执行，实现OS的并发与共享。</p><h2 id="Q9：进程的概念"><a href="#Q9：进程的概念" class="headerlink" title="Q9：进程的概念"></a>Q9：进程的概念</h2><p>进程是具有独立功能的程序在一个数据集合上的运行过程，它是系统进行资源分配和调度的一个独立单位。（引入线程后，线程是调度的基本单位）</p><p>进程是程序的一次执行过程。</p><p>进程一个程序及数据在处理机上顺序执行时所发生的活动。</p><p>进程是进程实体的运行过程，是系统进行资源分配和调度的基本单位。（进程实体/进程映像：由PCB、程序段、数据段组成；某时刻静态的进程）</p><h2 id="Q10：进程的特征"><a href="#Q10：进程的特征" class="headerlink" title="Q10：进程的特征"></a>Q10：进程的特征</h2><p>①动态性</p><p>【进程是程序的一次执行过程，是动态地产生、变化和消亡的】</p><p>②并发性</p><p>【多个进程存在于内存中，能够在同一时间段执行】</p><p>【引入进程的目的就是为了程序之间的并发执行，以提高系统吞吐量】</p><p>③独立性</p><p>【进程是一个能够独立运行，独立获取资源以及独立调度的基本单位】</p><p>【PCB是进程存在的唯一标志，凡未建立PCB的程序都不能作为一个独立单位运行】</p><p>④异步性</p><p>【由于进程的相互制约，使得进程的执行具有间断性。即进程是按照各自独立的、不可预知的速度向前推进。异步性导致了其执行结果的不可重现性。】</p><p>⑤结构性</p><p>【每个进程都是由PCB、程序段、数据段三部分组成】</p><h2 id="Q11：进程的状态及状态转换"><a href="#Q11：进程的状态及状态转换" class="headerlink" title="Q11：进程的状态及状态转换"></a>Q11：进程的状态及状态转换</h2><p>①创建态：进程正在被创建，未转到就绪态。</p><p>【创建步骤：首先申请一个空白的PCB，并向PCB中填入一些控制和管理进程的信息，然后由系统为进程分配运行时所必要的资源，最后将其转为就绪态。】</p><p>②就绪态：进程获得了除CPU以外的所有资源，一旦分配CPU即可执行。</p><p>③运行态：进程正在运行。</p><p>④阻塞态：</p><p>进程由于等待某一事件发生（如：等待I/O完成、等待除CPU外的某资源分配）而暂停运行，只有当这个事件响应时才从阻塞态转为就绪态。</p><p>【一个正在执行的进程等待某一事件而被阻塞是主动行为，因此只有运行态才可转到阻塞态。而当等待事件发生唤醒阻塞进程是被动行为，需要其他进程的协助】</p><p>⑤结束态：可能由于进程的正常结束或其他原因中断退出运行。</p><p>【进程需要结束运行时，系统首先将该进程置为结束态，然后进一步处理资源释放和回收工作】</p><p>⑥就绪挂起态</p><p>⑦阻塞挂起态：由于内存资源有限，当内存不足时将一些阻塞的进程移到外存，待内存有空闲时将其移到内存。</p><p>状态转换：</p><p>创建态 —&gt; 就绪态</p><p>—&gt; 阻塞态 【分配内存等资源不足时】</p><p>就绪态 —&gt; 运行态</p><p>—&gt; 结束态</p><p>—&gt; 就绪挂起态 【内存不足】</p><p>运行态 —&gt; 就绪态 【时间片已到/可剥夺系统中有更高优先级进程进入】</p><p>—&gt; 阻塞态 【等待某事件的发生】</p><p>【进程以系统调用的形式请求OS提供服务，这是一种特殊的、由用户态程序调用OS内核过程的形式】</p><p>—&gt; 结束态</p><p>阻塞态 —&gt; 就绪态 【等待事件的响应】</p><p>—&gt; 阻塞挂起态 【内存不足】</p><p>—&gt; 结束态</p><p>—&gt; 创建态</p><p>阻塞挂起态 —&gt; 阻塞态 【内存有空闲】</p><p>—&gt; 就绪挂起态</p><p>就绪挂起态 —&gt; 就绪态 【内存有空闲】</p><h2 id="Q12：进程的控制"><a href="#Q12：进程的控制" class="headerlink" title="Q12：进程的控制"></a>Q12：进程的控制</h2><p>进程控制的主要功能是对系统中所有的进程实施有效的管理，包括创建新进程、撤销已有进程、进程状态转换等。</p><p>①进程的创建：</p><p>【父进程可以创建子进程、子进程可以继承父进程所拥有的全部资源、当子进程撤销时应当归还所有从父进程那所获得的资源、当父进程撤销时应当撤销其所有的子进程并将所拥有的资源归还给父进程或OS】</p><p>【引发事件：终端用户登录系统、作业调度、系统提供服务、用户程序的应用请求】</p><p>创建原语：</p><p>1) OS为进程分配一个唯一的PID，并申请一个空白的PCB（PCB数量有限，申请失败则创建失败）。</p><p>2)为进程分配资源，为新进程的程序、数据及用户栈分配必要的内存空间，若资源不足则处于阻塞态，等待资源。</p><p>3)初始化PCB，主要包括初始化标志信息、初始化处理机状态信息、初始化处理机控制信息、以及设置进程优先级。</p><p>4)若就绪队列可以容纳新进程，则将其插入队列，等待被调度。</p><p>②进程的终止：</p><p>【正常结束、异常结束（存储区越界、保护错、非法指令、特权指令错、算术运算错、I/O故障错等）、外界干预】</p><p>撤销原语：</p><p>1)根据结束进程的PID检索到对应的PCB，从中读出进程状态。</p><p>2)若进程处于运行状态，则立即终止该进程的执行，将CPU分配给其他进程。</p><p>3)若进程还有子孙进程，则应将所有子孙进程撤销。</p><p>4)将进程拥有的全部资源归还给父进程或OS。</p><p>5)将PCB从所在队列删除。</p><p>③进程的阻塞和唤醒：</p><p>阻塞原语：</p><p>1)找到要阻塞进程PID对应的PCB。</p><p>2)若该进程处于运行态，则保护其现场，将状态转换为阻塞态，停止运行。</p><p>3)将该PCB插入到相应等待事件的阻塞队列，并把处理机分配给其他进程。</p><p>唤醒原语：</p><p>1)在该事件对应的阻塞队列找到相应的PCB。</p><p>2)将其从等待队列移出，并置位就绪态。</p><p>3)将PCB插入到就绪队列，等待被调度执行。</p><p>④进程的切换：</p><p>通常情况下，进程的创建、撤销及要求OS所要完成的I/O操作，都是利用系统调用进入OS内核，然后由内核中相应程序完成。进程的切换也是在内核的支持下完成的。</p><p>1)保存处理机上下文，包括程序计数器和其他寄存器。</p><p>2)更新PCB信息。</p><p>3)把进程的PCB移入到相应的等待队列。</p><p>4)选择另一个进程执行，并更新其PCB。</p><p>5)更新内存管理的数据结构。</p><p>6)恢复处理机上下文。</p><h2 id="Q13：进程的组织"><a href="#Q13：进程的组织" class="headerlink" title="Q13：进程的组织"></a>Q13：进程的组织</h2><p>进程是一个独立运行的、独立分配资源和独立调度的基本单位。</p><p>①PCB</p><p>【进程创建时，OS为其新建一个PCB，该结构之后常驻于内存，任何时刻都可以存取，该进程结束时删除。是进程存在的唯一标志。】</p><p>【进程执行时，系统要根据进程的PCB来了解进程的现行状态信息，以便对其进行控制和管理】</p><p>【当OS要调度某进程执行时，首要要从该进程的PCB中读出其现行状态及优先级；在调度某进程后，要根据其PCB所保存的处理机状态信息，设置该进程的恢复运行现场，并根据其PCB中程序和数据的内存地址，找到对应的程序和数据；进程在运行的过程中要与与之合作的进程实现同步、通信和访问文件也要访问PCB；当进程由于某种原因暂停运行时，要将其断点的处理机现场信息保存到PCB中去】</p><p>1) 进程的描述信息</p><p>【PID（每个进程都有唯一的）、UID（进程的归属用户，主要用于保护和共享）】</p><p>2) 进程控制和管理信息</p><p>进程的当前状态信息、进程优先级、代码运行入口地址、程序的外存地址、进入内存的时间、处理机占用时间、信号量使用</p><p>3) 资源分配清单</p><p>【用于说明有关内存地址空间或虚拟地址空间的状况，打开的文件列表和所使用的的输入/输出设备信息】</p><p>代码段指针、数据段指针、堆栈段指针、文件描述符、键盘、鼠标</p><p>4) 处理机相关信息</p><p>【主要指CPU中各寄存器的值，当进程切换时，处理机状态信息必须保存到相应的PCB中，以便进程再重新运行可以恢复到断点处继续执行】</p><p>通用寄存器值、地址寄存器值、控制寄存器值、标志寄存器值、状态字</p><p>②程序段</p><p>能被进程调度程序调度到CPU执行的程序代码段。</p><p>③数据段</p><p>可以是进程对应程序加工处理的原始数据，也可以是程序执行时产生的中间或最终结果。</p><h2 id="Q14：进程的通信"><a href="#Q14：进程的通信" class="headerlink" title="Q14：进程的通信"></a>Q14：进程的通信</h2><p>进程通信是指进程之间的信息交换。P/V操作是低级通信方式，高级通信方式是指以较高效率传输大量数据的通信方式。</p><p>高级通信方式：</p><p>①共享存储</p><p>【在通信进程之间存在一块可以直接访问的共享空间，通过对这片共享空间的读/写操作实现进程间的信息交换。在对共享进行读/写操作时，要用到进程同步互斥工具】</p><p>1)基于数据结构的共享：低级方式</p><p>2)基于存储区的共享：高级方式</p><p>【OS只负责为通信进程提供可共享使用的存储空间以及同步互斥工具，而数据交换则是由用户自己安排读/写指令完成的】</p><p>【用户进程空间一般是独立的，进程运行期间一般是不能访问其他进程的空间，想实现进程间的通信，必须通过特殊的系统调用实现，而进程内的线程共享该进程的全部资源】</p><p>②消息传递</p><p>进程之间的数据交换是以格式化的消息为单位的。进程提供系统提供的发送和接收原语实现数据交换。</p><p>1) 直接通信方式：</p><p>【发送进程直接将消息发送给接收进程，并把它挂在接收进程的消息缓冲队列上，然后接收进程从其消息缓冲队列中取得消息】</p><p>2) 间接通信方式/信箱通信方式：</p><p>【发送进程将消息发送给某个中间实体（信箱），然后接收进程从其中取得消息】</p><p>③管道通信</p><p>是消息传递的一种特殊方式。</p><p>【管道pipe：是指用于连接一个读进程和一个写进程以及实现它们之间通信的一个共享文件】</p><p>【写进程以字符流形式将大量数据送入管道，读进程则从管道中接收数据】</p><p>【管道实际上是一个固定大小的缓冲区。Linux中其大小为4KB。从管道中读数据是一次性操作，数据一旦被读取就从管道中抛弃。管道通信只能采用半双工的通信方式，即某一时刻只能单向传输。】</p><p>【缓冲区只允许进程一边写入、一边读出。只有当写进程将缓冲区写满时，读进程才可以去读取。只有当读进程将数据全部从缓冲区中读出时，写进程才可以写入】</p><h2 id="Q15：线程及多线程模型"><a href="#Q15：线程及多线程模型" class="headerlink" title="Q15：线程及多线程模型"></a>Q15：线程及多线程模型</h2><p>①引入线程的目的：</p><p>​ 是为了更好地使多道程序并发执行，提高资源利用率及系统吞吐量。</p><p>​</p><p>②线程的概念：</p><p>线程是一个基本的CPU执行单元，也是程序流的一个最小单元，由线程ID、程序计数器、其他寄存器和堆栈构成。线程是系统调度的基本单位，它只拥有一点儿在程序中运行必不可少的资源，但它可以和同一个所属进程中的线程共享进程拥有的全部资源。</p><p>​ ③线程与进程的比较：</p><p>1) 调度：</p><p>对于传统的OS中，进程是OS进行调度和资源分配的基本单位；引入线程后，线程是OS进行调度的基本单位，进程是资源分配的基本单位。</p><p>同一个进程中的线程进行切换时，进程不会发生切换；但线程和其他进程中的线程发生切换时，进程发生切换。</p><p>2) 拥有资源：</p><p>不管是传统的OS，还是引入Thread之后的OS，进程都是系统进行资源分配的基本单位，而线程不拥有资源（只拥有一点儿必不可少的资源），但线程可以访问所属进程拥有的全部资源。</p><p>若线程也是资源分配的基本单位，那么在线程切换时就需要很大的时空开销，引入线程就几乎没有意义了。</p><p>3) 并发性：</p><p>引入线程的OS，不仅进程间可并发执行，多个线程也可并发执行，使OS具有更好的并发性，提高了系统的吞吐量。</p><p>4) 系统开销：</p><p>由于进程创建和撤销时，系统都要为之分配和回收资源，如内存空间、I/O设备等，因此系统所付出的时空开销远大于创建和撤销线程时的开销。</p><p>在进程进行切换时，涉及到当前执行进程的CPU环境保存以及新调度进程CPU环境的设置，而线程切换只需要保存和设置少量的寄存器内容，开销小。</p><p>由于进程的线程共享进程拥有的全部资源，因此进程内的线程通信容易实现，甚至无需系统的干预。</p><p>5) 地址空间和其他资源：</p><p>进程的地址空间之间相互独立（OS利用硬件地址机制对进程的地址空间进行了严格的保护），而进程内各线程共享进程的全部资源。</p><p>6) 通信：</p><p>进程间通行(IPC)需要借助进程的同步互斥工具，而线程之间通信可以直接读/写进程数据段来进行通信。</p><p>​</p><p>​ ④线程的实现方式：</p><p>1) 用户级线程(ULT)：</p><p>有关线程的管理（创建、撤销、切换等）的工作都是由应用程序完成的，内核意识不到线程的存在。应用程序可以通过使用线程库来设计多线程程序。通常，应用程序从单线程开始，在其运行的任意时刻，可以通过线程库中的派生例程创建一个同一进程内的线程。</p><p>2) 内核级线程(KLT)：</p><p>线程的管理工作都是由OS内核完成的，应用程序没有直接对线程进行管理的代码，只是有一个到内核级进程的接口。内核为进程内的各线程维护上下文信息，调度也是在内核基于线程结构的基础上完成。</p><p>​</p><p>​ ⑤多线程模型：</p><p>​ 有些系统同时支持ULT以及KLT。</p><p>1) 多对一模型：</p><p>多个ULT映射到一个KLT，ULT管理是在用户空间完成的，对OS透明。</p><p>【优点：线程管理是在用户空间进行的，因此效率比较高。】</p><p>【缺点：一个线程在使用内核服务时被阻塞，整个进程都会被阻塞，多个线程不能并行地运行在多个处理机上。】</p><p>2) 一对一模型：</p><p>一个ULT映射到一个KLT。</p><p>【优点：当一个线程被阻塞后，允许其他线程继续执行，并发能力强。】</p><p>【缺点：每创建一个ULT，都要创建一个KLT与之对应，这样创建线程的开销比较大，会影响到应用程序的性能。】</p><p>3) 多对多模型：</p><p>m个ULT映射到n个KLT（m&gt;=n）。</p><p>【特点：既克服了多对一模型并发度不高的缺点，又克服了一对一模型的一个ULT对应一个KLT开销大的缺点。同时具有两者的优点。】</p><h2 id="Q16：调度层次"><a href="#Q16：调度层次" class="headerlink" title="Q16：调度层次"></a>Q16：调度层次</h2><p>当系统中的作业/进程数高于当前可以进行执行的时候，就要涉及到调度。</p><p>一个从提交直到完成，往往要经历三级调度：</p><p>①作业调度/高级调度：</p><p>按照一定的调度原则从外存上处于后备状态的作业队列中挑选一个或多个作业，给它们创建相应进程，并且分配内存、输入/输出设备等必要资源，使之有竞争处理机的权利。</p><p>多道批处理系统中大多配有作业调度，而其他系统中通常不需要配置作业调度。作业调度执行的频率较低，通常为几分钟一次。</p><p>​</p><p>②内存调度/中级调度：</p><p>其作用是提高内存利用率和系统吞吐量。为此，把那些暂时不能运行的进程调至外存等待（把此时进程所处的状态称为挂起态），当它们具备了运行条件并且内存又稍有空闲时，由中级调度决定把那些外存上具备运行条件的就绪进程再重新调入内存，并修改为就绪态，挂在就绪队列上等待被调度。</p><p>③进程调度/低级调度：</p><p>是按照某种方法和策略从就绪队列中选取一个进程，并为之分配处理机。进程调度的频率很高，通常几十毫秒一次。</p><p>【进程调度和进程切换是OS内核程序进行操作的。】</p><p>l 在现代OS中，不能进行进程调度和切换的情况：</p><p>1) 在处理中断的过程中。</p><p>2) 进程在OS内核临界区中。</p><p>3) 其他需要完全屏蔽中断的原子操作过程中。</p><p>（若在上述条件下发生了进程调度请求，则应置请求调度标志，等上述情况结束后再进行进程的调度与切换）</p><p>l 在现代OS中，应该进行进程调度和切换的情况：</p><p>1) 发生引起调度的条件且当前进程无法继续执行下去的时候，可以马上进行进程调度与切换；（若OS只在这种情况下进行中级调度，则是实现非剥夺方式的调度）</p><p>2) 中断/异常处理结束后，返回被中断进程的用户态程序执行现场前，若置上请求调度标志，即可立马进行进程调度与切换。（若OS支持在这种情况下进行中级调度，则是实现了剥夺方式的调度）</p><p>【进程的切换往往在进程调度完成后立即发生，它要求保存原进程的当前切换点的现场信息，以及恢复被调进程的现场信息。现场切换时，OS内核将原进程的现场信息推入到当前进程的内核堆栈中，并更新堆栈指针】</p><p>【内核完成从新进程的内核栈中装入新进程的现场信息、更新当前运行进程空间指针、重设PC寄存器等相关工作后，开时运行新进程】</p><p>​</p><p>进程的调度方式：</p><p>（即当某个进程正在运行时，有个更为重要或紧迫的进程进入就绪队列时，此时如何分配处理机）</p><p>1) 非剥夺调度方式/非抢占方式：</p><p>继续运行，直至进程执行完或发生某种事件进入阻塞队列时，才将处理机分配给这个更为重要或紧迫的进程。</p><p>2) 剥夺调度方式/抢占方式：</p><p>立即停止执行当前运行进程，将处理机分配给这个更为重要或紧迫的进程。</p><p>【采用剥夺式的调度，对提高系统吞吐量以及响应效率都有明显好处。但“剥夺”不是一种任意行为，需要遵循一定原则，如：优先权、时间片、短进程优先等】</p><h2 id="Q17：调度的基本准则"><a href="#Q17：调度的基本准则" class="headerlink" title="Q17：调度的基本准则"></a>Q17：调度的基本准则</h2><p>①CPU利用率</p><p>CPU是系统最重要和昂贵的资源之一，应使得CPU总处于“忙”的状态，使得其资源利用率最高。</p><p>②系统吞吐量</p><p>表示单位时间内完成的作业数量。长作业需耗较长的处理机时间，因此会降低系统吞吐量；而短作业需要消耗的处理机时间短，会提高系统吞吐量。调度算法和方式的不同，也会对系统吞吐量产生较大的影响。</p><p>③周转时间</p><p>是指从作业提交到完成所经历的时间。</p><p>带权周转时间：是指作业的周转时间和实际运行时间的比值。</p><p>④等待时间</p><p>是指进程处于等待处理机状态的时间之和。</p><p>【处理机调度算法实际上并不影响作业执行或输入/输出操作的时间，只影响进程在就绪队列等待所花的时间。因此衡量一个低级调度算法，只需简单地考察等待时间即可。】</p><p>⑤响应时间</p><p>是指从用户提交请求到系统首次产生响应所用的时间。</p><p>【在交互式系统中，一般将响应时间作为衡量调度算法的重要依据之一。】</p><h2 id="Q18：典型的调度算法"><a href="#Q18：典型的调度算法" class="headerlink" title="Q18：典型的调度算法"></a>Q18：典型的调度算法</h2><p>①先来先服务调度算法FCFS</p><p>（适用于作业调度、进程调度）（不可剥夺算法）</p><p>在作业调度中，算法每次从后备队列中选择最先进入的一个或几个作业，把它们调入内存，为其分配必要的资源，创建进程并放入就绪队列。</p><p>在进程调度中，算法每次从就绪队列中选择最先进入该队列的进程，分配处理机使之运行，直至完成或因某事件而阻塞才释放处理机。</p><p>【特点：算法简单，但效率低；对长作业有利，对短作业不利（相对于SJF和高响应比优先）；有利于CPU繁忙型作业，不利于I/O繁忙型作业。】</p><p>​</p><p>②短作业/进程优先调度算法:</p><p>【平均等待时间、平均周转时间最少】</p><p>SJF从后备队列中选择一个或若干个估计运行时间最短的作业，把它们调入到内存运行。</p><p>SPF从就绪队列中选择一个估计运行时间最短的作业，把处理机分配给它，使之得以运行，直至完成或发生某事件而阻塞时才释放处理机。</p><p>【缺点：对长作业不利，有可能导致“饥饿”现象；未考虑作业的紧迫程度，不能保证紧迫作业及时处理；由于作业长短是依据用户提供的估计运行时间而定的，使得该算法不一定能够真正做到短作业优先调度。】</p><p>​</p><p>③优先级调度算法：</p><p>（适用于作业调度、进程调度）（适用于实时OS）</p><p>在作业调度中，该算法从作业后备队列中选择一个或若干个优先级最高的作业调入内存运行。</p><p>在进程调度中，该算法从就绪队列中选择一个优先级最高的进程，为之分配处理机，使之得以运行。</p><p>​</p><p>依据当某进程正在运行时，此时有更高优先级的进程进入就绪队列，此时如何分配处理机，可分为：</p><p>1) 非剥夺式优先级调度算法：</p><p>继续运行，直至进程执行完或发生某种事件进入阻塞队列时，才将处理机分配给这个更为重要或紧迫的进程。</p><p>2) 剥夺式优先级调度算法：</p><p>立即停止执行当前运行进程，将处理机分配给这个更为重要或紧迫的进程。</p><p>​</p><p>进程的优先级：</p><p>1) 静态优先级：</p><p>优先级是在创建进程时确定的，且在进程的整个运行期间保持不变。</p><p>设置的主要依据有进程类型、进程对资源的要求、用户要求。</p><p>2) 动态优先级：</p><p>在进程运行过程中，根据进程状态情况变化动态调整优先级。</p><p>设置的主要依据有进程占CPU时间长短、就绪进程等待CPU时间长短。</p><p>​</p><p>优先级设置参考原则：</p><p>系统进程 &gt; 用户进程</p><p>交互型进程 &gt; 非交互型进程</p><p>I/O型进程 &gt; CPU型进程</p><p>​</p><p>④高响应比优先调度算法：</p><p>（适用于作业调度）（适用于分时OS）</p><p>响应比：=（等待时间 +要求服务时间）/ 要求服务时间。</p><p>【作业等待时间相同时，要求服务时间越短，响应比越高，即有利于短作业；】</p><p>【要求服务时间相同时，等待时间越长，响应比越高，因而它实现的是FCFS；】</p><p>【对于长作业，作业的响应比可以随等待时间增加而提高，当等待时间足够长时，其响应比也很高，从而获得处理机得以运行。因此克服了“饥饿”，兼顾了长作业。】</p><p>⑤时间片轮转调度算法：</p><p>（适用于进程调度）（适用于分时OS）</p><p>在这种算法中，系统将所有就绪进程按照到达时间的先后次序排成一个队列，进程调度程序总是选择该队列中第一个进程执行，但只能执行一个时间片。</p><p>当使用完一个时间片后，即使该进程并未完成，也要释放处理机给下一个就绪进程，而被剥夺的进程返回该队列尾部重新排队，等待再次运行。</p><p>【若时间片足够大，以至于所有进程都可以在一个时间片内被执行完成，则该算法退化为FCFS。】</p><p>【若时间片很小，则处理机在进程间过于频繁切换，使得处理机开销增发，真正用于运行用户进程的时间将减少。】</p><p>【时间片长短影响因素：系统的响应时间、就绪队列的进程数目、系统处理能力。】</p><p>⑥多级反馈队列调度算法：</p><p>（适用于进程调度）（适用于分时OS）</p><p>1) 设置多个就绪队列，并为各个队列赋予不同的优先级，第1级队列优先级最高，其他队列优先级依次降低；</p><p>2) 赋予各个队列的时间片大小互不相同。在优先级越高的队列中，每个进程的运行时间片越小。</p><p>3) 一个新进程进入内存后，首先置于第1级队列的末尾，按照FCFS原则排队等待调度。当轮到该进程被调度时，若它能够在时间片内运行完成，则可准备撤销该进程；否则，调度程序将其置于第2级队列的末尾，同样按照FCFS的原则等待被调度。….如此下去，一个长进程从第1级队列降到第n级队列时，在第n级队列中按时间片轮转的方式执行。</p><p>4) 仅当第k级队列以及之前所有队列为空时，调度程序才调度第k+1级队列。若处理机正在执行第i级队列中的某个进程，这时有新进程进入到更高级别的队列中，则此时新进程将抢占正在运行进程的处理机，即调度程序将正在运行的进程置于第i级队列的末尾，然后将处理机分配给新到的更高优先级的进程。</p><p>【特点：终端型作业用户：短作业优先；短批处理作业用户：周转时间较短；长批处理作业用户：经过前面几个队列得到部分执行，不会长期得不到执行。】</p><p>​</p><h2 id="Q19：进程同步"><a href="#Q19：进程同步" class="headerlink" title="Q19：进程同步"></a>Q19：进程同步</h2><p>①为什么引入进程同步概念：</p><p>在多道程序环境下，不同进程之间存在着不同的相互制约关系，为了协调进程间的相互制约关系，引入了进程同步概念。</p><p>②临界资源及临界区：</p><p>临界资源：是指在同一时间段内只能由一个进程进行访问的资源。对临界资源的访问必须是互斥的。</p><p>临界区：是指进程中用于访问临界资源的那段代码。</p><p>③对临界资源的访问过程分为：</p><p>1) 进入区：</p><p>为了进入临界区使用临界资源，在进入区检查是否可进入临界区，若能进入则应设置正在访问临界区的标志，以避免其它进程同时进入临界区。</p><p>2) 临界区/临界段：</p><p>进程中用于访问临界资源的那段代码。</p><p>3) 退出区：</p><p>将正在访问临界区的标志清除。</p><p>4) 释放区：</p><p>代码其余部分。</p><p>④同步及互斥：</p><p>同步（直接制约关系）：</p><p>是指为了完成某种任务而创建的两个或多个进程，这些进程因为在某些位置上协调它们的工作次序、传递信息而产生的制约关系。</p><p>互斥（间接制约关系）：</p><p>是指当一个进程临界区访问临界资源时，其他想要访问该资源的进程必须等待，当该进程从临界区退出后，才允许进入临界区访问临界资源。</p><p>​</p><p>为了使进程互斥进入临界区，同步机制应遵循的原则：</p><p>1) 空闲让进：临界区空闲时，允许一个请求该资源的进程立即进入临界区。</p><p>2) 忙则等待：当已有进程进入临界区时，其他想要进入该临界区的进程等待。</p><p>3) 有限等待：对于请求访问的进程，应保证能在有限时间内进行响应。</p><p>4) 让权等待：当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</p><h2 id="Q20：实现临界区互斥的基本方法"><a href="#Q20：实现临界区互斥的基本方法" class="headerlink" title="Q20：实现临界区互斥的基本方法"></a>Q20：实现临界区互斥的基本方法</h2><p>①软件方法：</p><p>在进入区设置并检查一些标志来表明是否有进程在临界区中，若已有进程在临界区，则在进入区通过循环检查进行等待，进程离开临界区后在退出区修改标志。</p><p>1) 单标志检查法：</p><p>通过设置一个公用整型变量turn，用于指示被允许进入临界区的进程编号。该算法可确保每次只有一个进程被允许进入临界区。</p><p>但两个进程必须交替进入临界区，若某个进程不再进入临界区，那么另一个进程也将无法进入临界区（违背“空闲让进”），容易造成资源利用不充分。</p><p>…</p><p>PROCESS_P0:</p><p>while(turn != 0);</p><p>critical section;</p><p>turn = 1;</p><p>remainder section;</p><p>…</p><p>…</p><p>PROCESS_P1:</p><p>while(turn != 1);</p><p>critical section;</p><p>turn = 0;</p><p>remainder section;</p><p>…</p><p>​</p><p>2) 双标志先检查法:</p><p>该算法的思想是在进入临界区之前先检查临界资源是否被访问，若正在被访问则需等待，否则进入自己的临界区。</p><p>通过设置布尔型数据flag[i]，若为TRUE表示Pi进程进入临界区。优先：不用交替使用，可连续使用。缺点：两个进程可同时进入临界区（违背“忙则等待”）。</p><p>…</p><p>PROCESS_Pi:</p><p>while(flag[j]);</p><p>flag[i] = TRUE;</p><p>critical section;</p><p>flag[i] = FALSE;</p><p>remainder section;</p><p>…</p><p>…</p><p>PROCESS_Pj:</p><p>while(flag[i]);</p><p>flag[j] = TRUE;</p><p>critical section;</p><p>flag[j] = FALSE;</p><p>remainder section;</p><p>…</p><p>​</p><p>3) 双标志后检查法：</p><p>由于双标志先检查是先检查临界区是否正在被访问然后来设置自己的标志，因此有可能会导致检查完执行另一个进程，进而导致出现两个进程同时访问的情况。</p><p>因此，通过先设置自己标志然后在检查来避免这种情况的发生。</p><p>缺点：会出现两个进程都想进入临界区，由于互相相互谦让而导致都不能进入临界区，从而导致“饥饿”现象。</p><p>…</p><p>PROCESS_Pi:</p><p>flag[i] = TRUE;</p><p>while(flag[j]);</p><p>critical section;</p><p>flag[i] = FALSE;</p><p>remainder section;</p><p>…</p><p>…</p><p>PROCESS_Pj:</p><p>flag[j] = TRUE;</p><p>while(flag[i]);</p><p>critical section;</p><p>flag[j] = FALSE;</p><p>remainder section;</p><p>…</p><p>4) Peterson’s 算法</p><p>为了防止双标志后检查的两个进程无限期等待的情况发生，又设置了变量turn（不允许进入标志），每个进程在设置完自己的标志后再设置turn标志，这时再检查另一个进程的状态标志和不允许进入标志，以便两个进程同时请求进入临界区时，只允许一个进程进入。</p><p>…</p><p>PROCESS_Pi:</p><p>flag[i] = TRUE;turn = j;</p><p>while(flag[j] &amp;&amp; turn == j);</p><p>critical section;</p><p>flag[i] = FALSE;</p><p>remainder section;</p><p>…</p><p>…</p><p>PROCESS_Pj:</p><p>flag[j] = TRUE;turn = i;</p><p>while(flag[i] &amp;&amp; turn == i);</p><p>critical section;</p><p>flag[j] = FALSE;</p><p>remainder section;</p><p>…</p><p>②硬件方法：</p><p>计算机提供了特殊的硬件指令，允许对一个字进行检查和修正，或对两个字的内容进行交换等。通过硬件实现临界段问题的方法为低级方法/元方法。</p><p>1) 中断屏蔽：</p><p>当一个进程正在使用处理机执行它的临界区代码时，防止其他进程进入临界区进行访问的最简方法是，禁止一切中断的发生，即屏蔽中断。因为CPU只有在发生中断时引起进程切换，屏蔽中断可以让当前运行的进程让临界区代码顺利地执行完。</p><p>缺点：限制了处理机交替执行程序的能力；对于内核来说，在它执行更新变量或列表的几条指令期间，关中断是很方便的；但将关中断的权力交给用户则很不明智，当一个程序关中断后不再开中断，系统则很可能因此而终止。</p><p>…</p><p>关中断</p><p>临界区</p><p>开中断</p><p>…</p><p>​</p><p>2) 硬件指令方法：</p><p>TestAndSet指令：</p><p>这条指令是原子操作，及执行该代码时不可被中断。其功能是读出指定的标志后把该标志设置为真。</p><p>…</p><p>boolean TestAndSet(boolean *lock){</p><p>boolean old;</p><p>old = *lock;</p><p>*lock = true;</p><p>return old;</p><p>}</p><p>…</p><p>可以为每个临界资源设置一个共享布尔变量lock，表示资源的两种状态：true表示正被占用；初值为false。在进程进入临界区之前，通过该指令进行检查和修改标志lock，直至进程退出。</p><p>…</p><p>while(TestAndSet(&amp;lock));</p><p>critical section;</p><p>lock = false;</p><p>remainder section;</p><p>…</p><p>​</p><p>Swap指令：该指令的功能是交换两个字的内容。</p><p>…</p><p>Swap(boolean <em>a, boolean </em>b){</p><p>boolean temp;</p><p>temp = *a;</p><p><em>a = </em>b;</p><p>*b = temp;</p><p>}</p><p>…</p><p>可以为每个临界资源设置一个共享布尔变量lock，初值为false。在每个进程中设置一个局部布尔变量key，用于与lock交换信息。在进入临界区前，先利用该指令交换内容，然后检查key的状态。</p><p>…</p><p>key = true;</p><p>while(key != false){</p><p>Swap(&amp;lock,&amp;key);</p><p>}</p><p>critical section;</p><p>lock = false;</p><p>remainder section;</p><p>…</p><p>硬件方法的优点：</p><p>适用于任意数目的进程，而不管是处于单处理机还是多处理机；简单、容易验证其正确性；可以支持进程内有多个临界区，只需为每个临界区设立一个布尔变量。</p><p>缺点：进程等待进入临界区要耗费处理机时间，不能实现让权等待。从等待进程中随机选择一个进程进入临界区，有的进程可能一直选不上，从而导致出现“饥饿”现象。</p><p>③信号量：</p><p>信号量机制是一种功能较强的机制，可以用来解决互斥和同步问题。它只能被两个标准的原语进行访问（signal(S)、wait(S)）。</p><p>原语通常由硬件实现；原语的不可中断性在单处理机上可由软件通过屏蔽中断的方法实现。</p><p>1) 整型信号量：</p><p>被定义为一个用于表示资源数目的整型量S。</p><p>…</p><p>wait(S){</p><p>while(S &lt;= 0);</p><p>S = S - 1;</p><p>}</p><p>signal(S){</p><p>S = S + 1;</p><p>}</p><p>…</p><p>该机制并未遵循“让权等待”，而是使进程处于“忙等”状态。</p><p>​</p><p>2) 记录型信号量：</p><p>该机制是不存在“忙等”现象的，除了需要一个表示资源数目的整型变量value外，再增加一个进程链表L。</p><p>typedef struct{</p><p>int value;</p><p>struct process *L;</p><p>}semaphore;</p><p>…</p><p>void wait(semaphore S){</p><p>S.value—;</p><p>if(S.value &lt; 0){</p><p>add this process to S.L;</p><p>block(S.L);</p><p>}</p><p>}</p><p>…</p><p>…</p><p>void signal(semaphore S){</p><p>S.value++;</p><p>if(S.value &lt;= 0){</p><p>remove a process P from S.L;</p><p>wakeup(P);</p><p>}</p><p>}</p><p>…</p><p>​</p><p>3) 利用信号量实现同步、互斥、进程前驱关系</p><p>a. 实现同步：</p><p>操作A执行完再执行操作B；</p><p>semaphore S = 0;</p><p>…</p><p>PROCESS_Pa{</p><p>…</p><p>操作A;</p><p>V(S);</p><p>…</p><p>}</p><p>PROCESS_Pb{</p><p>…</p><p>P(S);</p><p>操作B;</p><p>…</p><p>}</p><p>…</p><p>​</p><p>b. 实现互斥：</p><p>临界资源数目为m;</p><p>semaphore S = m;</p><p>…</p><p>PROCESS_Pa{</p><p>…</p><p>P(S);</p><p>critical section;</p><p>V(S);</p><p>…</p><p>}</p><p>PROCESS_Pb{</p><p>…</p><p>P(S);</p><p>critical section;</p><p>V(S);</p><p>…</p><p>}</p><p>…</p><p>​</p><p>c. 实现前驱关系：</p><p>eg：P1-&gt;P2-&gt;P4; P1-&gt;P3-&gt;P4;</p><p>semaphore S_12=0,S_13=0,S_24=0,S_34=0;</p><p>…</p><p>PROCESS_P1{</p><p>…</p><p>V(S_12);</p><p>V(S_13);</p><p>}</p><p>PROCESS_P2{</p><p>P(S_12);</p><p>…</p><p>V(S_24);</p><p>}</p><p>PROCESS_P3{</p><p>P(S_13);</p><p>…</p><p>V(S_34);</p><p>}</p><p>PROCESS_P4{</p><p>P(S_24);</p><p>P(S_34);</p><p>…</p><p>}</p><p>…</p><p>④管程：</p><p>1) 引入管程目的：</p><p>在信号量机制中，每个访问临界资源的进程都必须自备同步的P/V操作，大量分散的同步机制给系统管理带来了麻烦，且容易因同步操作不当而导致系统死锁。</p><p>管程的特性保证了进程互斥，无需程序员自己实现互斥，从而降低了死锁发生的可能性。同时管程提供了条件变量，可以让程序员灵活地实现进程同步。</p><p>2) 管程(monitor)：</p><p>代表系统中共享资源的数据结构，以及对该共享数据结构实施操作的一组过程所组成的资源管理程序。</p><p>【管程对共享资源的操作封装起来；每次只允许一个进程进入管程，从而实现进程互斥。】</p><p>3) 管程的组成：</p><p>管程名字、局部于管程内部的共享数据结构说明、对该数据结构进行操作的一组过程、对局部于管程内部的共享数据设置初始化语句。</p><p>4) 条件变量：</p><p>当一个进程进入管程后发生阻塞，直到阻塞原因解除，在此期间若进程不释放管程，那么其他进程无法进入管程。因此，将阻塞的原因定义为条件变量condition。</p><p>通常，由于阻塞原因有多个，所以管程内部的条件变量也有多个，每个条件变量保存了一个队列，用于记录因此条件变量而阻塞的所有进程；对条件变量的操作只有两种wait和signal。</p><p>x.wait:</p><p>当x所对应的条件不满足时，正在调用管程的进程调用x.wait将自己插入到x条件的等待队列，并释放管程。此时其他进程可以使用管程。</p><p>x.signal:</p><p>x对应的条件发生了变化，则调用x.signal，唤醒一个因x条件而被阻塞的进程。</p><p>5) 信号量 &amp; 条件变量：</p><p>相似点：条件变量的wait/signal操作类似于信号量的P/V操作，可以实现进程的阻塞与唤醒；</p><p>不同点：条件变量仅实现了“排队功能”功能；而信号量的值反应了剩余资源数目，而在管程中用共享数据结构记录剩余资源数目。</p><p>…</p><p>monitor demo{</p><p>共享数据结构S；</p><p>condition x;</p><p>init_code{…};</p><p>take_away(){</p><p>if(S&lt;=0) x.wait();</p><p>资源足够，分配资源，做相应处理；</p><p>}</p><p>give_back(){</p><p>归还资源，作相应处理；</p><p>if(有进程在等待) x.signal();</p><p>}</p><p>}</p><p>…</p><h2 id="Q21：经典同步问题"><a href="#Q21：经典同步问题" class="headerlink" title="Q21：经典同步问题"></a>Q21：经典同步问题</h2><p>①生产者-消费者问题</p><p>Que1: 一组生产者和一组消费者进程共享一个初始为空、大小为n的缓冲区。只有当缓冲区未满时，生产者才可以将消息放入缓冲区；只有当缓冲区未空时，消费者才可以把消息从缓冲区取出。由于缓冲区是临界资源，它只允许一个生产者放入消息，或一个消费者取出消息。</p><p>​</p><h6><a href="#" class="headerlink" title="#"></a>#</h6><p>semaphore mutex = 1; //临界区互斥信号量</p><p>semaphore empty = n; //空闲缓冲区</p><p>semaphore full = 0; //缓冲区初始化为空</p><p>produce(){</p><p>while(1){</p><p>produce a product of A;</p><p>P(empty);</p><p>P(mutex);</p><p>add A to buffer;</p><p>V(mutex);</p><p>V(full);</p><p>}</p><p>}</p><p>consumer(){</p><p>while(1){</p><p>P(full);</p><p>P(mutex);</p><p>remove A from buffer;</p><p>V(mutex);</p><p>V(empty);</p><p>}</p><p>}</p><h6 id="-1"><a href="#-1" class="headerlink" title="#"></a>#</h6><p>​</p><p>Que2: 一个盘子只能放一个水果，爸爸只放apple，妈妈只放orange，儿子只拿orange，女儿只拿apple。</p><p>​ ################</p><p>semaphore plate = 1; //对盘子临界资源互斥访问 //对应Que1中的mutex及empty</p><p>semaphore apple = 0; //对应Que1中的full</p><p>semaphore orange = 0; //对应Que1中的full</p><p>PROCESS_papa(){</p><p>…</p><p>P(plate);</p><p>put an apple on the plate;</p><p>V(apple);</p><p>…</p><p>}</p><p>PROCESS_mom(){</p><p>…</p><p>P(plate);</p><p>put an orange on the plate;</p><p>V(orange);</p><p>…</p><p>}</p><p>PROCESS_son(){</p><p>…</p><p>P(orange);</p><p>take the orange from the plate;</p><p>V(plate);</p><p>…</p><p>}</p><p>PROCESS_daughter(){</p><p>…</p><p>P(apple);</p><p>take the apple from the plate;</p><p>V(plate);</p><p>…</p><p>}</p><h6 id="-2"><a href="#-2" class="headerlink" title="#"></a>#</h6><p>②吸烟者问题</p><p>Que: 假设一个系统有三个吸烟者进程和一个供应者进程。每个吸烟者不停地卷烟并抽掉他。卷烟需要三种材料：烟草、纸、胶水。三个吸烟者中，第一个有烟草、第二个有纸、第三个有胶水。供应者无限地提供三种材料，每次将两种材料放在桌子上，拥有剩下一种的吸烟者拿起材料，卷烟并抽掉他，并给供应者一个信号告诉已完成，此时供应者就会将另外两种材料放在桌子上。</p><h6 id="0"><a href="#0" class="headerlink" title="## 0"></a>## 0</h6><p>int num = 0;</p><p>semaphore offer1 = 0;</p><p>semaphore offer2 = 0;</p><p>semaphore offer3 = 0;</p><p>semaphore finish = 0; //完成信号量</p><p>PROCESS_P0(){ //供应者</p><p>while(1){</p><p>num++;</p><p>num = num % 3;</p><p>if(num == 0)</p><p>V(offer1);</p><p>if(num == 1)</p><p>V(offer2);</p><p>if(num == 2)</p><p>V(offer3);</p><p>P(finish);</p><p>}</p><p>}</p><p>PROCESS_P1(){</p><p>while(1){</p><p>P(offer1);</p><p>拿起纸、胶水，卷烟并抽掉；</p><p>V(finish);</p><p>}</p><p>}</p><p>PROCESS_P2(){</p><p>while(1){</p><p>P(offer2);</p><p>拿起烟草、胶水，卷烟并抽掉；</p><p>V(finish);</p><p>}</p><p>}</p><p>PROCESS_P3(){</p><p>while(1){</p><p>P(offer3);</p><p>拿起烟草、纸，卷烟并抽掉；</p><p>V(finish);</p><p>}</p><p>}</p><h6 id="-3"><a href="#-3" class="headerlink" title="#"></a>#</h6><p>③读者/写者问题</p><p>Que: 读者、写者两组进程共享一个文件。要求：允许多个读者可以同时对文件进行读操作、只允许一个写者往文件中写信息、任一写者在完成写操作之前不允许其他读/写进程工作、写者执行写操作之前其他已有的读者和写者应全部退出。</p><h6 id="0-1"><a href="#0-1" class="headerlink" title="## 0"></a>## 0</h6><p>int count = 0; //记录当前读者数量</p><p>semaphore mutex = 1; //用于保护和更新count变量时的互斥</p><p>semaphore rw = 1; //用于实现读/写的互斥</p><p>writer(){</p><p>​ while(1){</p><p>​ P(rw);</p><p>​ writing;</p><p>​ V(rw);</p><p>​ }</p><p>}</p><p>reader(){</p><p>​ while(1){</p><p>​ P(mutex);</p><p>​ count++;</p><p>​ if(count == 1)</p><p>​ P(rw);</p><p>​ V(mutex);</p><p>​ reading;</p><p>​ P(mutex);</p><p>​ count—;</p><p>​ if(count == 0)</p><p>​ V(rw);</p><p>​ V(mutex);</p><p>​ }</p><p>}</p><h6 id="-4"><a href="#-4" class="headerlink" title="#"></a>#</h6><p>上述的算法中，读进程是优先，即存在读进程时，写进程将被延迟，若至少有一个的读进程活跃，那么随后的写进程都将被阻塞，有可能出现写进程“饿死”情况。</p><h6 id="1"><a href="#1" class="headerlink" title="## 1"></a>## 1</h6><p>int count = 0; //记录当前读者数量</p><p>semaphore mutex = 1; //用于保护和更新count变量时的互斥</p><p>semaphore rw = 1; //用于实现读/写的互斥</p><p>semaphore w = 1; //</p><p>writer(){</p><p>​ while(1){</p><p>​ P(w);</p><p>​ P(rw);</p><p>​ writing;</p><p>​ V(rw);</p><p>​ V(w); //恢复对共享文件的访问</p><p>​ }</p><p>}</p><p>reader(){</p><p>​ while(1){</p><p>​ P(w);</p><p>​ P(mutex);</p><p>​ count++;</p><p>​ if(count == 1)</p><p>​ P(rw);</p><p>​ V(mutex);</p><p>​ V(w); //恢复对共享文件的访问</p><p>​ reading;</p><p>​ P(mutex);</p><p>​ count—;</p><p>​ if(count == 0)</p><p>​ V(rw);</p><p>​ V(mutex);</p><p>​ }</p><p>}</p><h6 id="-5"><a href="#-5" class="headerlink" title="#"></a>#</h6><p>​</p><p>④哲学家进餐问题</p><p>Que：5名哲学家围着一个圆桌而坐，两人之间仅有一只筷子，哲学家只做两件事：think and eat，且当拿起左右两只筷子时才能吃饭。</p><h6 id="0-2"><a href="#0-2" class="headerlink" title="## 0"></a>## 0</h6><p>semaphore chopstick[5] = {1,1,1,1,1};</p><p>professor_i(){</p><p>​ while(1){</p><p>​ P(chopstick[i]); //拿左手筷子</p><p>​ P(chopstick[(i+1)%5]); //拿右手筷子</p><p>​ eat;</p><p>​ V(chopstick[i]);</p><p>​ V(chopstick[(i+1)%5]);</p><p>​ think;</p><p>​ }</p><p>}</p><h6 id="-6"><a href="#-6" class="headerlink" title="#"></a>#</h6><p>当所有哲学家拿起左手筷子，就会出现死锁。</p><p>解决方案：</p><p>1) 限制最多4人同时进餐；</p><p>2) 限制只有当可以拿起左右两只筷子时才允许拿起；</p><p>3) 限制奇数号哲学家先拿左手筷子，偶数号先拿右手筷子；</p><p>​</p><h6 id="1-1"><a href="#1-1" class="headerlink" title="## 1"></a>## 1</h6><p>semaphore chopstick[5] = {1,1,1,1,1};</p><p>​ semaphore S = 4;</p><p>​ professor_i(){</p><p>​ while(1){</p><p>​ P(S);</p><p>​ P(chopstick[i]); //拿左手筷子</p><p>​ P(chopstick[(i+1)%5]); //拿右手筷子</p><p>​ eat;</p><p>​ V(chopstick[i]);</p><p>​ V(chopstick[(i+1)%5]);</p><p>​ V(S);</p><p>​ think;</p><p>​ }</p><p>​ }</p><p>​ ###################</p><p>​ ######## 2 ########</p><p>​ semaphore chopstick[5] = {1,1,1,1,1};</p><p>​ semaphore mutex = 1; //设置取筷子信号量</p><p>​ professor_i(){</p><p>​ while(1){</p><p>​ P(mutex);</p><p>​ P(chopstick[i]); //拿左手筷子</p><p>​ P(chopstick[(i+1)%5]); //拿右手筷子</p><p>​ V(mutex);</p><p>​ eat;</p><p>​ V(chopstick[i]);</p><p>​ V(chopstick[(i+1)%5]);</p><p>​ think;</p><p>​ }</p><p>​ }</p><p>​ ###################</p><p>​ ######## 3 ########</p><p>​ semaphore chopstick[5] = {1,1,1,1,1};</p><p>​ professor_i(){</p><p>​ while(1){</p><p>​ if(i%2 == 1)</p><p>​ P(chopstick[i]);</p><p>​ P(chopstick[(i+1)%5]);</p><p>​ else</p><p>​ P(chopstick[(i+1)%5]);</p><p>​ P(chopstick[i]);</p><p>​ eat;</p><p>​ V(chopstick[i]);</p><p>​ V(chopstick[(i+1)%5]);</p><p>​ think;</p><p>​ }</p><p>​ }</p><p>​ ###################</p><p>与贪心算法比较：</p><p>贪心算法强调争取眼前最好的情况，而哲学家进餐问题不仅考虑眼前一步，还考虑下一步。若该问题用贪心算法解决，即只要眼前有筷子就拿起的话，有可能会导致死锁。</p><p>​</p><h2 id="Q22：死锁"><a href="#Q22：死锁" class="headerlink" title="Q22：死锁"></a>Q22：死锁</h2><p>①死锁：</p><p>是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。</p><p>②产生的原因：</p><p>1) 系统资源的竞争。</p><p>【只有对不可剥夺资源进行竞争时才有可能产生死锁，对可剥夺资源的竞争是不会产生死锁的。】</p><p>2) 进程推进顺序不当。</p><p>进程运行过程中，对资源的请求和释放顺序不当；信号量使用不当。</p><p>​</p><p>③死锁产生的必要条件：</p><p>1) 互斥条件：进程对所分配的资源进行排他控制。</p><p>2) 不剥夺条件：进程所获的资源在未使用完之前，不能被其他进程剥夺，即只能由获得该资源的进程主动释放。</p><p>3) 请求并保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源被其他进程所占有，此时进程被阻塞，但不释放自己所获得的资源。</p><p>4) 循环等待条件：存在一种进程资源的循环等待链。</p><p>【资源分配图含圈但不一定有死锁的原因是，同类资源数目大于1。若系统中每类资源都只有一个，则资源分配图含圈就成了系统出现死锁的充要条件。】</p><p>​</p><p>④死锁的处理策略：</p><p>1) 死锁预防：</p><p>防止死锁的发生只需破坏死锁产生的4个必要条件之一即可。</p><p>a. 破坏互斥条件</p><p>若所有的系统都能共享使用，则系统自然不会进入死锁状态，但有些资源只能互斥使用，不能同时使用，因此此方案不太可行，而且在某些场合下应该保护这种互斥性。</p><p>b. 破坏不剥夺条件</p><p>即当已保持资源的进程请求新资源时而得不到满足时，它必须释放掉所拥有的全部资源，待以后需要时再次重新申请。</p><p>【释放已获得的资源可能造成前一阶段的工作失效，反复地申请和释放资源会增加系统的开销，降低系统吞吐量。这种方法常用状态易保存和修复的资源，如CPU的寄存器及内存资源，一般不能用于打印机之类的资源。】</p><p>c. 破坏请求并保持条件</p><p>采用预先静态分配方法，即在进程运行之前一次申请完所需要的全部资源，在运行期间这些资源归他所有，不能提出其他资源请求。</p><p>【系统资源被严重浪费，有些资源有可能只在开始或快结束时才用到；而且还会导致“饥饿”现象，个别资源长期被其他进程占用，导致等待该资源的进程迟迟不能开始运行。】</p><p>d. 破坏循环并等待条件</p><p>采用按顺序资源分配法。首先给系统中的资源编号，规定进程按编号递增的顺序请求资源，同类资源一次申请完。</p><p>【限制新类型设备的增加；尽管在编号时考虑到大多作业使用这些资源的顺序，但也经常会发生作业使用资源顺序和系统规定顺序不同情况，造成资源浪费；不利于用户编程。】</p><p>2) 避免死锁：</p><p>在资源动态分配过程中，防止进程进入不安全状态，以避免发生死锁。</p><p>【系统安全状态：是指系统按照某种进程顺序推进时为每个进程分配其所需的资源，直至满足每个进程对资源最大的最大需求，使得每个进程都可顺序完成。</p><p>【称此时的进程序列为一个安全序列，若系统找不到这样的一个安全序列，则系统处于不安全状态。】</p><p>【并不是所有的不安全状态都是死锁状态，只是不安全状态有可能发生死锁，即安全状态一定不会发生死锁。】</p><p>​</p><p>银行家算法：</p><p>设Request_i是进程P_i的请求向量，“Request_i[j]=K”表示P_i进程申请j类资源K个，当P_i发出请求后，系统按以下步骤检查：</p><p>a) 若Request_i[j] &lt;= Need[i,j]，转b)；否则认为出错，因为所需要的的资源数超出所声明的最大数目。</p><p>b) 若Request_i[j] &lt;= Available[i,j]，转b)；否则，表示尚无足够资源，P_i等待。</p><p>c) 系统试探着把资源分配给P_i进程，并修改：</p><p>Available = Available - Request_i;</p><p>Allocation[i,j] = Allocation[i,j] + Request_i[j];</p><p>Need[i,j] = Need[i,j] - Request_i[j];</p><p>d) 系统执行安全性算法，检查此次分配后系统是否处于安全状态。若安全，则系统正式将资源分配给P_i进程；否则，将本次试探分配作废，让P_i进程等待。</p><p>安全性算法：</p><p>设置工作向量Work，有m个元素，表示系统中剩余可用资源数目。在执行算法开始时，置Work = Available。</p><p>a) 初始时安全序列为空。</p><p>b) 从Need矩阵中找出符合下面条件的行：该行对应的进程不再安全序列里面，而且该行小于等于Work向量。找到后则把对应进程加入到安全序列，否则执行d)。</p><p>c) 进程P_i进入安全序列后，可顺利执行，直至完成，并释放分配给它的资源。执行Work = Work + Allocation[i]。</p><p>d) 若此时安全序列已有所有进程则系统处于安全状态，否则处于不安全状态。</p><p>​</p><p>3) 死锁的检测并解除：</p><p>a) 资源分配图：</p><p>一个圆圈代表一个进程，一个框代表一类资源，框中的一个圆圈代表一个资源，从资源到进程的有向边表示该类资源的一个已分配给进程，从进程到资源的有向边表示该进程申请一个该类资源。</p><p>【简化资源分配图：在资源分配图中，找出既不阻塞又不孤点的进程P_i，小区它的所有请求边和分配边，使之成为孤立的结点。然后进程P_i所释放资源，可唤醒某些因等待这些资源而阻塞的进程。继续执行此过程。】</p><p>​</p><p>b) 死锁定理：</p><p>S为死锁的条件是当且仅当S状态的资源分配图是不可完全简化的。</p><p>c) 死锁解除：</p><p>i) 资源剥夺法：</p><p>挂起某些死锁进程，并抢占它的资源，分配给其他的死锁进程。</p><p>【但应防止被挂起进程长时间得不到资源而处于资源匮乏的状态。</p><p>ii) 撤销进程法：</p><p>强制撤销部分甚至所有死锁进程。</p><p>【撤销原则可以按进程优先级和撤销进程代价高低进行。】</p><p>iii) 进程回退法：</p><p>让一个或多个进程回退到足以回避死锁的地步，进程回退时主动释放资源而非被剥夺。</p><p>【要求保持进程的历史信息，设置还原点。】</p><p>​</p><p>⑤“饥饿”&amp;死锁：</p><p>死锁是多个进程因抢占互斥资源而产生无终止的循环等待，“饥饿”是指系统对于资源的分配不公平时，某些进程因得不到资源而长期等待。（当“饥饿”到一定程度的进程即使完成任务也无意义时，称该进程被“饿死”。）</p><p>进入“饥饿”状态的进程可以只有一个，而因循环等待条件进入死锁状态的进程至少是两个；</p><p>处于“饥饿”状态的进程可以是一个就绪进程，而处于死锁的进程必定是阻塞进程。</p><h2 id="Q23：作业-amp-进程"><a href="#Q23：作业-amp-进程" class="headerlink" title="Q23：作业 &amp; 进程"></a>Q23：作业 &amp; 进程</h2><p>进程是系统资源的使用者，系统的大部分资源是以进程为单位分配的。而用户使用计算机是完成一串相关的任务，通常将用户要求计算机完成的这一串任务称为作业。</p><p>①批处理系统中作业和进程的关系：</p><p>批处理系统通过 磁记录或卡片机 向系统提交批作业，由系统的 SPOOLing输入进程 将作业放入磁盘的 输入井，作为后备作业。</p><p>作业调度程序（一般也作为独立的进程运行）每当选择一道后备作业运行时，首先为该作业创建一个进程（称为该作业的根进程）。</p><p>该进程将执行作业控制语言解释程序，解释该作业的作业说明书。父进程在运行过程中可以动态地创建一个或多个子进程，执行说明书中的语句。因此，一个作业就动态转化为一组运行实体——进程族。</p><p>当父作业遇到作业说明书中的“撤出作业”语句时，将该作业从运行态改为完成态，将作业及相关作业输出送至磁盘的输出井。</p><p>作业终止进程将输出井中的作业利用打印机输出，回收作业所占用的资源，删除作业有关的数据结构，删除作业在磁盘输出井中的信息等。</p><p>作业终止进程撤除一道作业后，可向作业调度程序请求进行新的作业调度。</p><p>​</p><p>②分时系统中作业和进程的关系：</p><p>分时系统的用户通过命令语言逐条与系统应答式地输入命令，提交作业。每输入一条/组命令，就对应系统内部的一个/若干进程。</p><p>在系统启动时，系统为每个终端设备建立一个进程（称终端进程），该进程执行命令解释程序，命令解释程序从终端设备读入指令，解释执行用户输入的每条指令。</p><p>对于每条终端命令，可以创建一个子进程去具体执行。若当前的终端命令是一条后台命令，则可以和下一条终端命令并行处理。</p><p>终端命令对应的进程结束后，所有的终端命令也相应的执行完毕。用户通过一条登出命令立即结束上机过程。</p><p>​</p><p>③交互式的提交批作业：</p><p>在同时支持交互和批处理的系统中，通过一条提交命令将作业提交到作业队列，然后由系统中专门的调度程序负责选择一个作业、为其创建一个父进程运行命令解释程序，解释执行作业控制说明书文件中的命令</p><h1 id="CHAPTER-3"><a href="#CHAPTER-3" class="headerlink" title="CHAPTER 3"></a>CHAPTER 3</h1><h2 id="Q24：内存管理概念及功能"><a href="#Q24：内存管理概念及功能" class="headerlink" title="Q24：内存管理概念及功能"></a>Q24：内存管理概念及功能</h2><p>内存管理就是对内存进行合理的划分以及有效的动态分配。</p><p>​</p><p>内存管理的功能：</p><p>​ 内存空间的分配与回收</p><p>​ 地址转换 【在多道环境下，程序中的逻辑地址和物理地址有可能不同】</p><p>​ 内存空间扩充【利用虚拟存储技术或自动覆盖技术对内存进行扩充】</p><p>​ 存储保护 【保证各道程序在各自的存储空间中运行，互不干扰】</p><p>​</p><h2 id="Q25：程序的链接和装入"><a href="#Q25：程序的链接和装入" class="headerlink" title="Q25：程序的链接和装入"></a>Q25：程序的链接和装入</h2><p>将用户源程序变为内存中可以执行的程序需经历：</p><p>n 编译：</p><p>【由编译程序将用户源代码编译为若干个目标模块】</p><p>【各个目标模块的逻辑地址都从0开始】</p><p>n 链接：</p><p>【由链接程序将编译后的若干个目标模块以及所需的库函数链接在一起，形成一个完整的装入模块】</p><p>【整合各个目标模块逻辑地址，装入模块的逻辑地址以0开始】</p><p>n 装入：</p><p>【由装入程序将装入模块装入内存运行】</p><p>​</p><p>链接的方式：</p><p>​ ①静态链接：</p><p>【在程序运行之前，将各目标模块和所需的库函数链接成一个完整的装入模块，此后不再拆开】</p><p>​ ②装入时动态链接：</p><p>【将各目标模块在装入时采用边链接边装入的方式】</p><p>​ ③运行时动态链接：</p><p>【对于某些目标模块的链接，是在程序执行中需要目标模块时进行的】</p><p>【优点：便于修改与更新，实现对目标模块的共享】</p><p>​</p><p>装入的方式：</p><p>​ ①绝对装入：</p><p>【在编译时，若知道程序将驻留在内存的某个位置，则编译程序将产生绝对地址的目标代码】</p><p>【绝对装入程序按照模块中的地址将程序和数据装入内存】</p><p>【只适用于单道程序环境】</p><p>【程序中所用的绝对地址，可在编译或汇编时给出，也可由程序员直接赋予。通常情况下，程序中采用的是符号地址，在编译或汇编时在转为绝对地址】</p><p>②静态重定位装入/可重定位装入：</p><p>【在多道程序环境下，多个目标模块的起始地址通常是从0开始，程序中其他地址都是相对于始址而言的，此时应采用可重定位装入方式】</p><p>【重定位：是指在装入目标程序时对其的程序与数据的修改】</p><p>【静态：是指地址转换是在装入时一次性完成的】</p><p>【特点：一个作业装入内存时，必须给它分配它所要求的全部内存空间，若没足够的内存则不装入。作业一旦进入内存，在整个运行期间不能在内存中移动，也不能再申请内存空间】</p><p>③动态重定位装入/动态运行时装入：</p><p>【装入程序装入装入模块后，并不立即把装入模块的相对地址变换成绝对地址，这种变换推迟到程序真正要执行时才进行】</p><p>【需要一个重定位寄存器的支持】</p><p>【特点：可以将程序分配到不连续的存储区中；在程序运行前装入它的部分代码即可运行，然后在运行期间，根据需要动态申请分配内存；便于程序段的共享，可以向用户提供一个比实际存储空间大的多的地址空间】</p><p>​</p><h2 id="Q26：逻辑地址空间-amp-物理地址空间"><a href="#Q26：逻辑地址空间-amp-物理地址空间" class="headerlink" title="Q26：逻辑地址空间&amp;物理地址空间"></a>Q26：逻辑地址空间&amp;物理地址空间</h2><p>编译后，各目标模块都是从0号单元开始编址（即相对地址/逻辑地址）。</p><p>链接程序将各个目标模块链接成一个完整的可执行目标程序时，链接程序顺序依次序按各个模块的相对地址构成统一的从0号单元开始的逻辑地址空间。</p><p>【内存管理的具体机制对应用程序和用户完全透明】</p><p>【不同进程可以有相同的逻辑地址】</p><p>​</p><p>物理地址空间是指内存中物理单元集合。</p><p>【进程在运行时执行指令和访问数据，最后都要通过物理地址从内存中存取】</p><p>【地址重定位：当装入程序将可执行代码装入内存时，必须通过地址转换将逻辑地址变换为物理地址】</p><p>​</p><h2 id="Q27：内存保护"><a href="#Q27：内存保护" class="headerlink" title="Q27：内存保护"></a>Q27：内存保护</h2><p>内存分配前，需要保证OS不受用户进程的影响，同时保护用户进程不受其他用户进程的影响。内存保护采用办法：</p><p>①在CPU上设置一对上、下限寄存器，存放用户作业在内存中下限、上限地址；每当CPU要访问一个地址时，分别和两寄存器值相比，判断是否越界。</p><p>②采用重定位寄存器/基地址寄存器和界地址寄存器/限长寄存器。</p><p>【重定位寄存器含最小的物理地址值，界地址寄存器含最大的逻辑地址值】</p><p>【内存管理机构动态地将逻辑地址和界地址寄存器进行比较，若未发生地址越界，则加上重定位寄存器中值映射成物理地址，再送交内存单元】</p><p>​</p><h2 id="Q28：覆盖-amp-交换"><a href="#Q28：覆盖-amp-交换" class="headerlink" title="Q28：覆盖&amp;交换"></a>Q28：覆盖&amp;交换</h2><p>覆盖和交换是在多道环境下扩充内存的两种办法。</p><p>覆盖的基本思想： 【同一进程内】 【对用户或程序员不透明】</p><p>由于程序运行时并非任何都要访问程序及数据的各个部分，因此可以将用户空间划分成一个固定区和若干个覆盖区。将经常活跃的部分放在固定区，其余部分按调用关系分段。首先将那些即将访问的段放入覆盖区，其他段放到外存，在需要调用时，系统再将其从外存调入覆盖区，替换覆盖区原有的段。</p><p>特点：</p><p>打破了一个必须将一个进程的全部信息全部装入内存才能运行的限制，但当同时运行程序的代码量大于内存时依然不能运行，另外内存中能够更新的只有覆盖区，其他中的段将会常驻内存。</p><p>​</p><p>交换/对换的基本思想：【不同进程间】</p><p>换出：把处于等待状态（或在CPU调度原则下被剥夺运行权利）的程序从内存移出到辅存，腾出内存空间。</p><p>换入：把准备好竞争CPU运行的程序从辅存移入内存。</p><pre><code>交换注意问题：
</code></pre><p>①交换需要备份存储，通常是快速磁盘。它必须足够大，并提供对这些内存映像的直接访问。</p><p>②为了有效使用，需要使进程的执行时间比交换时间长。影响交换时间的主要是转移时间，转移时间和所交换的内存空间成正比。</p><p>③若换出进程，必须保证该进程完全处于空闲状态。</p><p>④交换空间通常作为磁盘的一整块，且独立于文件系统，因此使用起来比较快。</p><p>⑤交换通常在有许多进程运行且内存吃紧时启动，在内存有了空闲时暂停。</p><h2 id="Q29：连续分配管理方式"><a href="#Q29：连续分配管理方式" class="headerlink" title="Q29：连续分配管理方式"></a>Q29：连续分配管理方式</h2><p>①单一连续分配：</p><p>【内存在此方式下分为系统区和用户区；系统区供OS使用，通常在低地址部分；用户区是为用户提供的内存空间】</p><p>【内存中永远只有一道程序，因此无需内存保护】</p><p>【优点：简单、无外部碎片，可以采用覆盖技术，不需要额外的技术支持】</p><p>【缺点：只能用于单用户、单任务的OS中，有内部碎片，存储器利用率极低】</p><p>②固定分区分配：</p><p>【存在内零头，不能实现多进程共享一个主存区】</p><p>【最简单的一种多道程序存储管理方式】</p><p>【它将用户内存空间划分成若干大小固定的区域，每个区只能装入一道作业】</p><p>【当有空闲分区时，从外存的后备队列中选择合适大小的作业装入分区】</p><p>​</p><p>划分分区的方法：</p><p>分区大小相等：</p><p>【用于利用一台计算机去控制相同对象的场合，灵活性差】</p><p>分区大小不等：</p><p>【划分多个较小分区、适量中等分区、少量大分区】</p><p>【为了便于内存分配，通常将分区按大小排队，并为之建立一张分区说明表，表项包括：分区号、分区大小、分区始址、分区状态】</p><p>【当有用户程序装入时，检索该表，以便找到合适分区并给予分配并设置状态为“已分配”，未找到时拒绝该程序的装入】</p><p>​</p><p>存在问题：</p><p>①程序可能太大而放不进任何一个分区，此时用户不得不使用覆盖技术来使用内存空间。</p><p>②程序小于固定分区大小，则存在内部碎片，这样分区内存存在浪费。</p><p>③动态分区分配/可变分区分配：【存在外零头】</p><p>不预先划分内存，而是在进程装入内存时，根据进程大小动态的创立分区，并使分区大小正好符合进程的需要。</p><p>【动态分区分配会出现很多小的外零头，通过紧凑compaction技术解决，即OS不时的对进程进行移动和整理。需要动态重定位寄存器支持，且相对费时。】</p><p>在进程装入或换入内存时，若内存有多个足够大小的空闲块，则OS应确定将哪个内存块分给进程使用：【找到第一个符合要求空闲分区】</p><p>①首次适应算法FF：【空闲分区以地址递增的次序链接】</p><p>②最佳适应算法BF：【空闲分区以容量递增的次序链接】</p><p>③最坏适应算法WF/最大适应算法LF：【空闲分区以容量递减的次序链接】</p><p>④邻近适应算法NF/循环首次适应算法：【分配时从上次查找结束的位置开始查找】</p><p>算法比较：</p><p>FF是最简单的，通常也是最好、最快的。但是FF会使内存低地址部分出现很多小的空闲分区，而每次查找的时候都要经过这些分区，增加了查找的开销。</p><p>NF试图解决FF的问题，但它常常导致内存的末尾空间分裂成小碎片（在一遍扫描中，内存前面部分分配后释放，不会参与分配），它通常比FF性能差。</p><p>BF性能通常很差，因为每次最佳分配会留下很小的碎片，会产生很多的内部碎片。</p><p>WF将最大的连续内存划分开，会导致很快没有可用的大内存块，性能也非常差。</p><p>FF和NF只需简单查找即可，BF和WF需要对可用块进行排序或遍历查找。在算法实现时，使用数组或链表进行管理。</p><div class="table-container"><table><thead><tr><th></th><th>作业道数</th><th>内零头</th><th>外零头</th><th>硬件支持</th><th>可用空间管理</th><th>解决碎片办法</th><th>解决内存不足</th><th>提高作业道数</th></tr></thead><tbody><tr><td>单道连续分配</td><td>1</td><td>有</td><td>无</td><td>界地址寄存器、越界检查机构</td><td>——</td><td>——</td><td>覆盖</td><td>交换</td></tr><tr><td>多道固定分区分配</td><td>&lt;=N(用户空间划分为N块)</td><td>有</td><td>无</td><td>①上、下限寄存器、地址变换机构②重定位寄存器、界地址寄存器、地址变换机构</td><td>——</td><td>——</td><td>——</td><td>——</td></tr><tr><td>多道可变分区分配</td><td>——</td><td>无</td><td>有</td><td>①上、下限寄存器、地址变换机构②重定位寄存器、界地址寄存器、地址变换机构</td><td>数组/链表</td><td>紧凑</td><td>——</td><td>——</td></tr></tbody></table></div><h2 id="Q30：非连续分配管理方式"><a href="#Q30：非连续分配管理方式" class="headerlink" title="Q30：非连续分配管理方式"></a>Q30：非连续分配管理方式</h2><p>采用非连续的分配方式，需要额外空间去存储它们（分散区域）的索引，使得非连续分配方式的存储密度低于连续分配方式。</p><p>①分页存储管理方式：</p><p>1) 基本分页存储管理方式：</p><p>l 分页的思想：</p><p>由于固定分区会产生内零头，可变分区会产生外零头，这两种技术对内存的利用率都比较低。因此，把主存空间划分大小相同且固定的块，块相对较小，作为主存的基本单位。每个进程也以块为单位进行划分，进程在执行时，以块为单位逐个申请主存中的块空间。</p><p>l 分页和固定分区区别：</p><p>块相对分区比较小，并且在进程也按照块进行划分，进程运行时按块申请主存可用块空间。这样，进程只会在为最后一个不完整块申请主存块空间时才产生内零头，并且产生的内部碎片相对于整个进程来说比较小，每个进程平均只产生半块大小内部碎片（页内碎片）。</p><p>​</p><p>l 基本概念：</p><p>页(Page)：进程中的块。</p><p>页框(Page Frame,页帧)：内存中的块。</p><p>块(Block)：外存中的块。</p><p>页面大小：2的指数幂（方便地址转换）。</p><p>【页面太小会使进程的页面数过多，这样页表就会过长，占用大量内存，而且也会增加硬件地址转换的开销，降低页面换入/换出效率】</p><p>【页面太大，会使页内碎片增多，降低内存利用率】</p><p>地址结构： （高位） 页号+页内偏移量 （低位）</p><p>页表：</p><p>由页表项组成。记录页面在内存中对应物理块号，一般存放于内存中。</p><p>页表项：页号+页框号。</p><p>【页表项大小不是任意的，在32位逻辑地址空间、字节编址单位、页面大小4KB，要保证页表项指向所有页的话，页表项大小应&gt;= log_2_(2^32B/4KB) / 8】</p><p>​ 物理地址：页框号+页内偏移量。</p><p>l 基本地址变换机构：</p><p>在系统中通常设置一个页表寄存器(PTR)，存放页表在内存的起始地址F和页表长度M。进程未执行时，页表的始址和页表长度存放于PCB中，当进程执行时，才将其存入PTR。</p><p>n 逻辑地址 转换 物理地址 的过程:</p><p>由逻辑地址及页面大小计算得到页号P和页内偏移量W。然后比较页号P和页表长度M，若P&gt;=M则发生越界中断，否则继续执行。由页表在内存的始址F和页号P计算出对应页表项地址。然后从页表项中找到对应页号的页框号，由页框号和页内偏移量W组成物理地址。</p><p>【页式管理的地址空间是一维的（页面大小是固定的，给一个逻辑地址就可计算出一个物理地址）】</p><p>l 基于上述地址变换机构的分页管理存在的问题：</p><p>①每次访存操作都要进行逻辑地址到物理地址的转换，地址转换必须足够快，否则会降低访存速度。</p><p>②每个进程引入页表，用于存储映射机制，页表不能太大，否则内存利用率会降低。</p><p>l 具有快表的地址变换机构：</p><p>在上面的地址变换机构中，若页表全部放在内存中，则存取一个数据或一条指令至少要访问2次内存，第一次访问页表，确定所存取数据或指令的物理地址，第二次是根据该物理地址存取数据或指令。为此，在地址变换机构中增加一个具有并行查找能力的高速缓冲器——快表/相联存储器TLB。用于存放当前访问的若干页表项，加速地址变换的过程。</p><p>n 逻辑地址 转换 物理地址 的过程:</p><p>①CPU给出逻辑地址后，由硬件进行地址转换，将页号送入高速缓存寄存器，并将此页号与快表中所有页号进行比较。</p><p>②若找到匹配的页号，说明所要访问的页表项在快表中，则直接从中读出对应的页框号，与页内偏移量拼接形成物理地址。这样，存取数据仅一次访存即可实现。</p><p>③若未找到，则需访问主存的页表，在读出页表项后，应将其存入快表，以便以后可能再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换。</p><p>【有的处理机设计为快表和慢表同时查找，若在快表中查找成功则终止慢表的查找】</p><p>【快表的有效性基于局部性原理】</p><p>l 两级页表：</p><p>由于引入了分页管理，每个进程执行时不需要将所有页面调入内存页框，而只需将保存有映射关系的页表调入内存。考虑页表大小，</p><p>以32位逻辑地址空间、字节编址单位、页面大小4KB、页表项为4B为例，若要实现进程对全部逻辑地址空间的映射，则每个进程需要2^20个页表项，即每个进程仅页表就需要4MB，显示不符合实际。</p><p>即便不考虑对全部逻辑地址空间的映射，那么对于一个逻辑地址空间稍大的进程而言，以40MB为例，则页表项总共40KB，页表项需要10个页框，而进程大小约1万个页面，实际运行时只需几十个页面进入内存页框即可运行，若要求10个页面大小的页表全部进入内存，则相对于实际上只需几十个页面进入内存页框即可运行而言，降低了内存利用率；从另一方面来说这10页的页表项也并不需要同时保存在内存，因为在大多情况下，映射所需要的页表项都在页表的一个页面中。</p><p>为了压缩页表，进一步延伸页表映射的思想，将页表的多个页面也进行地址映射，建立上一级页表，用于存储页表的映射关系。</p><p>在进程执行时，只需要将这一页的上一级页表调入内存即可，进程的页表和进程本身的页面可在后面的执行中再调入执行。</p><p>【顶级页表只能有一个页面】</p><p>逻辑地址空间的格式：</p><p>（高位） 一级页号 + 二级页号 + 页内偏移量 （低位）</p><p>建立多级页表的目的：</p><p>建立索引，以便不用浪费主存空间去存储无用的页表项，也不用盲目地顺序式查找页表项。</p><p>​</p><p>2) 请求调页存储管理方式</p><p>​</p><p>②分段存储管理方式：</p><p>1) 基本分段存储管理方式：</p><p>【分页通过硬件机制实现，对用户完全透明】</p><p>【分段管理方式的提出是考虑了用户和程序员，以满足方便编程、信息保护和共享、动态增长及动态链接等多方面的需要】</p><p>分段：</p><p>段式管理方式按照用户进程中的自然段划分逻辑空间。段内要求连续、段间不要求连续。</p><p>逻辑地址结构：段号+段内偏移量。</p><p>【页式系统中，逻辑地址的页号和页内偏移量对用户是透明的】</p><p>【段式系统中，段号和段内偏移量必须由用户显示提供，在高级程序设计语言中，这个工作由编译程序完成】</p><p>段表：</p><p>由段表项组成。每个进程都有一张逻辑空间与内存空间映射的段表。</p><p>【配置段表后，执行中的进程可以通过段表，找到每段对应的内存区】</p><p>段表项：</p><p>段号+段长+本段在主存中的地址。</p><p>【每个段表项对应进程的一段】</p><p>地址变换机构：</p><p>段表寄存器：段表始址、段表长度。</p><p>逻辑地址 转换 物理地址 的过程:</p><p>从逻辑地址中取出前几位为段号S，后几位为段内偏移量W。然后比较段号S和段表长度M，若S&gt;=M则发生越界中断，否则继续执行。</p><p>由段表在内存的始址F和段号S计算出对应段表项地址。然后将段内偏移量W和段表项中的段长C比较，若W&gt;=C则发生越界中断，否则继续执行。</p><p>由段在内存的地址和段内偏移量相加构成物理地址。</p><p>【段式管理的地址空间是二维的（段长是不确定的，因此段号和段内偏移量要显示给出）】</p><p>​</p><p>​ 段的共享：</p><p>【分段系统中，段的共享是通过两个作业的段表中相应段表项指向被共享段的同一个物理副本来实现的】</p><p>【当一个作业正在从共享段中读取数据时，必须防止另一个作业修改此共享段中的数据】</p><p>【可重入代码/纯代码（：不能修改的代码，不属于临界资源）和不能修改的数据可以共享，而可修改代码和数据不可共享】</p><p>​</p><p>段的保护：</p><p>【存取控制保护】【越界保护】</p><p>​</p><p>③段页式存储管理方式：</p><p>1) 基本段页式存储管理方式：</p><p>页式存储管理有效地提高了内存利用率，段式存储管理能反映程序的逻辑结构并有利于段的共享。</p><p>【作业的地址空间分为若干个逻辑段，每个段有自己的段号，然后将每个段分成若干个固定大小的页】</p><p>【对内存划分和分页存储管理一样，将其划分成若干个页面大小相同的存储块，对内存的分配以存储块为单位】</p><p>逻辑地址结构：（高位） 段号+页号+页内偏移量 （低位）</p><p>地址变换机构：</p><p>【每个进程有唯一的段表和若干个页表】</p><p>段表表项：段号、页表长度、页表始址等。</p><p>页表表项：页号、页框号等。</p><p>段表寄存器：段表始址、段表长度。</p><p>逻辑地址 转换 物理地址 的过程:</p><p>从逻辑地址中取出前几位为段号S，接着几位为页号P，然后为页内偏移量W。将段号S和段表寄存器中的段表长度M相比较，若S&gt;=M则发生越界中断，否则继续执行。</p><p>由段表始址和段号计算出对应段表项的地址，将页号P和段表项中的页表长度Mp比较，若P&gt;=Mp则发生越界中断，否则继续执行。将段表项中的页表始址和页号计算出对应的页表项地址，然后查找到对应页表项，将页框号和页内偏移量拼接组成物理地址。</p><p>【段页式管理的地址空间是二维的】</p><p>​ 快表：其关键字是：段号和页号，值是：页帧号和保护码。</p><p>​</p><p>​</p><h2 id="Q31：虚拟存储管理"><a href="#Q31：虚拟存储管理" class="headerlink" title="Q31：虚拟存储管理"></a>Q31：虚拟存储管理</h2><p>l 传统存储管理方式特征：</p><p>①一次性：</p><p>作业必须一次性全部装入内存后，才能执行。</p><p>②驻留性：</p><p>作业被装入内存后，就一直驻留在内存中，其任何部分都不会被换出，直至程序运行结束。运行中的进程可以因等待I/O而被阻塞，可能处于长期等待状态。</p><p>l 局部性原理：</p><p>n 时间局部性:</p><p>程序中的某条指令一旦执行，不久后该指令可能再次执行；某数据被访问后，不久后该数据可能再次被访问。</p><p>【产生时间局部性的原因是程序中存在着大量的循环操作】</p><p>n 空间局部性：</p><p>一旦程序访问了某个存储单元，则不久后，其附近的存储单元也将被访问。</p><p>【通常指令是顺序存放的、顺序执行的，数据一般是以数组、向量、表等形式簇聚存储的】</p><p>【时间局部性通过将近来使用的指令和数据存放在高速缓冲存储器中，并使用高速缓存的层次结构实现】</p><p>【空间局部性通常使用较大的高速缓存，并将预取机制集成化到高速缓存控制逻辑中实现】</p><p>​</p><p>l 虚拟存储器：</p><p>基于局部性原理，在程序装入时，只将程序的一部分装入内存，其余部分留在外存，就可启动程序执行。在程序执行过程中，当所访问的信息不在内存时，由OS将所需的部分从外存调入内存，然后执行。另一方面，OS将内存中暂时不适用的部分调到外存上，腾出内存空间以便将要调入的部分调入内存中。因此，系统为用户提供了一个比实际存储空间大得多的存储器。</p><p>特征：【虚拟存储器的大小由计算机的地址结构决定】</p><p>①多次性：作业在运行时无须一次性地全部装入内存，而是允许被分成多次调入内存。</p><p>②对换性：作业无须一直驻留在内存，而是可以换入和换出。</p><p>③虚拟性：逻辑上扩充。</p><p>虚拟存储技术的实现：</p><p>虚拟内存技术允许一个作业分多次调入内存。采用连续分配方式，会使相当一部分内存处于暂时或“永久”空闲状态，造成内存资源的严重浪费，也无法从逻辑上扩充内存。</p><p>因此，虚拟内存的实现是建立在离散分配的内存管理方式基础上。</p><p>实现方式：请求分页存储管理、请求分段存储管理、请求段页式存储管理。</p><p>虚拟存储技术需要硬件支持，一般需要：</p><p>①一定量的内存和外存空间</p><p>②页表机制或段表机制</p><p>③中断机构，当所要访问的部分未调入内存时，产生中断</p><p>④地址变换机构</p><p>​</p><h2 id="Q32：请求分页存储管理"><a href="#Q32：请求分页存储管理" class="headerlink" title="Q32：请求分页存储管理"></a>Q32：请求分页存储管理</h2><p>l 页表机制：</p><p>页表项：页号、物理块号、状态位、访问字段、修改位、外存地址。</p><p>状态位：</p><p>用于指示该页是否已调入内存，供程序访问时参考。</p><p>访问字段：</p><p>用于记录本页在一段时间内被访问次数或记录本页有多长时间未被访问，供置换算法换出页面时参考。</p><p>修改位：</p><p>表示该页被调入内存后是否修改过。</p><p>外存地址：</p><p>指出该页在外存中的地址，供调入该页时参考。</p><p>​</p><p>l 缺页中断机制：</p><p>在请求分页存储管理方式中，当所要访问页面不在内存时，便产生一个缺页中断，请求该OS将所需的页调入内存，此时应将缺页的进程阻塞，若内存中有空闲块，则分配一个块，将要调入的页装入该块，并修改页表中相应表项。若此时内存中无空闲块，则要淘汰某页（若淘汰的页在内存期间被修改过，则需要写回外存）。</p><p>【内中断，指令执行期间产生的中断请求】</p><p>【一条指令在执行期间，可能产生多次缺页中断】</p><p>​</p><p>l 地址变换机构：</p><p>程序请求访问某一页，</p><p>比较页号P和页表长度M，若P&gt;=M则产生越界中断，否则继续执行。</p><p>CPU检索快表，若该页号对应的页表项在快表中，则修改访问位和修改位，然后由页帧号和页内偏移量拼接成物理地址。</p><p>若不在快表中，则由页表始址和页号得到页表项地址访问页表，若该页在内存中中，则修改快表中相应表项，然后，修改访问位和修改位，然后由页帧号和页内偏移量拼接成物理地址。</p><p>若该页不在内存中，则产生缺页中断。由缺页中断处理程序保护CPU现场。然后从外存中找到该页。若内存有空闲，则OS命令CPU从外存读缺页，启动I/O硬件，将一页从外存调入内存，修改页表，然后重新执行指令。</p><p>若内存已满，则需要选择一页换出，若该页修改过则还需写回外存，然后，OS命令CPU从外存读缺页，启动I/O硬件，将一页从外存调入内存，修改页表，然后重新执行指令。</p><p>​</p><p>l 页面置换算法：（决定换入哪页、换出哪页）</p><p>①最佳OPT置换算法:</p><p>【淘汰：以后永久不使用或在最长时间内不再被访问的页面】</p><p>【无法实现，一般用来评价其他算法】</p><p>②先进先出FIFO置换算法：</p><p>【淘汰：最先进入内存的页面，即内存中驻留时间最久的页面】</p><p>【实现简单，只需将调入内存的页面根据先后次序链接成队列，设置一个指针总指向最早的页面】</p><p>【Belady异常：分配物理块增多而页故障数不减反增】</p><p>③最近最久未使用LRU置换算法：</p><p>【淘汰：最近最长时间未访问过的页面】</p><p>【基于局部性原理，认为过去一段时间内未使用，则在最近的将来可能也不会使用】</p><p>【该算法为每个页面设置一个访问字段，用来记录页面自上次访问以来所经历的时间】</p><p>【LRU算法性能较好，但需要寄存器和栈的硬件的支持】</p><p>【LRU算法是堆栈类算法】</p><p>【理论上可证明堆栈类算法不会产生Belady异常】</p><p>④时钟CLOCK算法:</p><p>1) 简单的CLOCK算法/最近未用NRU算法：</p><p>【为每个帧关联一个附加位，即使用位】</p><p>【将替换的帧的集合视为一个循环缓冲区，并有一指针与之关联】</p><p>初始时，将所有帧的使用位置为0。</p><p>当某页首次装入内存时，将其对应帧的使用位置为1。</p><p>当该页随后再次被访问，将其使用位置1。</p><p>当某页被替换时，该指针指向缓冲区的下一帧。</p><p>当需要进行替换一页时，OS扫描帧缓冲区，以查找使用位为0的帧。每当遇到使用位为1的帧，将其使用位置为0。若查找失败，则重新扫描，直至找到所要淘汰的页。</p><p>2) 改进的CLOCK算法：</p><p>【使用位u、修改位m】</p><p>初始时，将所有帧置u=0,m=0。</p><p>当某页首次装入内存时，将其对应帧的使用位置为1。</p><p>当该页随后再次被访问，将其使用位置1。</p><p>当某页在内存期间被修改则置对应帧的修改位为1。</p><p>当某页被替换时，该指针指向缓冲区的下一帧。</p><p>当需要进行替换一页时，</p><p>step1：OS扫描帧缓冲区，以查找u=0,m=0的帧，在此次查找过程中对使用位不进行任何修改。</p><p>step2：若查找失败，则重新扫描，查找u=0,m=1的帧。每当遇到使用位为1的帧，将其使用位置为0。</p><p>若查找失败，则重新扫描，循环step1与step2操作，直至找到所要淘汰的页。</p><p>l 页面分配策略：</p><p>①驻留集大小：</p><p>进程的驻留集：OS为每一个进程分配的物理页框的集合。</p><p>【考虑点1：分配给一个进程的存储量越小，则任何时刻驻留在内存中的进程数目就越多，从而可以提高CPU的利用效率】</p><p>【考虑点2：若一个进程在内存中的页面过少，尽管有局部性原理，页错误率仍然相对较高】</p><p>【考虑点3：若页数过多，则由局部性原理，给特定的进程分配过多的主存空间对进程的页错误率没有明显的影响】</p><p>​</p><p>现代OS采用的策略：</p><p>1) 固定分配局部置换：</p><p>【为每一个进程分配一定数目的物理块，在进程执行期间不发生改变】</p><p>【若进程在运行时发生缺页，则只能从该进程在内存的页面中选出一页换出，然后调入页面】</p><p>【难以确定合适的物理块数目，过少会频繁出现缺页中断，过多会降低CPU和其他资源利用率】</p><p>2) 动态分配全局置换</p><p>【为每个进程分配一定数目的物理块，OS保持一个空闲物理块队列】</p><p>【当发生缺页时，OS从空闲地物理块队列中取出一个物理块分配给该进程，并将要调入的页装入该物理块中】</p><p>【缺点：会盲目地给进程增加物理块，从而使得系统多道程序的并发性下降】</p><p>​</p><p>3) 动态分配局部置换：</p><p>【为每个进程分配一定数目的物理块】</p><p>【当发生缺页时，允许该进程在内存的页面中选出一页换出，因此不会影响其他进程运行】</p><p>【若进程在运行时频繁发生缺页，则系统再为进程分配若干个物理块，直至该进程缺页率区域适当程度】</p><p>【若进程的缺页率极低，则可适当地减少给进程分配的物理块】</p><p>【优点：既保证了进程不会出现过多缺页的同时，又保持了系统的多道程序并发能力】</p><p>​</p><p>②页面调入时机：</p><p>1) 预调入策略：</p><p>根据局部性原理，一次调入相邻的若干页可能会比一次调入一页更高效。但当调入的一批页面中大多未访问时，又是低效的。</p><p>【目前预调页成功率仅约50%。主要用于进程的首次调入，由程序员指定调入哪些页】</p><p>​</p><p>2) 请求调入策略：</p><p>【易于实现，缺点是每次只调入一页，当调入/调出页面过多时会增加过多的I/O开销】</p><p>​</p><p>③从何处调入页面：</p><p>请求分页存储管理系统在外存分为两部分：</p><p>文件区（用于存放文件）【通常采用离散存储方式】</p><p>对换区（用于存放对换页面）【通常采用连续存储方式】</p><p>​</p><p>1) 系统有足够的对换空间：</p><p>【可以全部从对换区调入所需页面，以提高页调入速度】</p><p>【在进程运行之前，将与该进程相关的文件从文件区拷贝到对换区】</p><p>2) 系统缺少足够的对换空间：</p><p>【凡不会修改的文件都从文件区调入】</p><p>【当换出页面时，若未修改则不必换出；否则，将其换出时必须调到对换区，以后需要时从对换区调入】</p><p>3) UNIX方式：</p><p>【与进程有关的文件都放在文件区，因此未运行过的页面直接从文件区调入】</p><p>【那些曾经运行过但被换出的页面放在对换区，因此下次调入时从对换区调入】</p><p>【进程请求的共享页面被其他进程调入内存，则无需再从对换区调入】</p><p>​</p><p>l 抖动：</p><p>刚刚换出的页面马上需要换入内存，刚刚换入的页面马上需要换出内存，这种频繁的页面调度行为。</p><p>【若一个进程在换页上用的时间多于执行时间，则该进程就在抖动】</p><p>频繁发生缺页中断（抖动）原因：</p><p>某个进程频繁要访问的页面数高于可用的物理块数目。</p><p>​</p><p>​</p><p>l 工作集：</p><p>某段时间间隔内，进程要访问的页面集合。由时间和工作集窗口大小确定。</p><p>【实际应用中，工作集窗口会设置很大，而工作集一般比工作集窗口小很多】</p><p>【工作集反映了进程在接下来一段时间可能进行频繁访问的页面集合，因此，若分给进程的物理块数小于工作集大小，则进程可能出现频繁缺页。因此，一般驻留集大小大于工作集大小】</p><p>工作集模型原理：</p><p>让OS去跟踪每个进程的工作集，并为进程分配大于工作集大小的物理块。在工作集中页面可能需要调入驻留集中，不在其中的页面可能需要从驻留集中换出。若还有空闲的物理块，则可通过再调一个进程进入内存来提高多道程序度。当所有进程的工作集大小总和超过了可用物理块数目，则OS会暂停一个进程，将其页面调出并将其物理块分配给其他进程，防止出现抖动现象。</p><p>​</p><p>l 地址结构：</p><p>虚拟地址： 虚拟页号（TLB标记 + TLB索引） + 页内偏移量</p><p>eg,TLB为四路组相联，共有16个条目，则， TLB索引为log_2_(16/4) = 2位。</p><p>物理地址： 物理页号（cache标记 + cache索引 + 偏移量） + 页内偏移量</p><p>eg,cache是物理寻址、直接映射的，行大小为4B，共有16组，则，块偏移为log_2_(4)= 2位，cache索引为log_2_(16)= 4位。</p><p>​</p><h2 id="Q33：覆盖、交换和虚拟存储技术区别"><a href="#Q33：覆盖、交换和虚拟存储技术区别" class="headerlink" title="Q33：覆盖、交换和虚拟存储技术区别"></a>Q33：覆盖、交换和虚拟存储技术区别</h2><p>覆盖与虚拟技术区别：</p><p>覆盖程序段的最大长度受内存存量大小限制，而虚拟存储器中程序最大长度只受地址结构限制。</p><p>覆盖技术中的覆盖段由程序员设计，且要求覆盖段中各个覆盖具有相对独立性，不存在直接联系或相互交叉访问，而虚拟存储技术没有这种要求。</p><p>​</p><p>交换与虚拟存储技术区别：</p><p>交换技术调入/调出是整个进程，因此一个进程的大小要受内存存量大小的限制，而虚拟存储技术中使用的调入/调出技术在内存与外存之间交换的是页面或段，而不是整个进程，从而使得进程的地址映射具有更大的灵活性。且允许进程大小比可以的内存空间大。</p><h1 id="CHAPTER-4"><a href="#CHAPTER-4" class="headerlink" title="CHAPTER 4"></a>CHAPTER 4</h1><h2 id="Q34：文件及文件系统概念"><a href="#Q34：文件及文件系统概念" class="headerlink" title="Q34：文件及文件系统概念"></a>Q34：文件及文件系统概念</h2><p>文件：是以计算机硬盘为载体的在计算机上的信息集合。</p><p>【计算机在运行时是以进程为基本调度单位，而在用户的输入/输出时是以文件为基本单位的】</p><p>【文件可以是数字、字母、二进制代码。基本访问单元可以是字节、行或记录。文件可以长期存储在硬盘或其他二级存储器中，允许可控制进程间共享，能被组织成复杂的结构】</p><p>文件系统：</p><p>​ OS中负责管理和存储文件信息的软件机构称为文件管理系统。</p><p>【由与文件管理有关的软件、被管理文件以及实施文件管理所需的数据结构组成】</p><p>【从用户角度看，文件管理系统是OS中重要的一部分。用户只关心如何命名、分类及查找文件，如何保证文件数据的安全性以及对文件进行哪些操作】</p><p>【文件管理系统提供与二级存储有关的资源抽象，使得用户在不了解文件的各种属性、文件在存储介质上的存储方式及存储位置的情况，方便快捷的使用文件】</p><p>​</p><p>l 从下往上看文件的组织：</p><p>数据项：是文件系统中最低级的数据组织形式。</p><p>基本数据项：用于描述一个对象的某一种属性。</p><p>组合数据项：由多个基本数据项组合而成。</p><p>记录：是一组相关的数据项的集合。</p><p>文件：是创建者所定义的一组相关信息的集合。</p><p>【逻辑上可分为有结构文件/记录式文件和无结构文件/流式文件，有结构文件由一组相似的记录组成，无结构文件被视为一个字符流】</p><p>​</p><p>l 文件的属性：</p><p>①名称</p><p>【文件名唯一，以易读取的形式保存】</p><p>②标识符</p><p>【标识文件系统内文件的唯一标识，通常为数字，对人不可读的一种内部名称】</p><p>③类型</p><p>【被支持不同类型的文件系统使用】</p><p>④大小</p><p>【文件当前大小，也可包含文件允许的最大值】</p><p>⑤位置</p><p>【指向设备和设备上文件的指针】</p><p>⑥保护</p><p>【对文件进行保护的访问控制信息】</p><p>​ ⑦时间、日期和用户标识</p><p>【文件创建、上次修改和上次访问的相关信息，用于保护和跟踪文件的使用】</p><p>【文件的所有相关信息保存在目录结构中，而目录结构保存在外存，在需要时调入到内存】</p><p>​</p><p>l 文件的基本操作：</p><p>【OS通过系统调用来对文件进行创建、读、写、删除、重定位、截断等操作】</p><p>①创建文件</p><p>②写文件</p><p>【为了写文件，执行一个系统调用，指明文件名称和要写入文件的内容】</p><p>【对于给定的文件名称，系统搜索目录以查找文件位置】</p><p>【系统必须为该文件维护一个写位置的指针，每当发生写操作时，便于更新写指针】</p><p>③读文件</p><p>【为了读文件，执行一个系统调用，指明文件名称和要读入文件块的内存位置】</p><p>【对于给定的文件名称，系统搜索目录以查找文件位置】</p><p>【系统必须为该文件维护一个读位置的指针，每当发生读操作时，便于更新读指针】</p><p>【一个进程通常只对一个文件进行读/写操作，因此当前操作位置可作为进程当前文件位置的指针。由于读、写操作使用同一个指针，节省了空间，降低了系统的复杂度】</p><p>④删除文件</p><p>【先从目录中找到要删除文件的目录项，使之成为空项，然后回收文件所占的存储空间】</p><p>⑤文件重定位（文件寻址）</p><p>【按某条件搜索目录，将当前文件位置设置为给定值，不进行读/写操作】</p><p>⑥截断</p><p>【允许文件的所有属性不变，删除文件内容，将其长度设为0并且释放其空间】</p><p>​</p><p>l 文件的打开和关闭：</p><p>【文件的许多操作都会涉及到为给定文件搜索目录以找到相对应的目录项，因此大多系统要求在首次使用文件时，使用系统调用open将指明文件的属性（也包括该文件在外存上的位置）从外存复制到内存的打开文件表的一个表目中，将该表目的编号（索引）返回给用户】</p><p>【当用户需要一个文件操作时，通过该表的一个索引指定文件，因此省略了搜索环节。当文件不再使用时，进程可以关闭它，OS从文件打开表中删除该条目】</p><p>【大部分OS要求在使用文件之前显示地打开文件】</p><p>【操作open会根据文件名称搜索目录，并将相应的目录条目复制到系统打开文件表。若调用open的请求（创建、只读、读写、添加等）得到允许，则进程就可打开文件，而open通常返回一个指向系统打开文件表中一个条目的指针，只通过该指针（而非文件名）进行所有I/O操作】</p><p>【一个进程打开一个文件，系统打开文件表就会为相应文件增加一个条目。当另一进程执行open操作时，只不过是在其进程的打开文件表中增加一个条目，并指向系统打开文件表中对应的条目】</p><p>【一个进程在打开一个文件时，首先遍历系统打开文件表】</p><p>【通常，系统打开文件表的每个文件时，还用到一个打开计数器，已记录多少进程打开该文件】</p><p>【每个关闭操作close使得count递减，当打开计数器为0时，表示该文件不在被使用，系统就回收分配该文件的内存空间等资源。若文件被修改过，则将文件写回外存，并将系统打开文件表中相应表项删除，最后释放其FCB】</p><p>​</p><p>n 每个打开文件都有如下关联信息：</p><p>文件指针：</p><p>【系统跟踪上次文件读写位置作为当前文件位置的指针】【对进程来说是唯一的，必须与磁盘文件属性分开保存】</p><p>文件打开计数：</p><p>文件磁盘位置：</p><p>【该信息保存在内存，以免每个操作都要从磁盘读取】</p><p>访问权限：</p><p>【保存在进程的打开文件表中，以便OS能够允许或拒绝之后的I/O请求】</p><p>​</p><h2 id="Q35：文件的逻辑结构"><a href="#Q35：文件的逻辑结构" class="headerlink" title="Q35：文件的逻辑结构"></a>Q35：文件的逻辑结构</h2><p>①无结构文件（流式文件）</p><p>【将数据按顺序组织成记录并积累、保存，它是有序相关信息项的集合】</p><p>【以字节为单位】</p><p>【对记录的访问只能以穷举搜索的方式进行，对大多数应用不适用；但管理简单，用户可以很方便地对其进行操作】</p><p>【适用于对基本信息单位操作不多的文件，如源程序文件、目标代码文件等】</p><p>​</p><p>②有结构文件（记录式文件）</p><p>1) 顺序文件：</p><p>【文件中的记录按一个接一个顺序排列，记录通常是定长的，可以以数组或链表的方式存储】</p><p>【访问时以顺序搜索文件】</p><p>【对记录进行批量操作，即每次要读或写一大批记录时，顺序文件的效率是所有逻辑文件中最高的】</p><p>【只有顺序文件才能存储在磁带上，并能有效地工作】</p><p>【但顺序文件对查找、删除、增加、修改单条记录的操作比较困难】</p><p>​</p><p>a) 串结构</p><p>【记录之间的顺序与关键字无关，通常由时间决定，即按存入的先后时间排列】</p><p>b) 顺序结构</p><p>【所有的记录以关键字的顺序进行排列】</p><p>2) 索引文件：</p><p>【对于定长的记录文件，可以很方便地得到某一条记录据第一条记录的位置】</p><p>【而对于可变长的记录文件，需要通过顺序地查找某条记录之前所有记录才能得到其的位置】</p><p>【变长文件只能顺序查找，系统开销大，为此，通过建立一张索引表以加快检索的速度】</p><p>【索引表是一个定长记录的顺序文件】</p><p>【索引表的表项由索引表编号、记录长度、指向逻辑文件中记录的位置的指针组成】</p><p>​</p><p>3) 索引顺序文件：</p><p>【将顺序文件中的记录分成若干组，为顺序文件建立一张索引表】</p><p>【索引表的表项由每组记录中第一条记录的关键字和指向该记录的指针组成】</p><p>【组间关键字必须连续】</p><p>【对于含N条记录的顺序文件，查找某条记录时平均需查找N/2次；若将其划分成sqrt(N)组，查找某条记录时先查找索引表以确定其所在组的第一条记录位置，然后顺序查找其顺序文件中所在的组，平均查找sqrt(N)次】</p><p>4)直接文件/散列文件：</p><p>【给定记录的键值或通过散列函数转换的键值直接决定记录的物理地址】</p><p>【没有顺序的特性】</p><p>【有很高的存取速度，但会引起冲突，即不同关键字的散列函数值相同】</p><p>​</p><h2 id="Q36：目录及目录结构"><a href="#Q36：目录及目录结构" class="headerlink" title="Q36：目录及目录结构"></a>Q36：目录及目录结构</h2><p>l 目录管理的基本要求：</p><p>从用户角度看，目录在用户（应用程序）所需的文件和文件名提供一种映射，即目录应实现“按名存取”；</p><p>目录的检索会直接影响到系统效率，因此应提高目录的检索速度；</p><p>在共享系统中，目录还需提供用于控制访问文件的信息；</p><p>文件名重名也是用户合理和必然的要求，因此通过树形结构来解决和实现的；</p><p>​</p><p>l 文件控制块(FCB):</p><p>【用来存放控制文件需要的各种信息的数据结构，以实现“按名存取”】</p><p>【FCB的有序集合称为文件目录。一个FCB就是一个文件目录项】</p><p>①基本信息：</p><p>【文件名、文件的物理位置、文件的逻辑结构、文件的物理结构等】</p><p>②存取控制信息：</p><p>【文件存取权限等】</p><p>③使用信息：</p><p>【文件建立时间、修改时间等】</p><p>​</p><p>l 索引结点(i node)：</p><p>【在检索目录文件过程中，只用到了文件名，仅当找到一个匹配的目录项时，才需从该目录项中读出文件的物理位置】</p><p>【因此，有的系统（如UNIX）采用了将文件名和文件描述信息分开的办法，文件描述信息单独构成一个索引结点】</p><p>【在文件目录中的每个目录项由文件名和指向该文件对应的索引结点的指针构成】</p><p>【一个盘块是1KB，一个FCB是64B，那么一个盘块可以存放16个FCB；而在UNIX系统中，一个FCB使16B，那么一个盘块可以存放64个FCB，因此减少了查找文件时平均启动磁盘的次数，降低了系统开销】</p><p>【连续存放的】</p><p>​</p><p>磁盘索引结点：</p><p>【UNIX系统中每个文件都有唯一的磁盘索引结点】</p><p>①文件主标识符</p><p>【拥有该文件的个人或小组的标识符】</p><p>②文件类型</p><p>【普通文件、目录文件、特殊文件（如UNIX中的输入/输出设备）】</p><p>③文件存取权限</p><p>【各用户对该文件的存取权限】</p><p>④文件物理地址</p><p>【每个索引结点有13个地址项，直接或间接地给出数据文件所在盘块的编号】</p><p>⑤文件长度</p><p>【以字节为单位】</p><p>⑥文件的链接计数</p><p>【在本文件系统中所有指向该文件的文件名的指针计数】</p><p>⑦文件的存取时间</p><p>【本文件最近被进程存取的时间、最近被修改的时间及索引结点最近被修改的时间】</p><p>​</p><p>在文件被打开时，磁盘索引结点赋值到内存的索引结点中，方便使用。增加了，</p><p>①索引结点编号</p><p>【用于标识内存索引结点】</p><p>②状态</p><p>【指示索引结点是否上锁或被修改】</p><p>③访问计数</p><p>【每当一进程要访问该结点时，计数加一】</p><p>④逻辑设备号</p><p>【文件所属文件系统的逻辑设备号】</p><p>⑤链接指针</p><p>【设置分别指向空闲链表和散列队列的指针】</p><p>​</p><p>l 目录层次上要执行的操作：</p><p>搜索：</p><p>【当用户使用一个文件时，需要搜索目录，以找到该文件对应的目录项】</p><p>创建文件：</p><p>【用户创建一个文件时，需要在其目录中增加一个相应的目录项】</p><p>删除文件：</p><p>【用户删除一个文件时，需要在其目录中删除一个相应的目录项】</p><p>显示目录：</p><p>【用户可以通过请求显示目录中内容，如显示该用户目录中所有文件及属性】</p><p>修改目录：【某些文件属性保存在目录中，因而这些属性的变化需要相应地改变目录中的内容】</p><p>​</p><p>l 目录结构：</p><p>①单级目录结构：</p><p>【整个系统中只存在一张目录表，每个文件占一个目录项】</p><p>【当访问一个文件时，首先根据文件名在该目录中查找相应的FCB，经合法检查后继续执行其他相关操作】</p><p>【当建立一个文件时，首先遍历整个目录以确保不存在“重名”的情况，然后在目录中增加一个目录项】</p><p>【当删除一个文件时，首先查找目录找到删除文件相应的目录项，然后回收文件所占的内存空间等资源，删除相应的目录项】</p><p>【实现了“按名存取”，但存在查找速度慢，文件不允许重名，不便于文件共享，显然对多用户的OS不适用】</p><p>​</p><p>②两级目录结构：</p><p>【将文件目录划分为主文件目录MFD和用户文件目录两级UFD】</p><p>【主文件目录的目录项记录用户名及相应用户文件目录所在的位置】</p><p>【用户文件目录的目录项由用户文件的FCB有序组成】</p><p>【允许多用户之间文件重名；文件系统可以在目录上实现访问限制；但不灵活，不能对文件进行分类】</p><p>​</p><p>③多级（树形）目录结构：</p><p>【用户访问某文件时，用文件的路径名来标识文件】</p><p>【文件路径名是一个字符串】</p><p>【绝对路径由从根目录出发都所找文件路径上所有的目录名和数据文件名称用“/”连接而成】</p><p>【当层次较多时，每次从根目录出发都会浪费时间，因此引入了当前目录/工作目录】</p><p>【当前目录存于内存】</p><p>【相对路径由从当前目录出发都所找文件路径上所有的目录名和数据文件名称用“/”连接而成】</p><p>【通常每个用户都有自己的工作目录，用户登录后进入了自己的当前目录中；OS提供一条专门的系统调用，用户可以随时地改变当前目录】</p><p>【层次清晰，便于对文件进行分类，也能有效地对文件进行保护和管理；但不便于实现文件共享】</p><p>​</p><p>④无环图目录结构：</p><p>【为了实现文件共享而引入】【在树形目录结构的基础上增加了一些指向同一结点的有向边】</p><p>【当某用户删除一个共享文件时，若只是简单的删除共享文件，则当另一共享用户访问时就会出错，因此在每个共享结点中设置一个共享计数器，记录所共享文件的用户（进程）数】</p><p>【每当增加一个指向共享结点的共享链时，该共享结点的共享计数器加1】</p><p>【每当一个用户要删除一个共享文件时，该共享文件的共享计数器减1，然后只删除该用户到共享文件的共享链；直到共享计数器为0时，系统才删除该共享文件，释放其FCB所占空间】</p><p>【共享：实际只存在一个文件，逻辑上存在多个；拷贝：存在多个文件】</p><h2 id="Q37：文件共享"><a href="#Q37：文件共享" class="headerlink" title="Q37：文件共享"></a>Q37：文件共享</h2><p>l 静态共享：</p><p>①基于索引结点的共享（硬链接）</p><p>【在树形目录结构，当两个用户或多个用户要共享一个文件或子目录时，要将共享文件或子目录链接到两个用户或多个用户的目录中，以方便地找到该文件】</p><p>【这种共享方式将文件的名称和文件描述信息分开，目录的目录项中只包含文件名和指向其对应i结点的指针，而文件描述信息存放于i结点中，i结点包括一个链接计数器，用来表示链接到该索引结点上的用户目录项的数目】</p><p>【当用户删除一个共享文件时，若将其共享文件对应的索引结点删除，则会导致其他共享该文件的用户指针悬空；因此引入链接计数器】</p><p>【只当链接计数器为0时，系统才会删除该共享文件对应的索引结点】</p><p>​</p><p>②基于符号链的共享（软链接）</p><p>【当其他用户需要共享文件主创建的文件时，系统创建一个LINK类型的文件，名称和要共享的文件名称相同，并且将新文件写入到其用户目录中】</p><p>【新文件的内容只包含要共享的文件的路径名】</p><p>【在基于符号链的共享方式中，只有文件拥有者才有指向其文件的索引结点的指针；而其他用户访问共享文件时，是通过访问LINK类型文件得到共享文件路径名，然后根据路径名对其进行访问】</p><p>【当文件拥有者删除其共享文件时，删除其索引结点；而当其他用户访问该共享文件时，会出现访问失败，系统将会将其符号链删除，不会导致其他影响】</p><p>【存在的问题：当文件主删除其共享文件后，在其他用户访问该共享文件之前，又在共享文件所在的目录下创建了一个和共享文件同名的新文件，则会导致其他用户所访问内容不是其所需的】</p><p>【缺点：用户（非文件主）访问共享文件时，会增加访问磁盘的次数，增加系统开销；并且会占用额外的存储空间】</p><p>【最大的优点是网络共享只需要提供文件所在机器的网络地址和在该机器中的文件位置即可】</p><p>​</p><p>l 动态共享：多个进程对同一个文件进行访问。</p><p>​</p><h2 id="Q38：文件保护"><a href="#Q38：文件保护" class="headerlink" title="Q38：文件保护"></a>Q38：文件保护</h2><p>【口令保护和加密保护是为了防止用户文件被他人存取或窃取】</p><p>【访问控制是控制用户对文件的访问方式】</p><p>【对多级目录结构而言，不仅对单个的文件要进行保护，而且需要对子目录内文件进行保护，即提供对目录的保护机制；由于目录和文件操作不同，所需的保护机制也不同】</p><p>​</p><p>①口令保护：</p><p>【用户在创建一个文件时提供一个口令，系统为其创建FCB并附上相应的口令，同时告知共享该文件的用户在访问时必须提供相应的口令】</p><p>【时空开销小，不安全（口令存在于系统内部）】</p><p>②加密保护：</p><p>【用户对文件进行加密和解密，文件被访问时需要使用秘钥】</p><p>【保密性强，节省了一定存储空间；但加密和解密要占用一定的时间】</p><p>③访问控制：</p><p>n 访问控制方式：</p><p>读、写、执行、添加、删除、列表清单（列出文件名和文件属性）</p><p>此外，还可以对文件重名、复制、编辑等加以控制，这些高层功能可以通过底层功能来实现；因此，可以只在底层实现保护。</p><p>​</p><p>【解决访问控制最常用的方法是基于用户身份进行访问控制】</p><p>【而实现基于用户身份访问最简单的方法就是为每个文件和目录增加一个访问控制列表ACL，以规定每个用户名和其所允许的访问类型】</p><p>【优点：可以实现复杂的访问方法】</p><p>【缺点：表长无法估计，可能会导致复杂的空间管理】</p><p>【解决方法：精简的访问列表（拥有者、组、其他三种用户类型）】</p><p>【文件拥有者在创建文件时，说明创建者的用户名和其所在的组的名称。系统在创建文件时，将文件主的名称和其所在的组名列在该文件的FCB】</p><p>【多用户对一个文件进行访问时是通过存取控制矩阵来进行的】</p><p>​</p><h2 id="Q39：文件系统的层次结构"><a href="#Q39：文件系统的层次结构" class="headerlink" title="Q39：文件系统的层次结构"></a>Q39：文件系统的层次结构</h2><p>【现代OS有不同的文件系统类型，如FAT32、NTFS、ext2、ext3、ext4等】</p><p>①用户调用接口：</p><p>【文件系统为用户提供与文件及目录有关的调用，如新建、打开、读写、关闭、删除文件等，建立、删除目录等】</p><p>【该层是由若干的数据模块组成，每个数据模块对应一个系统调用，用户发出系统调用，控制权就转给相应的模块】</p><p>②文件目录系统：</p><p>【主要功能是管理文件目录。其任务有管理活跃文件打开表、管理读写状态信息表、管理用户进程的文件打开表、管理存储设备上的文件目录结构以及调用下一层控制模块】</p><p>③存取访问验证模块：</p><p>【实现文件保护主要由该层完成。将用户的访问请求和文件FCB中对用户访问控制权限进行对比，以确保访问的合法性】</p><p>④逻辑文件系统及文件信息缓冲区：</p><p>【主要功能是将逻辑文件中要读写的逻辑记录转换成文件逻辑结构内相应的块号】</p><p>⑤物理文件系统：</p><p>【主要功能是将逻辑记录相应的块号映射成实际的物理地址】</p><p>⑥辅助分配模块：</p><p>【主要功能是分配空闲辅存空间、回收辅存空间等】</p><p>⑦设备管理程序模块：</p><p>【主要功能是分配设备、分配设备读写的缓冲区、磁盘调度、启动设备、处理设备中断、释放设备读写的缓冲区、释放设备等】</p><h2 id="Q40：目录实现"><a href="#Q40：目录实现" class="headerlink" title="Q40：目录实现"></a>Q40：目录实现</h2><p>【在读文件之前要打开文件，OS根据其路径名找到对应的目录项，其中有文件的物理地址】</p><p>【目录查询是通过在磁盘上反复搜索完成，需要不断地进行I/O操作，开销大；因此为了减小开销，通常将当前使用文件目录存入内存】</p><p>①线性列表</p><p>【最简单的目录实现方法是使用存储文件名和数据块指针构成的线性表】</p><p>【在创建文件时，要遍历目录以确保没有同名的文件存在；再删除文件时，要根据删除文件名称搜索目录以找到相应目录项，使其为空项，回收空间等资源】</p><p>【通过采用线性链表的方式，在删除时操作简单，但由于线性表的特性，比较费时】</p><p>​</p><p>n 重用目录项的方法：</p><p>1) 可以将目录项标记为不再使用</p><p>2) 可以将其加在空闲目录项表中</p><p>3) 可以将目录的最后一个目录项移到空目录项位置</p><p>​</p><p>②哈希表</p><p>【根据文件名得到一个值，并返回指向线性列表中某个元素的指针】</p><p>【优点：查找迅速，插入、删除简单】</p><p>【缺点：需要一定的措施解决冲突；哈希表表长固定，且哈希函数和哈希表表长的依赖性】</p><p>​</p><p>​</p><h2 id="Q41：文件实现——分配方式"><a href="#Q41：文件实现——分配方式" class="headerlink" title="Q41：文件实现——分配方式"></a>Q41：文件实现——分配方式</h2><p>①连续分配：</p><p>【每个文件占用一组连续的块】</p><p>【作业访问磁盘时寻道数和寻道时间最小】</p><p>【一个文件的目录条目包括开始块地址和该文件所分配区域的长度】</p><p>【支持顺序访问和直接访问】</p><p>【优点：实现简单、存取速度快】</p><p>【缺点：文件长度不宜动态增加；反复地分配和回收会导致外部碎片的产生；很难确定一个文件需要的空间大小，适用于长度固定的文件】</p><p>【访问第n条记录时，需访问1次磁盘】</p><p>②链接分配：</p><p>【没有外部碎片产生】</p><p>1) 隐式链接：</p><p>【每个文件对应一个磁盘块的链表】</p><p>【除了最后一个磁盘块其他的都有指向下一块磁盘块的指针，指针对用户透明】</p><p>【目录结构包含了文件的第一块指针和最后一块的指针】</p><p>【只支持按块链顺序访问】</p><p>【缺点：无法直接访问；指针占用了一定的存储空间；稳定性比较差，系统在运行过程中由于软件或硬件出现错误而导致链接指针损坏或丢失，会导致文件数据的丢失】</p><p>【访问第n条记录时，最多需访问次磁盘n次】</p><p>​</p><p>2) 显示链接：</p><p>【支持直接访问和顺序访问】</p><p>【将用于链接各块的指针提取出来，存放在内存的一张链接表中，该表在磁盘中仅设置一张，即文件分配表FAT】</p><p>【FAT和全部的磁盘块一一对应，可以用-1来表示是文件最后一块，可以用-2表示磁盘块是空闲的】</p><p>【FAT不仅记录了文件的各块先后链接关系，还记录了当前空闲的磁盘块信息】</p><p>【FAT在系统启动时就会被读入内存，因此对FAT的查找是在内存中进行的，提高了检索速度，减少了访问磁盘的次数】</p><p>​</p><p>③索引分配：</p><p>【没有外部碎片产生】</p><p>【将每个文件的所有盘块集中存放一起构成索引块，即磁盘地址构成的数组】</p><p>【每个文件都有索引块】</p><p>【初始时文件索引块的指针全置为空】</p><p>【支持直接访问】</p><p>【缺点：索引块占用了一定的存储空间开销；由于每个文件都有索引块，因此索引块不应过大，而索引块过小会无法支持大文件】</p><p>【访问第n条记录时，需访问次磁盘m+1次（m级索引）】</p><p>【访问某条记录时，首先要访问索引块找到对应数据块的物理地址，为了加快文件的访问速度，通常将文件的索引块读入到内存的缓冲区中】</p><p>解决索引块过小无法支持大文件办法：</p><p>1) 链接方案：</p><p>【通常一个索引块为一个磁盘块，因此可以直接读写；为了支持大文件，可以将多个索引块链接起来】</p><p>2) 多级索引</p><p>3) 混合索引：</p><p>UNIX的索引结点包含13个地址项，10个地址项用于直接地址，一个用于一次间接地址，一个用于二次间接地址，一个用于三次间接地址。</p><p>​</p><h2 id="Q42：文件实现——存储空间管理："><a href="#Q42：文件实现——存储空间管理：" class="headerlink" title="Q42：文件实现——存储空间管理："></a>Q42：文件实现——存储空间管理：</h2><p>l 文件存储空间的划分和初始化：</p><p>【一般来说，一个文件存在于一个文件卷中，一个文件卷可以是物理盘的一部分，也可以是整个物理盘，支持超大型文件的文件卷也可由多个物理盘组成】、</p><p>【在一个文件卷中，文件数据信息空间（文件区）和存放文件控制信息FCB的空间（目录区）是分离的】</p><p>【逻辑卷在提供文件服务前，必须由对应的文件程序进行初始化，划分好文件区和目录区，建立空闲空间管理表格以及存放逻辑卷信息的超级块】</p><p>​</p><p>①空闲表法：</p><p>【属于连续分配方式】</p><p>【为每个文件分配一块连续的存储空间】</p><p>【系统为外存上所有空闲区建立一张空闲盘块表，每个空闲区对应一个空闲表项】</p><p>【表项由表项序号、该空闲区的第一个盘块的盘块号、该区的空闲盘块数组成；所有空闲区按起始盘块号递增顺序排列】</p><p>​</p><p>②空闲链表法：</p><p>1) 空闲盘块链：</p><p>【将所有空闲的盘块以盘块为单位拉成一条链】</p><p>【分配和回收操作简单，但为一个文件分配盘块时可能要重复多次操作】</p><p>2) 空闲盘区链：</p><p>【将所有空闲的盘块以盘区（包含若干个空闲盘块）为单位拉成一条链】</p><p>【在每个盘区除了有指向下一块盘区的指针还有指明本盘块大小（盘块数）信息】</p><p>③位示图法：</p><p>【用二进制的一位来表示磁盘中一个盘块的分配与回收，“1”表示已分配，“0”表示空闲】</p><p>④成组链表法：</p><p>【空闲表法和空闲链表法都不是用于大型文件系统，主要是因为表长太大】</p><p>【把顺序的n个空闲扇区地址保存在第一个空闲扇区内，其后的一个空闲扇区内则保存另一个顺序空闲扇区的地址，依次继续】</p><p>​</p><p>【表示文件存储器空闲空间的“位向量”表或第一个成组链块，以及卷中文件区和目录区的划分信息都需存放在存储器中，一般放在卷头位置，在UNIX系统中称为超级块】</p><p>【在对卷中的文件进行操作之前，超级块应预先读入系统空闲的主存，并经常保持主存中的超级块与辅存卷中的超级块的一致性】</p><p>​</p><h2 id="Q43：磁盘结构"><a href="#Q43：磁盘结构" class="headerlink" title="Q43：磁盘结构"></a>Q43：磁盘结构</h2><p>磁盘：由表面涂有磁性物质的金属或塑料构成的圆形盘片。</p><p>【通过一个称为磁头的导体线圈来从磁盘上存取数据】</p><p>【在读写期间，磁头固定，磁盘在下面进行高速旋转】</p><p>【磁盘的密度从最外道向里增加，磁盘的存储能力受限于最内道的最大记录密度】</p><p>磁道：磁盘上的数据存储在一组同心圆中。</p><p>【磁道和磁头一样宽，一个盘面上有上千个磁道】</p><p>扇区：一个扇区称为一个盘块。</p><p>【一个磁道分为几百个扇区】</p><p>【每个扇区固定存储大小（通常为512B）】</p><p>【磁道间、扇区间存在间隙，以避免精度错误】</p><p>磁盘驱动器：磁头臂、用于旋转磁盘的主轴、用于数据输入/输出的电子设备组成。</p><p>【多个磁盘垂直重叠构成磁盘组，所有盘面上相同位置的磁道构成柱面】</p><p>【每个盘面对应一个磁头，所有的磁头固定在一起，与磁盘中心距离相同且一起移动】</p><p>磁盘地址：柱面号·盘面号·扇区号</p><p>【扇区是磁盘可寻址的最小存储单位】</p><p>按磁头相对于盘片的径向是否可以移动分：</p><p>固定头磁盘（每个磁道一个磁头）、活动头磁盘</p><p>按磁盘在磁盘驱动器中是否可以更换分：</p><p>固定盘磁盘、可换盘磁盘</p><p>​</p><h2 id="Q44：一次磁盘读-写的时间"><a href="#Q44：一次磁盘读-写的时间" class="headerlink" title="Q44：一次磁盘读/写的时间"></a>Q44：一次磁盘读/写的时间</h2><p>①寻道时间：</p><p>活动头磁盘在读写信息前，将磁头移动到指定磁道的时间。</p><p>【包括将磁头移到指定磁道所需的时间及启动磁头臂的时间（约为2ms）】</p><p>②旋转延迟时间：</p><p>将磁头定位到某一扇区所需的时间。</p><p>【1/(2r)，磁盘转速r】</p><p>③传输时间：</p><p>从磁盘读出或向磁盘写入的时间。</p><p>【取决于要读/写的字节数b以及磁盘转速r，b/(rN)，N是一个磁道上的字节数】</p><p>​</p><p>优化方法：</p><p>针对寻道时间：磁盘调度算法。</p><p>针对旋转延迟时间：对盘面的扇区交替编号及磁盘组的不同盘面错位命名。</p><h2 id="Q45：磁盘调度算法"><a href="#Q45：磁盘调度算法" class="headerlink" title="Q45：磁盘调度算法"></a>Q45：磁盘调度算法</h2><p>①FCFS：</p><p>【进程请求访问磁盘的先后顺序】【具有公平性】</p><p>【若只有少量进程需要访问，且大部分请求都是访问簇聚的文件扇区，则有望达到较好的性能】</p><p>【若有大量进程竞争使用磁盘，则FCFS算法趋近于随机调度】</p><p>②SSTF：</p><p>【磁道与当前磁头所在磁道距离最近】【会产生“饥饿”现象】</p><p>③SCAN：</p><p>【在磁头当前移动方向上与磁头所在磁道距离最近的磁道】</p><p>【SCAN算法对最近访问过的磁道具有不公平性，因此在访问局部性方面不如FCFS、SSTF】</p><p>【偏向于处理接近最里或最外的磁道的请求】</p><p>④C-SCAN：</p><p>【在SCAN基础上，磁头在回返时快速移动至起始端，而不服务任何请求】</p><p>⑤LOOK：</p><p>【在SCAN基础上，要求磁头只需移动到最远端的一个请求后就立即返回，不需要到达磁盘终点】</p><p>⑥C-LOOK：</p><p>【在C-SCAN基础上，要求磁头只需移动到最远端的一个请求后就立即返回，不需要到达磁盘终点】</p><p>⑦N-STEP-SCAN：</p><p>【在SCAN基础上，将请求队列的所有请求划分为长度为N的子队列，处理顺序以FIFO进行】</p><p>【当正在处理一个子队列时，新到的I/O请求加入到其他的子队列中】</p><p>​ ⑧FSCAN：</p><p>【使用两个子队列，扫描开始时，所有的请求都在一个子队列中，其后到达的所有新请求都放在另一个子队列中】</p><p>【用SCAN算法处理旧请求，新请求的处理延迟在旧请求之后】</p><p>​</p><h2 id="Q46：磁盘管理"><a href="#Q46：磁盘管理" class="headerlink" title="Q46：磁盘管理"></a>Q46：磁盘管理</h2><p>①磁盘的初始化：</p><p>【一块新的磁盘只是一个含磁性物质的空白圆片】</p><p>【低级格式化/物理分区：在磁盘存储数据之前，它必须划分成扇区以便磁盘控制器进行读/写操作】</p><p>【低级格式化为磁盘的每个扇区采用了特别的数据结构，每个扇区的数据结构由头部、数据区域（通常为512B）、尾部组成】</p><p>【头部和尾部包含了一些磁盘控制器所使用的信息】</p><p>为了使用磁盘存储文件，OS还需将自己的数据结构保存在磁盘上：</p><p>1) 将一个磁盘分成由一个或多个柱面组成的分区</p><p>2) 对物理分区进行逻辑格式化，OS将初始化文件系统的数据结构存储在磁盘上，包括空闲和已分配的空间及一个初始为空的目录</p><p>②引导控制块&amp;分区控制块：</p><p>计算机在启动时需运行一个初始化程序（自举程序），它初始化CPU、寄存器、设备控制器和内存等，接着启动OS。为此，自举程序应找到磁盘上的OS内核，载入内存，并转到起始地址，从而开始OS运行。</p><p>【自举程序通常保存在ROM中，为了避免改动自举程序而需要改变ROM硬件的问题，只在ROM中保留很小的自举装入程序】</p><p>【将完整的自举程序保存在磁盘的启动块上，启动块位于磁盘的固定位置，包含启动分区的磁盘称为启动磁盘/系统磁盘】</p><p>引导控制块包含系统从该分区引导OS所需的信息。</p><p>【若磁盘无OS则其为空】</p><p>【通常为分区的第一块】</p><p>【UFS称为引导块，NTFS称为分区引导扇区】</p><p>分区控制块包括分区详细信息。</p><p>如分区的块数、块的大小、空闲块的数量、空闲FCB数量等。</p><p>【UFS称为超级块，NTFS称为主控文件表】</p><p>③坏块：</p><p>【由于磁盘有移动部件且容错能力弱，因此容易导致一个或多个扇区损坏】</p><p>【对于简单磁盘，如电子集成驱动器IDE，坏扇区可手动处理。坏扇区在FAT表会标明，因此程序不会使用】</p><p>【对于复杂磁盘，如小型计算机系统接口SCSI，其控制器维护一个磁盘坏块链表】【在出厂低级格式化时就已初始化】</p><p>【扇区备用：低级格式化将一些扇区保留作为备用，对OS透明，控制器可用备用块来逻辑替换坏块】</p><p>​</p><h2 id="Q47：内存结构"><a href="#Q47：内存结构" class="headerlink" title="Q47：内存结构"></a>Q47：内存结构</h2><p>内存分区：包含所有安装分区的信息。</p><p>内存目录结构用来保存最近访问过的目录信息。对于安装分区的目录，可以包括一个指向分区表的指针。</p><h2 id="Q48：文件系统实现概述"><a href="#Q48：文件系统实现概述" class="headerlink" title="Q48：文件系统实现概述"></a>Q48：文件系统实现概述</h2><p>为了创建一个文件，应用程序调用逻辑文件系统。它将为文件分配一个新的FCB，并把相应目录写入内存，用新的文件名更新目录和FCB，并将结果写回磁盘。</p><p>一旦文件创建就能用于I/O，不过在使用文件之前要打开文件。</p><p>调用open将文件名传给文件系统，文件系统根据给定文件名搜索目录结构。</p><p>【为了加快检索速度，部分目录缓存在内存中】</p><p>找到文件后，将FCB复制到系统范围的打开文件表。</p><p>【该表不仅存储FCB，还存储打开该文件进程数目的条目】</p><p>然后，在进程的打开文件表中增加一个条目，并通过指针将系统范围的打开文件表中的相应条目和其他域（文件当前位置的指针、文件的打开模式等）相连。</p><p>调用open返回一个指向进程的打开文件表中合适条目的指针，所有的文件操作都通过该指针进行。</p><p>【对于访问打开文件表的索引，UNIX称为文件描述符，Windows2000称为文件句柄】</p><p>当一个进程关闭文件时，就会删除进程的打开文件表中的一个条目，系统范围打开文件表中的打开数递减。</p><p>当打开文件的所有用户都关闭了一个文件时，更新的文件信息会复制在磁盘的目录结构中，系统范围打开文件表相应的条目也会删除。</p><p>【在实际中，系统调用open时会首先检索系统范围打开文件表，以确保文件是否已被其他进程所使用】</p><p>​</p><p>​</p><h1 id="CHAPTER-5"><a href="#CHAPTER-5" class="headerlink" title="CHAPTER 5"></a>CHAPTER 5</h1><h2 id="Q49：I-O设备分类"><a href="#Q49：I-O设备分类" class="headerlink" title="Q49：I/O设备分类"></a>Q49：I/O设备分类</h2><p>按使用属性：</p><p>①人机交互设备：</p><p>【如打印机、键盘、鼠标、显示器等】</p><p>【数据交换速度相对较慢】</p><p>【通常以字节为单位进行数据交换】</p><p>②存储设备：</p><p>【如磁盘、磁带、光盘等】</p><p>【数据交换速度相对较快】</p><p>【通常以多字节组成的块为单位进行数据交换】</p><p>③网络通信设备：</p><p>【如各种网络接口、调制解调器等】</p><p>按信息交换单位：</p><p>①块设备：</p><p>【如磁盘等】</p><p>【有结构设备】</p><p>【传输速率较高、可寻址，即对它可任意读/写某一块】</p><p>【输入/输出时采用DMA控制方式】</p><p>②字符设备：</p><p>【如打印机等】</p><p>【无结构设备】</p><p>【传输速率低、不可寻址】</p><p>【输入/输出时采用中断驱动方式】</p><p>按传输速率：</p><p>①低级设备：</p><p>【如键盘、鼠标等】</p><p>【每秒几字节至几百字节】</p><p>②中级设备：</p><p>【如打印机等】</p><p>【每秒几千字节至上万字节】</p><p>③高级设备：</p><p>【如磁盘机、磁带机、光盘机等】</p><p>【每秒几百千字节至千兆字节】</p><p>按访问方式：</p><p>①基于互斥访问的互斥设备</p><p>②基于分时共享访问的共享设备：</p><p>【如磁盘等】【必须可寻址、可随机访问】</p><p>③基于SPOOLING技术访问的虚拟设备：</p><p>​</p><h2 id="Q50：I-O控制方式"><a href="#Q50：I-O控制方式" class="headerlink" title="Q50：I/O控制方式"></a>Q50：I/O控制方式</h2><p>①程序直接控制方式：</p><p>【计算机从外部设备读取数据到存储器，每次读一个字的数据，对读入的每个字，CPU需要对外设状态进行循环检查，直到确定该字已经在I/O控制器的数据寄存器中】</p><p>【CPU之所以不断地循环检查外设状态，是因为CPU未采用中端机构，使得I/O设备无法向CPU报告已完成一个字的输入操作】</p><p>【简单易于实现，但由于CPU和I/O设备只能串行工作，导致CPU的利用率比较低】</p><p>②中断驱动方式：</p><p>【允许I/O设备主动打断CPU地运行并请求提供服务】</p><p>从I/O控制器角度看，</p><p>【I/O控制器从CPU接收一个读命令，然后从外围设备读数据】</p><p>【一旦数据读入该I/O控制器的数据寄存器，便通过控制线给CPU发出一个中断信号，表示数据已准备好，然后等待CPU请求该数据】</p><p>【I/O控制器接收到CPU发出的数据请求后，将数据放到数据总线上，传至CPU的寄存器中】</p><p>从CPU角度看，</p><p>【CPU发出读命令，然后保存当前运行程序的上下文，转而执行其他程序】</p><p>【在每个指令周期的末尾，CPU检查中断；当有来自I/O控制器的中断时，CPU保存当前正在运行进程的上下文，转去执行中断处理程序以处理该中断】</p><p>【这时，CPU从I/O控制器中读一个字的数据传送至寄存器，并存入主存】</p><p>【接着，CPU恢复发出I/O命令的程序或其他程序的上下文，然后继续运行】</p><p>​</p><p>③DMA控制方式：</p><p>【在I/O设备和内存间开辟直接的数据交换通路】</p><p>【基本单位是数据块】</p><p>【所传的数据是从设备直接到内存的，或者相反】</p><p>【仅在传送一个数据块或多个数据块的开始和结尾，才需CPU干预，整块数据的传送是在DMA控制器下完成的】</p><p>【CPU接收到I/O设备的DMA请求时，它给I/O控制器发出一条命令，启动DMA控制器，然后转而执行其他工作】</p><p>【之后CPU将控制权交给DMA控制器，DMA控制器直接与存储器交互，传送整个数据块，该过程不需CPU参与】</p><p>【传送完成后，DMA控制器发送一个中断信号给CPU】</p><p>​</p><p>n DMA控制器中的寄存器：</p><p>1) 控制寄存器/状态寄存器(CR)：</p><p>【用于接收从CPU发出的I/O命令或有关控制信息，或设备的状态】</p><p>2) 数据寄存器(DR)：</p><p>【用于暂存从设备到内存或从内存到设备的数据】</p><p>3) 数据计数器(DC)：</p><p>【存放本次传送数据的字节数】</p><p>4) 内存地址寄存器(MAR)：</p><p>【在输入时，存放从设备到内存的起始目标地址】</p><p>【在输出时，存放从内存到设备的内存源地址】</p><p>​</p><p>④通道控制方式：</p><p>【I/O通道是指专门负责输入/输出的处理机】</p><p>【通道的指令类型单一】</p><p>【通道所执行的通道程序是放在主机的内存中】</p><p>【没有自己的内存，与CPU共享内存】</p><p>【把对一个数据块的读/写为单位的干预减少为对一组数据块的读/写和有关管理和控制为单位的干预】</p><p>【实现CPU、通道和I/O设备并行操作】</p><p>【当CPU要执行一组相关读/写操作及有关控制时，只需向I/O通道发送一条I/O指令，指明所要执行的通道程序的首地址和要访问的设备】</p><p>【通道接到该指令后，执行通道程序便可完成CPU指定的I/O任务，数据传送结束时向CPU发送中断请求】</p><p>与DMA控制方式区别：</p><p>DMA方式需要CPU来控制传输的数据块大小、传输内存位置，而通道方式中由通道控制；</p><p>每个DMA控制器对应一个设备，而一个通道可控制多个设备与内存进行数据交换；</p><p>通道类型：字节多路通道、数组选择通道、数组多路通道</p><h2 id="Q51：I-O系统层次结构"><a href="#Q51：I-O系统层次结构" class="headerlink" title="Q51：I/O系统层次结构"></a>Q51：I/O系统层次结构</h2><p>①用户层I/O软件：</p><p>【实现与用户交互的接口】</p><p>【用户可以直接调用在用户层提供的、与I/O有关的库函数，对设备进行操作】</p><p>【用户可以通过系统调用的方式请求OS提供服务】</p><p>②设备独立软件：</p><p>【实现用户程序与设备驱动器的统一接口、设备命令、设备保护、设备的分配与回收、同时为设备的管理和数据的传送提供必要的存储空间】</p><p>1) 执行所有设备的公共操作：</p><p>【设备的分配与回收、将逻辑设备名映射成物理设备名、对设备进行保护，避免用户直接访问设备、缓冲管理、差错控制、提供独立于设备的大小统一的逻辑块】</p><p>2) 向用户层（文件层）提供统一接口：</p><p>【例如对各种设备的读/写操作，在应用程序中统一使用read/write命令等】</p><p>设备独立性，即设备无关性，使得应用程序独立于具体使用的物理设备。</p><p>【在应用程序中使用逻辑设备名来使用某些设备，而在系统实际执行的过程中，需要将逻辑设备名映射成物理设备名使用】</p><p>【使用逻辑设备名的好处：1)增加设备分配的灵活性2)易于实现I/O重定向（是指用于I/O操作的设备可更换，无需改变应用程序）】</p><p>​</p><p>③设备驱动软件：</p><p>【具体实现系统对设备发出的命令】</p><p>【每类设备配置一个设备驱动程序】</p><p>【是I/O进程和设备控制器之间通信程序，通常以进程形式存在】</p><p>④中断处理程序：</p><p>【进行进程上下文切换、对处理中断信号源进行测试、读取设备状态、修改进程状态等】</p><p>⑤硬件层：</p><p>【I/O设备通常包括一个机械部件和一个电子部件】</p><p>【为了达到设计的模块性和通用性，一般将其分开】</p><p>【电子部件称为设备控制器（适配器），在个人计算机中，通常是一块插入主板扩充槽的印刷电路板】</p><p>【机械部件即为设备本身】</p><h2 id="Q52：设备控制器"><a href="#Q52：设备控制器" class="headerlink" title="Q52：设备控制器"></a>Q52：设备控制器</h2><p>【设备控制器通过寄存器与CPU通信，有的计算机中，这些寄存器占用内存的一部分，称为内存映像I/O；而在其他计算中，采用I/O专用地址，寄存器独立编址】</p><p>​</p><p>【OS向控制器寄存器写命令字来执行I/O功能】</p><p>【控制器接收到一条命令时，CPU转而执行其他工作，而让设备控制器自行完成I/O功能】</p><p>【当命令执行完毕后，控制器发出一个中断信号，OS重新获得CPU的控制权并检查运行结果】</p><p>【CPU仍旧从控制权中读取信息来获得执行结果和设备的状态信息】</p><p>​</p><p>设备控制器的主要功能：</p><p>①接收和识别CPU或通道发出的命令</p><p>②实现数据交换</p><p>【设备和控制器间的数据传输】</p><p>【通过数据总线或通道，控制器和内存间的数据传输】</p><p>③发现和记录设备以及设备自身状态，供CPU处理使用</p><p>④设备地址识别</p><p>设备控制器组成：</p><p>①设备控制器与CPU接口</p><p>【该接口有三类信号线：数据线（DR、CR）、地址线、控制线】</p><p>②设备控制器与设备接口</p><p>【一个接口连接一个设备】</p><p>【每个接口存在数据、状态、控制三种类型的信号】</p><p>③I/O控制逻辑</p><p>【用于实现设备控制】</p><p>【通过一条控制线和CPU交互，对从CPU收到的I/O命令进行译码】</p><p>【CPU启动设备时，将启动命令发送给设备控制器，同时通过地址线将地址发送给控制器，由控制器的I/O逻辑对地址进行译码，并相应地选择设备进行控制】</p><h2 id="Q53：I-O核心子系统"><a href="#Q53：I-O核心子系统" class="headerlink" title="Q53：I/O核心子系统"></a>Q53：I/O核心子系统</h2><p>I/O子系统：</p><p>由于I/O设备种类繁多，功能和传输速率也有较大差异，因此需要多种办法来对设备进行控制，这些方法共同组成OS内核的I/O子系统。</p><p>​ 主要的功能有：</p><p>I/O调度、磁盘高速缓存和缓冲区、设备的分配与回收、SPOOLing系统等。</p><h2 id="Q54：I-O调度"><a href="#Q54：I-O调度" class="headerlink" title="Q54：I/O调度"></a>Q54：I/O调度</h2><p>【应用程序所发出的系统调用顺序不一定是最佳的，通过I/O调度来改善系统整体系统，使进程间公平地对共享设备进行访问，减少I/O完成所需要的平均等待时间】</p><p>【OS为每个设备维护一个请求队列来实现调度】</p><p>【当一个应用程序执行I/O调用阻塞时，该请求就加到相应设备的请求队列上】</p><p>​</p><h2 id="Q55：高速缓存及缓冲区："><a href="#Q55：高速缓存及缓冲区：" class="headerlink" title="Q55：高速缓存及缓冲区："></a>Q55：高速缓存及缓冲区：</h2><p>l 磁盘高速缓存：</p><p>【提供磁盘的I/O速度】</p><p>【逻辑上在磁盘，物理上在内存】</p><p>【高速缓存上有的数据，低速设备上必然有】</p><p>在内存的两种形式：</p><p>1) 在内存开辟一个单独的、大小固定的存储空间作为磁盘高速缓存；</p><p>2) 把未利用的内存空间作为一个缓冲池，供请求调页系统和磁盘I/O时共享；</p><p>​</p><p>l 缓冲区：</p><p>n 引入缓冲区的目的：</p><p>1) 缓和CPU与I/O设备速度不匹配的矛盾</p><p>2) 减少CPU的中断频率，放宽对CPU中断响应时间的限制</p><p>3) 解决基本数据单元（即数据粒度）不匹配的问题</p><p>4) 提供CPU和I/O设备之间的并行性</p><p>n 实现方法：</p><p>1) 采用硬件缓冲器，价格高昂，一般不采用；</p><p>2) 内存建立缓冲区；</p><p>n 特点：</p><p>只有当缓冲区为空时才可以写，只有当缓冲区满时才可以读；读操作是一次性的操作。</p><p>​</p><p>n 单缓冲：</p><p>【在设备和处理机之间建立一个缓冲区，设备与处理机交换数据时，先把交换数据写入缓冲区，然后设备或处理机从缓冲区中将数据拿走】</p><p>在研究各种缓冲技术对每块的处理时间时，首先假定一个初始状态，然后计算下一次达到相同状态所需的时间。</p><p>【初始状态：工作区满的，缓冲区为空】</p><p>（T：在块设备输入时，假定从磁盘把一块数据输入到缓冲区的时间为T）</p><p>（M：OS将该缓冲区的数据传送到用户区的时间为M）</p><p>（C：CPU对这一块数据的处理时间为C）</p><p>T&gt;C时，</p><p>把一块数据从磁盘输入缓冲区，花费时间为T，此时缓冲区已满，而工作区为空；因此将缓冲区数据传送到工作区花费时间为M，此时工作区满、缓冲区为空，故对一个数据块的处理时间为T+M。</p><p>T&lt;C时，</p><p>把一块数据从磁盘输入缓冲区，花费时间为T，此时缓冲区已满，而工作区非空，因此等待CPU完成数据处理，此时整体花费时间为C，缓冲区为满，工作区为空；和上述操作相同，得到对一个数据块处理时间为C+M。</p><p>故，单缓冲对一个数据块的处理时间为 (max(T,C)+M)。</p><p>n 双缓冲：</p><p>【初始状态：工作区为空的，缓冲区1满，缓冲区2为空】</p><p>T&gt;M+C时，</p><p>此时将缓冲区1的数据传送到工作区，而磁盘向缓冲区2输入数据块；当数据从缓冲区1传送到工作区后，此时花费时间为M，而缓冲区2未冲满，继续将数据从磁盘冲入缓冲区2，此时CPU处理工作区的数据;当CPU处理完工作区数据时，缓冲区2未冲满，继续将数据从磁盘冲入缓冲区2，直至缓冲区2冲满，此时总共花费时间为T，缓冲区2满，缓冲区1为空，工作区为空，故对一个数据块的处理时间为T。</p><p>T&lt;M+C时，</p><p>此时经历M时间，缓冲区1将数据传送到工作区，然后经历C时间，CPU处理数据，工作区为空。此时工作区为空，缓冲区2满，缓冲区1为空，故对一个数据块的处理时间为M+C。</p><p>​</p><p>【注意：当在T时间时，缓冲区2冲满，此时若缓冲区1为空，那么由于只有一个I/O设备，缓冲区1虽然为空，但不能冲入数据】</p><p>【只有当CPU处理完缓冲区1中的数据，此时缓冲区1才可以冲入数据】</p><p>故，双缓冲对一个数据块的处理时间为max(T,M+C)。</p><p>​</p><p>n 循环缓冲：</p><p>【包含大小相等的缓冲区，每个缓冲区中有一个链接指针指向下一个缓冲区，最后一个缓冲区的指针指向第一个缓冲区】</p><p>【循环缓冲用于输入/输出时，还需要两个指针in和out】</p><p>【in指针指向可以输入数据的第一个空缓冲区】</p><p>【out指针指向可以输出数据的第一个满缓冲区】</p><p>n 缓冲池：</p><p>【由多个系统公用的缓冲区组成】</p><p>缓冲区按其使用状况分为三个队列：</p><p>空缓冲队列、输入队列、输出队列。</p><p>还应具有四种缓冲区：</p><p>用于收容输入数据的工作缓冲区、用于提取输出数据的工作缓冲区、用于提取输入数据的工作缓冲区、用于收容输出数据的工作缓冲区。</p><p>【当输入进程需要输入数据时，从空缓冲队列的队首取下一个缓冲区作为收容输入数据的工作缓冲区，将要输入的数据冲入，然后将其挂在输入队列的队尾】</p><p>【当计算进程需要数据时，从输入队列取下一个缓冲区作为提取输入数据的工作缓冲区，计算进程从中提取数据，提取完后将其挂在空缓冲队列的队尾】</p><p>【当计算进程需要输出数据时，从空缓冲队列队首取下一个缓冲区作为收容输出数据的工作缓冲区，将要输出的数据冲入，然后将其挂在输出队列的队尾】</p><p>【当要输出数据时，从输出队列取下一个缓冲区作为提取输出数据的工作缓冲区，将数据输出完后，将其挂在空缓冲队列的队尾】</p><p>​</p><h2 id="Q56：设备的分配与回收"><a href="#Q56：设备的分配与回收" class="headerlink" title="Q56：设备的分配与回收"></a>Q56：设备的分配与回收</h2><p>①设备分配的数据结构：</p><p>设备控制表DCT：</p><p>【一个设备控制表描述了一个设备，控制表中表项为设备的各个属性】</p><p>控制器控制表COCT：</p><p>【现代OS的I/O控制采用的都是通道方式，因此在COCT的某个表项中存放指向相应CHCT的指针】</p><p>通道控制表CHCT：</p><p>【由于通道可为多个设备控制器服务，CHCT中必有一个指针指向一个表，该表上的信息是CHCT提供服务的设备控制器】</p><p>系统设备表SDT：</p><p>【整个系统只有一张SDT，记录已连接到系统中的所有物理设备的情况，每个物理设备占一个表目】</p><p>​</p><p>②设备分配策略：</p><p>n 分配原则参考因素：</p><p>I/O设备的固有属性、I/O设备的分配算法、I/O设备分配的安全性、I/O设备的独立性。</p><p>​</p><p>n 设备分配原则：</p><p>既要充分发挥设备的使用效率，又要避免造成进程死锁，还要将用户程序和具体的物理设备分开。</p><p>n 设备分配方式：</p><p>1) 静态分配：</p><p>【主要用于对独占设备的分配】</p><p>【在用户作业开始执行之前，由系统一次性分配该作业所要求的的全部设备、控制器（如通道等）】</p><p>【一旦分配，这些设备、控制器就会一直被该作业占用，直至该作业被撤销】</p><p>【不会出现死锁，但设备的使用效率低】</p><p>2) 动态分配：</p><p>【在进程执行的过程中根据需求进行分配】</p><p>【当进程需要设备时，通过系统调用命令向系统提出设备请求，由系统按事先规定的策略为进程分配所需的设备、I/O控制器】</p><p>【一旦用完，立即释放】</p><p>【有利于提高设备的使用效率，但有可能会造成进程死锁】</p><p>​</p><p>n 设备分配算法：用于动态分配的算法：先请求先分配、优先级高者优先等。</p><p>【独占设备：即可采用静态分配，又可采用动态分配，但往往采用静态分配】</p><p>【共享设备：一般采用动态分配方式，但在每个I/O传输的单位时间内只能被一个进程所占有】</p><p>​</p><p>③设备分配的安全性：</p><p>【设备分配的安全性是指设备分配中应防止发生进程死锁】</p><p>1) 安全分配方式：</p><p>【每当发出I/O请求后便立即进入阻塞态】</p><p>【直至其I/O操作完成才被唤醒】</p><p>【优点：设备分配安全】</p><p>【缺点：CPU和I/O设备时串行工作的（对同一进程而言）】</p><p>2) 不安全的分配方式：</p><p>【进程发出I/O请求后继续执行，仅当进程所请求的设备已被占用时才进入阻塞态】</p><p>【优点：一个进程可以同时操作多个设备】</p><p>【缺点：可能会造成进程死锁】</p><p>④逻辑设备名到物理设备名的映射：</p><p>【为了实现设备独立性，在系统中设置一张逻辑设备表LUT，用于将逻辑设备名映射成物理设备名】</p><p>【LUT的表项包括：逻辑设备名、物理设备名、设备驱动程序的入口地址】</p><p>【当进程用逻辑设备名来请求分配设备时，系统为其分配相应的物理设备，并在LUT中增加一个表项】</p><p>【以后进程再利用逻辑设备名来请求I/O操作时，系统通过查找LUT来寻找相应的物理设备和设备驱动程序】</p><p>​</p><p>在系统中建立逻辑设备表的两种方式：</p><p>1) 在整个系统中建立一张LUT</p><p>【所有的设备分配情况都在该表中，因此不允许有相同的逻辑设备名，只适用于单用户系统】</p><p>2) 为每个用户建立一张LUT</p><p>【用户在登录时，系统为该用户建立一个进程，同时也为之建立一张LUT，并将其存放于该进程的PCB中】</p><h2 id="Q57：SPOOLING技术（假脱机技术）"><a href="#Q57：SPOOLING技术（假脱机技术）" class="headerlink" title="Q57：SPOOLING技术（假脱机技术）"></a>Q57：SPOOLING技术（假脱机技术）</h2><p>脱机输入/输出技术：</p><p>（为了缓和CPU的高速性和I/O设备的低速性之间的矛盾而引入）</p><p>该技术利用专门的外围控制机，将低速I/O设备上的数据传送到高速磁盘上，或者相反。</p><p>​</p><p>SPOOLing又称假脱机输入/输出技术，是OS中采用的一项将独占设备改造成共享设备的技术。</p><p>【实质上就是对I/O操作进行批处理】</p><p>【以空间换时间的技术】</p><p>【广泛的应用于多用户系统和局域网络】</p><p>【特点：提高了I/O的速度；将独占设备改造为共享设备；实现了虚拟设备功能】</p><p>输入井：</p><p>【位于磁盘】</p><p>【模拟脱机输入时的磁盘，用于收容I/O设备输入的数据】</p><p>输出井：</p><p>【位于磁盘】</p><p>【模拟脱机输出时的磁盘，用于收容用户进程输出的数据】</p><p>输入缓冲区：</p><p>【位于内存】</p><p>【暂存由输入设备送来的数据，以后在传送到传送井】</p><p>输出缓冲区：</p><p>【位于内存】</p><p>【暂存由输出井送来的数据，以后在传送到输出设备】</p><p>输入进程：</p><p>【模拟脱机输入时的外围控制机】</p><p>【将用户要求输入的数据从输入机通过输入缓冲区再送到输入井。当CPU需要输入数据时，直接将数据从输入井读入内存】</p><p>输出进程：</p><p>【模拟脱机输出时的外围控制机】</p><p>【将用户要求输出的数据从内存送到输出井，待输出设备空闲时，在将输出井中的数据经过输出缓冲区送到输出设备】</p><p>​</p><p>用户请求打印输出时，SPOOLing系统做：</p><p>①由输出进程在输出井中为之申请一个空闲磁盘块区，并将要打印的数据送入其中；</p><p>②输出进程再为用户申请一张空白的用户请求打印表，并将用户的打印要求填入其中，在将该表挂到请求打印队列上。</p><h1 id="CHAPTER-6"><a href="#CHAPTER-6" class="headerlink" title="CHAPTER 6"></a>CHAPTER 6</h1><h2 id="Q58：RAID技术"><a href="#Q58：RAID技术" class="headerlink" title="Q58：RAID技术"></a>Q58：RAID技术</h2><p>用于解决二级存储传送速度和内存、处理机传送速度的不匹配的技术。</p><p>【RAID将一列物理磁盘驱动视为一个逻辑驱动】</p><p>【数据是以条带的形式分布在各个磁盘驱动上】</p><p>【使用冗余磁盘保存奇偶校验信息，当一个磁盘失效时，数据具有可恢复性】</p><p>RAID技术实现高数据传送能力及实现高I/O请求率：</p><p>①对于需要高传送率的应用程序而言，应满足：</p><p>1) 高数据传送能力必须存在于主机存储器和单个磁盘驱动器的整个路径中，包括内部控制总线、主机系统I/O总线、I/O适配器、主机存储器总线。</p><p>2) 应用程序必须能够产生有效地使用磁盘阵列的I/请求。</p><p>若请求的是大量逻辑上连续的条带，则单个I/O请求可并行处理，提高了数据传送能力。</p><p>②在面向事务处理环境下，用户对响应时间的关注超过了对传送速率：</p><p>对于一个关于少量数据的单个I/O请求，I/O时间主要由寻道时间和延迟时间决定；</p><p>在面向事务处理环境中，每秒可能有上百条I/O请求。磁盘阵列通过平衡多个磁盘的I/O负载来提供较高的执行速率；</p><p>只有存在多个未完成的I/O请求，才能实现有效的负载平衡，即存在多个进行I/O请求的应用进程或存在一个能产生多个异步I/O请求的面向事务的应用程序；</p><p>条带大小也可影响I/O请求率，当条带相对较大时，一个I/O请求请求的数据可能在一个条带中，那么多个I/O请求请求的数据位于不同的条带上，即这些I/O请求可以并行处理，提高了I/O请求率；</p><p>冗余性：</p><p>发生磁盘故障时，通过访问奇偶校验磁盘，并从其余设备中重建数据。替换失效磁盘时，丢失的数据可恢复到新的驱动器上，并继续执行。</p><p>l RAID 0</p><p>【用户数据和系统数据分布在所有磁盘中】</p><p>相对于单一大磁盘而言，当两个不同的I/O请求请求数据而被挂起时，被请求的数据可能位于两个不同的磁盘上，因此这两个I/O请求可以并行发出，减少因I/O排队等待产生的平均时间。</p><p>【数据以条带的形式分布在所有可用磁盘上】</p><p>所有的用户数据和系统数据被视为存储在一个逻辑磁盘上，这个逻辑磁盘被划 分为多个条带(strip)；</p><p>一个条带可能是物理块、扇区或其他某种单元；</p><p>一组逻辑上连续的条带，若恰好一个条带映射到一个阵列成员磁盘上，那么称其为一条条带(stripe)；</p><p>当一个I/O请求请求的数据分布在不同的磁盘上时，这个I/O请求可以并行处理，减少了I/O的传送时间。</p><p>l RAID 1</p><p>【通过临时复制所有数据来实现冗余】</p><p>【一个逻辑条带映射到两个单独的磁盘上，阵列包含磁盘相同数据的镜像磁盘】</p><p>①对于读请求，可能由包含被请求数据的任意一个磁盘提供服务，而不管哪个磁盘具有最短的寻道时间和延迟时间。</p><p>②对于写请求，需要对两个相应的条带进行更新。写性能由两个写操作中具有最大寻道时间和延迟时间的决定。</p><p>【RAID 1 不存在“写性能损失(write penalty)”】</p><p>③磁盘失效的恢复实现简单。即当一个磁盘失效时，可以从另一个磁盘驱动中访问数据。</p><p>【在面向事务处理环境中，若有许多读请求，则RAID1的性能接近RAID0的两倍】</p><p>【在需要高传送率的应用程序中，若请求大多为读请求，则RAID1具有比RAID0更好的性能】</p><p>l RAID 2</p><p>【使用了并行访问技术】</p><p>【条带非常小，通常只有一个字节或一个字】</p><p>【在并行访问阵列时，所有磁盘成员都参与每个I/O请求的执行】</p><p>【包含多个奇偶检验磁盘，对每个数据磁盘的相应位计算一个错误校正码】</p><p>【通常错误校正码使用汉明码，能纠正一位错误检测双位错误】</p><p>【冗余磁盘的数量和数据磁盘数量的对数成正比】</p><p>①对于一次读，所有的磁盘都被访问到，被请求的数据及相关的错误校正码被送到阵列控制器。若有一个位错误，则阵列控制器可立即识别并改正这个错误，不会减少一次读的存取时间。</p><p>②对于写操作，必须访问所有的数据磁盘和奇偶检验磁盘。</p><p>【单个磁盘和磁盘驱动器的可靠性很高时，RAID2往往会出现矫枉过正的现象】</p><p>l RAID 3</p><p>【使用了并行访问技术】</p><p>【条带非常小，通常只有一个字节或一个字】</p><p>【在并行访问阵列时，所有磁盘成员都参与每个I/O请求的执行】</p><p>【只包含一个冗余磁盘，对所有数据磁盘的相应位异或计算一个奇偶检验码】</p><p>①缩减模式：磁盘失效时，在该模式下仍可以得到所有的数据。</p><p>对于读操作，丢失的数据仍可在运行中通过异或运算重新生成；</p><p>对于写操作，必须为以后的重新生成维持一致的奇偶校验；</p><p>②完全模式：要从缩减模式恢复到完全模式，则要替换失效磁盘，并在新磁盘中重新生成失效磁盘的所有内部数据。</p><p>【由于条带非常小，任何一个I/O请求都会从所有的数据磁盘并行传送，数据传送速率比较高；对于大量数据的传送，性能提升也很明显】</p><p>【由于一次只能执行一个I/O请求，因此性能在面向事务处理环境中并不可观】</p><p>l RAID 4</p><p>【使用了一种独立访问技术】</p><p>【数据条带相对较大】<br>【在独立访问阵列时，每个磁盘单独运转，则不同的I/O请求可以并行地得到满足】</p><p>【对于每个数据磁盘中相应的条带计算一个逐位奇偶校验，并将奇偶校验位保存在奇偶校验磁盘相应的条带中】</p><p>【存在“写损失”，当执行很小的I/O写请求时，每当写操作发生时，阵列驱动器不仅更新用户数据，还要更新相应的奇偶校验位】</p><p>【计算新的奇偶校验时，要先读取旧的用户数据条带和相应的奇偶校验条带，然后和新的用户数据计算得到新的奇偶校验并更新这两个条带，进行两次读和写】</p><p>【对于涉及到所有数据磁盘的大数据量I/O请求，奇偶校验信息即可通过新的数据计算得到，即奇偶校验的更新可以和数据一起并行地更新】</p><p>【不管哪种情况下，每次写操作都必须涉及奇偶校验磁盘，因此奇偶校验磁盘可能成为瓶颈】</p><p>l RAID 5</p><p>【相对于RAID4，奇偶校验条带依次循环地存放于各个磁盘中】</p><p>l RAID 6</p><p>【相对于RAID4，采用了两种不同的奇偶校验计算，并保存在不同磁盘的不同块中；一种是RAID4与RAID5使用的异或计算，另一种是独立数据校验算法】</p><p>【提供极高的数据可用性，在MTTR(平均故障时间)内，三个磁盘同时失效时数据才会丢失】</p><p>【RAID6会导致严重的写性能损失】</p><h2 id="Q59：Disk-Cache"><a href="#Q59：Disk-Cache" class="headerlink" title="Q59：Disk Cache"></a>Q59：Disk Cache</h2><p>【高速缓冲存储器(cache memory)通常指比内存小但比内存快的存储器，介于内存和处理器之间；利用了局部性原理来减少平均存储器存取时间】</p><p>【磁盘高速缓存是在内存中为磁盘扇区设置的一个缓冲区，包含磁盘某些扇区的副本】</p><p>【对一特定扇区进行I/O请求时，首先会进行检测，以确保该扇区是否在磁盘高速缓存中；若在，则该请求通过这个高速缓存来满足；否则，则把被请求的扇区从磁盘读到磁盘高速缓存中】</p><p>设计考虑因素一：</p><p>当一个I/O请求从磁盘高速缓存中得到满足时，磁盘高速缓存中的数据必须传送到发送请求的进程。</p><p>实现方法：</p><p>①在内存中将这一块数据从磁盘高速缓存传送到分配给该进程的存储空间</p><p>②使用一个共享内存，传送指向磁盘高速缓存中相应项的指针</p><p>设计考虑因素二：</p><p>当一个新扇区被读入到磁盘高速缓存时，必须换出一个已存在的块。</p><p>实现算法：</p><p>①最近最久使用页面置换算法LRU：未被访问的时间最长的块。</p><p>②最不常使用页面置换算法LFU：访问次数最少的块。<br>【可通过给每个块关联一个计数器实现】</p><p>【当一个块被读入时，其计数器置为1】</p><p>【每当访问到这一块时，计数器加1】</p><p>【需要置换时选择计数器最小的块】</p><p>存在问题：可能存在着一些块，整体上看很少出现对其的访问。但当其被访问时，由于局部性原理，会在一段时间内出现多次重复访问，导致计数器的值很高，而过了这段时间计数器的值难以解释。</p><p>​ 改进：</p><p>块在逻辑上被组织成一个栈，栈顶的一部分作为新区。出现一次高速缓存命中时，被访问的块移到栈顶。若该块已在新区，则计数器值不变，否则计数器值加1。</p><p>若发生一次未命中时，访问计数器值最小，并且不再新区中的块被选择出；若有多个则选择近期最少使用的块。</p><p>存在问题：</p><p>出现一次磁盘高速缓存未命中，一个新块被读取到新区，计数器置为1；只要该块留在新区，其计数器值保持为1；最终该块的年龄超过新区，但其计数器仍为1；若该块未被很快地再次访问，则其很有可能被置换。</p><p>​</p><p>进一步改进：</p><p>把栈划分为新区、中间区和老区。位于新区的块，其访问计数器不会增加；只有老区中的块才符合置换条件。</p><p>假设有足够大的中间区，这就使得相对比较频繁地被访问到的块，在变为符合置换条件块之前有机会增加自己的访问计数器值。</p><p>​</p><p>置换发生的时间：</p><p>按需发生：只有当需要用到存储槽时才置换扇区。</p><p>预先发生：一次可以释放多个存储槽。【与写回扇区的要求相关】</p><p>【若一扇区读入到磁盘高速缓存中仅用于读，则置换时不需写回磁盘；若其已被修改，那么在换出前要写回磁盘。此时成簇地写回来降低寻道时间】</p><p>​</p><p>​</p><p>​</p><p>​</p><p>​</p><p>​</p><p>​</p><p>​</p><p>​</p><p>​</p><p>​</p><p>​</p><p>​</p><p>​</p>]]></content>
      <categories>
        <category>考研</category>
        <category>专业课</category>
        <category>操作系统</category>
        <category>计算机</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>C_NOTES_1.md</title>
    <url>/2021/03/14/c_notes/</url>
    <content><![CDATA[<h3 id="inttypes-h"><a href="#inttypes-h" class="headerlink" title="inttypes.h"></a>inttypes.h</h3><blockquote><p>标准C函数库头文件，各种整数输出输入格式转换宏<br><a id="more"></a></p><h4 id="output-format-specifier-macros"><a href="#output-format-specifier-macros" class="headerlink" title="output format specifier macros"></a>output format specifier macros</h4><div class="table-container"><table><thead><tr><th style="text-align:left">MACROS</th><th style="text-align:center">string</th></tr></thead><tbody><tr><td style="text-align:left">PRId8</td><td style="text-align:center">“hhd”</td></tr><tr><td style="text-align:left">PRId16</td><td style="text-align:center">“hd”</td></tr><tr><td style="text-align:left">PRId32</td><td style="text-align:center">“d”</td></tr><tr><td style="text-align:left">PRId64</td><td style="text-align:center">“lld”</td></tr><tr><td style="text-align:left">PRIi8</td><td style="text-align:center">“hhi”</td></tr><tr><td style="text-align:left">PRIi16</td><td style="text-align:center">“hi”</td></tr><tr><td style="text-align:left">PRIi32</td><td style="text-align:center">“i”</td></tr><tr><td style="text-align:left">PRi64</td><td style="text-align:center">“lli”</td></tr><tr><td style="text-align:left">PRIo8</td><td style="text-align:center">“hho”</td></tr><tr><td style="text-align:left">PRIo16</td><td style="text-align:center">“ho”</td></tr><tr><td style="text-align:left">PRIo32</td><td style="text-align:center">“o”</td></tr><tr><td style="text-align:left">PRIo64</td><td style="text-align:center">“llo”</td></tr><tr><td style="text-align:left">PRIu8</td><td style="text-align:center">“hhu”</td></tr><tr><td style="text-align:left">PRIu16</td><td style="text-align:center">“hu”</td></tr><tr><td style="text-align:left">PRIu32</td><td style="text-align:center">“u”</td></tr><tr><td style="text-align:left">PRIu64</td><td style="text-align:center">“llu”</td></tr><tr><td style="text-align:left">PRIx8</td><td style="text-align:center">“hhx”</td></tr><tr><td style="text-align:left">PRIx16</td><td style="text-align:center">“hx”</td></tr><tr><td style="text-align:left">PRIx32</td><td style="text-align:center">“x”</td></tr><tr><td style="text-align:left">PRIx64</td><td style="text-align:center">“llx”</td></tr><tr><td style="text-align:left">PRIX8</td><td style="text-align:center">“hhX”</td></tr><tr><td style="text-align:left">PRIX16</td><td style="text-align:center">“hX”</td></tr><tr><td style="text-align:left">PRIX32</td><td style="text-align:center">“X”</td></tr><tr><td style="text-align:left">PRIX64</td><td style="text-align:center">“llX”</td></tr></tbody></table></div><h4 id="input-format-specifier-macros"><a href="#input-format-specifier-macros" class="headerlink" title="input format specifier macros"></a>input format specifier macros</h4><div class="table-container"><table><thead><tr><th style="text-align:left">MACROS</th><th style="text-align:center">string</th></tr></thead><tbody><tr><td style="text-align:left">SCNd8</td><td style="text-align:center">“hhd”</td></tr><tr><td style="text-align:left">SCNd16</td><td style="text-align:center">“hd”</td></tr><tr><td style="text-align:left">SCNd32</td><td style="text-align:center">“d”</td></tr><tr><td style="text-align:left">SCNd64</td><td style="text-align:center">“lld”</td></tr><tr><td style="text-align:left">SCNi8</td><td style="text-align:center">“hhi”</td></tr><tr><td style="text-align:left">SCNi16</td><td style="text-align:center">“hi”</td></tr><tr><td style="text-align:left">SCNi32</td><td style="text-align:center">“i”</td></tr><tr><td style="text-align:left">SCN64</td><td style="text-align:center">“lli”</td></tr><tr><td style="text-align:left">SCNo8</td><td style="text-align:center">“hho”</td></tr><tr><td style="text-align:left">SCNo16</td><td style="text-align:center">“ho”</td></tr><tr><td style="text-align:left">SCNo32</td><td style="text-align:center">“o”</td></tr><tr><td style="text-align:left">SCNo64</td><td style="text-align:center">“llo”</td></tr><tr><td style="text-align:left">SCNu8</td><td style="text-align:center">“hhu”</td></tr><tr><td style="text-align:left">SCNu16</td><td style="text-align:center">“hu”</td></tr><tr><td style="text-align:left">SCNu32</td><td style="text-align:center">“u”</td></tr><tr><td style="text-align:left">SCNu64</td><td style="text-align:center">“llu”</td></tr><tr><td style="text-align:left">SCNx8</td><td style="text-align:center">“hhx”</td></tr><tr><td style="text-align:left">SCNx16</td><td style="text-align:center">“hx”</td></tr><tr><td style="text-align:left">SCNx32</td><td style="text-align:center">“x”</td></tr><tr><td style="text-align:left">SCNx64</td><td style="text-align:center">“llx”</td></tr></tbody></table></div></blockquote><hr><h3 id="左值-amp-右值"><a href="#左值-amp-右值" class="headerlink" title="左值 &amp; 右值"></a>左值 &amp; 右值</h3><blockquote><p>简要来说，左值即为代码执行到下一行还可以访问到</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n_var = <span class="number">10</span>;		<span class="comment">//ok</span></span><br><span class="line"><span class="keyword">int</span> n_var_1 = n_var;	<span class="comment">//ok</span></span><br></pre></td></tr></table></figure><blockquote><p>10是一个<strong>字面常量</strong>，没有指定的内存地址，除了程序运行时一些临时的寄存器，故10是一个右值；整型变量<code>n_var</code>具有<strong>具体</strong>的内存位置，故<code>n_var</code>是一个左值。</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p_nvar = &amp;n_var;	<span class="comment">//ok</span></span><br></pre></td></tr></table></figure><blockquote><p><code>&amp;</code>在这里是一个取地址操作符，<code>&amp;</code>作用于<code>n_var</code>获得了<code>n_var</code>的内存地址，而<code>p_nvar</code>是一个<code>int</code>类型的指针变量，是一个左值。</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p_nvar1 = &amp;<span class="number">10</span>;		<span class="comment">//nope</span></span><br></pre></td></tr></table></figure><blockquote><p>10是一个右值，<strong><code>&amp;</code>必须作用于一个左值</strong>。</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;r_nvar = n_var;</span><br><span class="line">r_nvar++;			<span class="comment">//ok</span></span><br><span class="line"><span class="keyword">int</span> &amp;r_nvar1 = <span class="number">10</span>;			<span class="comment">//nope</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r_nvar2 = <span class="number">10</span>;	<span class="comment">//ok</span></span><br></pre></td></tr></table></figure><blockquote><ul><li><p><code>r_nvar</code>是一个<code>int</code>类型的引用（reference），指向已经存在的内存位置，故<code>r_var</code>是一个左值。此时，<code>r_nvar</code>指向<code>n_var</code>的内存地址，是<code>n_var</code>的一个引用。</p></li><li><p><code>const</code> 的左值可以绑定于一个右值。</p></li></ul></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n_var_2 = <span class="number">0</span>;</span><br><span class="line">n_var2 = n_var_1++;		<span class="comment">//ok</span></span><br><span class="line">n_var2 = ++n_var_1;		<span class="comment">//ok</span></span><br><span class="line">n_var2 = ++n_var++;		<span class="comment">//nope</span></span><br><span class="line">n_var2 = (++n_var)++;	<span class="comment">//ok</span></span><br></pre></td></tr></table></figure><blockquote><p>自增操作符必须作用于一个左值。若自增在左值的右边，返回的是一个右值；若自增在左值的左边，返回的是一个左值。自增操作符的结合方向是从右至左，此时先<code>n_var++</code>，返回一个右值；而<code>++n_var</code>返回一个左值，故可再<code>(++n_var)++</code>。</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func_1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...somewhere in main()...</span><br><span class="line">func_1() = <span class="number">20</span>;	<span class="comment">//nope</span></span><br></pre></td></tr></table></figure><blockquote><p><code>func_1()</code>返回一个右值（一个临时值10），右值不能作为赋值的左操作数。</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> global_nvar = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">func_2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> global_nvar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...somewhere in main()...</span><br><span class="line">func_2() = <span class="number">20</span>;	<span class="comment">//ok</span></span><br></pre></td></tr></table></figure><blockquote><p><code>&amp;</code>在这里定义了一个引用，<code>func_2()</code>返回一个int类型的引用，故返回值是一个左值。</p></blockquote><ul><li><a href="https://www.internalpointers.com/post/understanding-meaning-lvalues-and-rvalues-c" target="_blank" rel="noopener">Understanding the meaning of lvalues and rvalues in C++</a></li></ul><hr><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><blockquote><p>按“位”进行，位之间不影响。</p></blockquote><h4 id="按位与、按位或、-取反、按位异或、左移、右移"><a href="#按位与、按位或、-取反、按位异或、左移、右移" class="headerlink" title="按位与、按位或、 取反、按位异或、左移、右移"></a>按位与、按位或、 取反、按位异或、左移、右移</h4><p><code>&amp;</code> <code>|</code> <code>~</code> <code>^</code> <code>&lt;&lt;</code> <code>&gt;&gt;</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n_var1 = <span class="number">3</span>;		<span class="comment">// 0...00000011（补码、反码、原码） </span></span><br><span class="line"><span class="keyword">int</span> n_var2 = <span class="number">4</span>;		<span class="comment">// 0...00000100</span></span><br><span class="line"><span class="keyword">int</span> n_var3 = n_var1 &amp; n_var2;	<span class="comment">// 0...00000000</span></span><br><span class="line"><span class="keyword">int</span> n_var4 = n_var1 | n_var2;	<span class="comment">// 0...00000111</span></span><br><span class="line"><span class="keyword">int</span> n_var5 = ~n_var1;			<span class="comment">// 1...11111100（补码）</span></span><br><span class="line"><span class="comment">// 1...11111011（反码）-&gt; 1...00000100（原码） -- -4</span></span><br><span class="line"><span class="keyword">int</span> n_var6 = n_var1 ^ n_var2;	<span class="comment">// 0...00000111</span></span><br><span class="line"><span class="keyword">int</span> n_var7 = n_var1 &lt;&lt; <span class="number">4</span>;		<span class="comment">// 0...00110000 -- 48</span></span><br><span class="line"><span class="comment">// int n_var7 = n_var1 * 2 * 2 * 2 * 2;</span></span><br><span class="line"><span class="keyword">int</span> n_var8 = n_var2 &gt;&gt; <span class="number">2</span>;		<span class="comment">// 0...00000001 -- 1</span></span><br><span class="line"><span class="comment">//int n_var8 = n_var2 / (2 * 2);</span></span><br></pre></td></tr></table></figure><h4 id="取模运算与位运算之间的等价转换"><a href="#取模运算与位运算之间的等价转换" class="headerlink" title="取模运算与位运算之间的等价转换"></a>取模运算与位运算之间的等价转换</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n_var = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">int</span> n_var1 = n_var % <span class="number">2</span>;	</span><br><span class="line"><span class="keyword">int</span> n_var_1 = n_var ^ <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n_var2 = n_var % <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> n_var_2 = n_var ^ <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> n_var3 = n_var % <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> n_var_3 = n_var ^ <span class="number">7</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="逻辑与（或）"><a href="#逻辑与（或）" class="headerlink" title="逻辑与（或）"></a>逻辑与（或）</h3><h4 id="“短路”"><a href="#“短路”" class="headerlink" title="“短路”"></a>“短路”</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n_var1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n_var2 = <span class="number">0</span>;</span><br><span class="line">(n_var1++) &amp;&amp; (n_var2++);	<span class="comment">// n_var1 = 1, n_var2 = 0</span></span><br><span class="line">(n_var1++) || (n_var2++);	<span class="comment">// n_var1 = 2, n_var2 = 0</span></span><br></pre></td></tr></table></figure><blockquote><ul><li><p><code>(n_var1++) &amp;&amp; (n_var2++);</code>中<code>n_var1++</code>值为0，而逻辑与<code>&amp;&amp;</code>的规则是，若第一个操作数为真才进行第二个操作数的判断，而当第一个为假时直接返回假；故，<code>n_var1 = 1</code>,<code>n_var2 = 0</code>,进行逻辑与后结果为<code>false</code>。</p></li><li><p><code>(n_var1++) || (n_var2++);</code>中<code>n_var1++</code>值为1，非0即为真，而逻辑或<code>||</code>的规则是，若第一个操作数为假才对第二个操作数进行判断，而当第一个操作数为真时直接返回真；故，<code>n_var1 = 2</code>,<code>n_var2 = 0</code>,进行逻辑或后结果为<code>true</code>。</p></li></ul></blockquote><h4 id="amp-amp-优先级高于"><a href="#amp-amp-优先级高于" class="headerlink" title="&amp;&amp; 优先级高于||"></a>&amp;&amp; 优先级高于||</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"1"</span>) || <span class="built_in">printf</span>(<span class="string">"2"</span>) &amp;&amp; <span class="built_in">printf</span>(<span class="string">"3"</span>);	   <span class="comment">// 1</span></span><br><span class="line"><span class="comment">//printf("1") || （printf("2") &amp;&amp; printf("3"));	</span></span><br><span class="line">(<span class="built_in">printf</span>(<span class="string">"1"</span>) || <span class="built_in">printf</span>(<span class="string">"2"</span>)) &amp;&amp; <span class="built_in">printf</span>(<span class="string">"3"</span>);   <span class="comment">// 13</span></span><br></pre></td></tr></table></figure><blockquote><p><code>&amp;&amp;</code>的优先级高于<code>||</code>,则后两个<code>printf()</code>先结合，由于逻辑与或的结合方向是从左向右，故第一行表达式等价于第二行。先执行第一个<code>printf()</code>，其返回为真发生“短路”，返回为真。</p></blockquote><hr><h3 id="设置随机数"><a href="#设置随机数" class="headerlink" title="设置随机数"></a>设置随机数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//设置随机种子</span></span><br><span class="line">srand(time(<span class="number">0</span>));</span><br><span class="line"><span class="comment">//输出10个0到99的随机数</span></span><br><span class="line"><span class="keyword">int</span> rand_value = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    rand_value = rand() % <span class="number">100</span>;</span><br><span class="line">    (i == <span class="number">0</span>) || <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, rand_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n_var = <span class="number">1</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> n_var = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"n_var = %d\n"</span>, n_var);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"n_var = %d\n"</span>, n_var);</span><br></pre></td></tr></table></figure><blockquote><p>第二个<code>n_var</code>作用域在大括号内。</p></blockquote><hr><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><h4 id="头递归-amp-尾递归"><a href="#头递归-amp-尾递归" class="headerlink" title="头递归 &amp; 尾递归"></a>头递归 &amp; 尾递归</h4><blockquote><ul><li><p>头递归在下一层调用返回后才会完成本层计算</p></li><li><p>尾递归在下一层调用前会先进行计算</p></li></ul></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//阶乘</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">factorial_1</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	（n == <span class="number">1</span>) &amp;&amp; <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> n * factorial_1(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">factorial_2</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> result)</span></span>&#123;</span><br><span class="line">    (n == <span class="number">0</span>) &amp;&amp; <span class="keyword">return</span> result;</span><br><span class="line">    result = n * result;</span><br><span class="line">    <span class="keyword">return</span> factorial_2(n<span class="number">-1</span>, result);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"4! = %d\n"</span>, factorial1(<span class="number">4</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"5! = %d\n"</span>, factorial2(<span class="number">5</span>, <span class="number">1</span>));</span><br></pre></td></tr></table></figure><h4 id="数组递归"><a href="#数组递归" class="headerlink" title="数组递归"></a>数组递归</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//爬楼梯</span></span><br><span class="line"><span class="comment">//rule: 一个爬2或3个楼梯，指定数目下组合的数目</span></span><br><span class="line"><span class="keyword">int</span> num_stairs = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> *p_ways = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(num_stairs * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">p_ways[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">p_ways[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">p_ways[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= num_stairs) &#123;</span><br><span class="line">    p_ways[i++] = p_ways[i<span class="number">-2</span>] + p_ways[i<span class="number">-3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p_ways[num_stairs]);</span><br><span class="line"><span class="built_in">free</span>(p_ways);</span><br><span class="line">p_ways = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="函数地址做函数参数"><a href="#函数地址做函数参数" class="headerlink" title="函数地址做函数参数"></a>函数地址做函数参数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二分法</span></span><br><span class="line"><span class="comment">//求一个在误差之内的 p*x+q=0 在[-20, 20]中的解</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPSILON 1e-7</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">func_1</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q, <span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p * x + q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">bisection</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q, <span class="keyword">double</span> (*f)(<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">double</span>))</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x_left = <span class="number">-20.0</span>, x_right = <span class="number">20.0</span>, x_mid = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">if</span>(f(p, q, x_left) * f(p, q, x_right) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"No Solution!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">if</span> (f(p, q, x_left) == <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> x_left;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (f(p, q, x_right) == <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> x_right;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">do</span>&#123;</span><br><span class="line">        x_mid = (x_left + x_right) / <span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(f(p, q, x_left) * f(p, q, x_mid) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x_right = x_mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(f(p, q, x_right) * f(p, q, x_mid) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x_left = x_mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;<span class="keyword">while</span>(<span class="built_in">fabs</span>(f(p, q, x_mid)) &gt;= EPSILON);</span><br><span class="line">    <span class="keyword">return</span> x_mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="continue-amp-break"><a href="#continue-amp-break" class="headerlink" title="continue &amp; break"></a>continue &amp; break</h3><blockquote><ul><li><code>continue</code>：回到当前所在循环头处，进行下一次循环；</li><li><code>break</code>：跳出当前所在循环；</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">	<span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">    	<span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">7</span>) &#123;</span><br><span class="line">    	<span class="keyword">break</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//012456</span></span><br></pre></td></tr></table></figure><hr><h3 id="memset初始化"><a href="#memset初始化" class="headerlink" title="memset初始化"></a>memset初始化</h3><blockquote><ul><li>memset初始化按字节分配；只能初始化0和-1；</li><li>{}初始化和memset初始化耗时差不多，但{}初始化有可能会出现移植错误；</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n_array[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">memset</span>(n_array, <span class="number">0</span>, <span class="keyword">sizeof</span>(n_array));</span><br><span class="line"><span class="built_in">memset</span>(n_array, <span class="number">-1</span>, <span class="keyword">sizeof</span>(n_array));</span><br><span class="line"><span class="built_in">memset</span>(n_array, <span class="number">1</span>, <span class="keyword">sizeof</span>(n_array));</span><br></pre></td></tr></table></figure><blockquote><p>对于第一个<code>memset()</code>，初始化为0，而<code>int</code>类型数组<code>n_array</code>其元素占4个字节，由于其按字节分配，其初始化为<code>00000000</code> <code>00000000</code> <code>00000000</code> <code>00000000</code> ，即为0；</p><p>对于第二个<code>memset()</code>，初始化为-1，其初始化为 <code>11111111</code> <code>11111111</code> <code>11111111</code> <code>11111111</code> ，即为1；</p><p>对于第三个<code>memset()</code>，初始化为1，其初始化为 <code>00000001</code> <code>00000001</code> <code>00000001</code> <code>00000001</code>，即0x01010101，即16843009。</p></blockquote><hr><h3 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h3><blockquote><p>只适用于顺序表；</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n_array[<span class="number">5</span>] = &#123; <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">23</span>&#125;;	</span><br><span class="line"><span class="comment">// int n_array[5] = &#123; 2, 7, 7, 7, 23&#125;</span></span><br><span class="line"><span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> high = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n_search = <span class="number">0</span>;				<span class="comment">//要查找的数</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n_search);</span><br><span class="line"><span class="keyword">while</span>(low &lt;= high) &#123;</span><br><span class="line">    mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(n_array[mid] &lt; n_search) &#123;</span><br><span class="line">        low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (n_array[mid] &gt; n_search) &#123;</span><br><span class="line">        high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//printf("位于%dst\n", mid+1);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"位于%dst\n"</span>, (low &gt; high)?<span class="number">0</span>:(mid+<span class="number">1</span>));</span><br></pre></td></tr></table></figure><blockquote><p>只能查找顺序表中是否有，而不能检查到其他剩余的；如若数组<code>n_array</code>初始化于第二种情况；</p></blockquote><hr><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><blockquote><p>稳定排序；</p><p>T(n) = n*n;</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n_array[<span class="number">5</span>] = &#123; <span class="number">6</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, n = <span class="number">5</span>;;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n_array[j] &gt; n_array[j + <span class="number">1</span>]) &#123; <span class="comment">//从小到大排序</span></span><br><span class="line">			swap(&amp;n_array[j], &amp;n_array[j + <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><blockquote><p>稳定排序；</p><p>T(n) = n*n;</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n_array[<span class="number">5</span>] = &#123; <span class="number">6</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, n = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> min_index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    min_index = i;</span><br><span class="line">	<span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">		 <span class="keyword">if</span>(n_array[j] &lt; n_array[min_index])&#123;</span><br><span class="line">             min_index = j;</span><br><span class="line">         &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span>(min_index != i)&#123;</span><br><span class="line">        swap(&amp;n_array[min_index], &amp;n_array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>冒泡排序和选择排序的比较次数都是<code>O(n*n)</code>的，而交换次数前者是<code>O(n*n)</code>的，后者是是<code>O(n)</code>的。</p></blockquote><hr><h3 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量"></a>字符串字面量</h3><blockquote><ul><li>是<strong>数组类型</strong>的（无名）<strong>静态对象</strong>；</li><li>是不可更改的<strong>左值</strong>；</li><li>可转换为指向第一个字符的指针；</li><li>位于字面量池中；</li></ul></blockquote><p>C/C++中的对象的生存周期按照其存储性质分为静态存储期、自动存储期、动态存储期；又按其存储性质分为静态对象、自动对象、动态对象。字符串字面量是静态对象，故在程序运行期间一直存在。静态对象的地址在编译期间即被确定，故地址<code>&amp;&quot;hello&quot;</code>是常量。而字符串字面量在右值上下语义时又可从数组类型转换为指针，所以字符串字面量可做地址常量表达式来使用。</p><p>在C中字符串字面量类型是无<code>const</code>限定的，而在C++中是<code>const</code>限定的。C中其转指针时也是无<code>const</code>限定的，而C++中是<code>const</code>限定的，故C++中又增加了可以有限制的转换为非常量指针。</p><p>在C++中字符串字面量是常量，而在C99中不是常量。</p><blockquote><p>ANSI C 规定： 修改字符串常量，结果是未定义的</p><p>ANSI C 并没有规定编译器的实现者对字符串的处理</p><ul><li>有些编译器可修改字符串常量，有些则不可</li><li><p>有些编译器将多个相同的字符串常量看成一个；有些则不进行次优化；如果进行优化，则可能导致修改一个字符串常量将会导致另外的字符串常量发生变化，结果不可知；</p><blockquote><ul><li>vs2013 字符串常量地址同文件、不同文件都相同；</li><li>qt 同文件相同，不同文件不同；</li></ul></blockquote></li><li><p>一般通过指针获取字符串，用<code>const</code> 修饰；</p></li></ul></blockquote><p><a href="http://www.360doc.com/content/12/0511/19/7775902_210379219.shtml" target="_blank" rel="noopener">C 和 C ++ 字符串字面量（String Literal）的区别</a></p><hr><h3 id="Q：求质数"><a href="#Q：求质数" class="headerlink" title="Q：求质数"></a>Q：求质数</h3><blockquote><p>求从<code>n_m</code>到<code>n_n</code>的质数；</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n_n = <span class="number">100</span>, n_m = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">int</span> *p_mark_arr = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>((n_n+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="built_in">memset</span>(p_mark_arr, <span class="number">0</span>, <span class="keyword">sizeof</span>(p_mark_arr));</span><br><span class="line">p_mark_arr[<span class="number">0</span>] = <span class="number">1</span>;		<span class="comment">//1是合数，0是质数</span></span><br><span class="line">p_mark_arr[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">2</span>; i * i &lt;= n_n; i++) &#123;</span><br><span class="line">    <span class="comment">//对于一个数n, 若2至sqrt(n)无因子，则一定是质数。</span></span><br><span class="line">    <span class="keyword">if</span>(p_mark_arr[i] != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">2</span>; j &lt;= n_n / i; j++) &#123;</span><br><span class="line">			p_mark_arr[i * j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i = n_m; i&lt;= n_n; i++) &#123;</span><br><span class="line">    (p_mark_arr[i] == <span class="number">1</span>) || <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><blockquote><p><code>const</code>修饰的变量，在二进制角度讲与变量无区别，存储于内存，<code>const</code>属性只是编译器层面在编译时进行检查和保护。</p><p><code>const</code> 修饰全局变量位于常量区，不可修改（直接、间接）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//const 修饰全局变量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CNVar = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//const 修饰局部变量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> cNVar = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> * nPtr1 = (<span class="keyword">int</span>*)&amp;CNVar;</span><br><span class="line">    <span class="keyword">int</span> * nPtr2 = (<span class="keyword">int</span>*)&amp;cNVar;</span><br><span class="line">    <span class="comment">//*nPtr1 = 30;			//Nope	不可</span></span><br><span class="line">    *nPtr2 = <span class="number">30</span>; 			<span class="comment">//Ok	可间接修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>const 修饰变量</p><blockquote><p>可通过指针修改变量值</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n_var = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *n_ptr = &amp;n_var;</span><br><span class="line">*p = <span class="number">20</span>;</span><br></pre></td></tr></table></figure></li><li><p>const 修饰指针类型</p><blockquote><p>不能改变所指地址中的值，可改变所指向的地址</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n_var = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* n_ptr = &amp;n_var;</span><br><span class="line"><span class="comment">//*n_ptr = 20;</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">30</span>;</span><br><span class="line">n_ptr = &amp;b;</span><br></pre></td></tr></table></figure></li><li><p>const 修饰指针变量</p><blockquote><p>可改变所指地址中的值，不可改变所指向的地址</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n_var = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> n_ptr = &amp;n_var;</span><br><span class="line">*n_ptr = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">30</span>;</span><br><span class="line"><span class="comment">//n_ptr = &amp;b;</span></span><br></pre></td></tr></table></figure></li><li><p>const 修饰指针类型及变量</p><blockquote><p>不可改变所指地址中的值，不可改变所指向的地址</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n_var = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> n_ptr = &amp;n_var;</span><br><span class="line"><span class="comment">//*n_ptr = 20;</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">30</span>;</span><br><span class="line"><span class="comment">//n_ptr = &amp;b;</span></span><br></pre></td></tr></table></figure></li></ul></blockquote><hr><h3 id="指针大小-amp-步长"><a href="#指针大小-amp-步长" class="headerlink" title="指针大小 &amp; 步长"></a>指针大小 &amp; 步长</h3><blockquote><ul><li>指针大小与机器字长相同，32位即为4字节，64位即为8字节；</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p_arr = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">4</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));	<span class="comment">//动态分配数组</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(p_arr));			<span class="comment">//指针大小</span></span><br><span class="line"><span class="built_in">memset</span>(p_arr, <span class="number">0</span>, <span class="number">4</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));		<span class="comment">//ok</span></span><br><span class="line"><span class="built_in">memset</span>(p_arr, <span class="number">0</span>, <span class="keyword">sizeof</span>(p_arr));		<span class="comment">//nope</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>指针的步长由指针类型确定</li></ul></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> nVar1;</span><br><span class="line">	<span class="keyword">char</span> ch1;</span><br><span class="line">	<span class="keyword">int</span> nVar2;</span><br><span class="line">	<span class="keyword">char</span> ch2;</span><br><span class="line">&#125;MyStruct;</span><br><span class="line">MyStruct s = &#123;<span class="number">10</span>, <span class="string">'a'</span>, <span class="number">20</span>, <span class="string">'b'</span>&#125;;</span><br><span class="line">MyStruct * s_ptr = &amp;s;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, s.nVar2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *((<span class="keyword">int</span>*)((<span class="keyword">char</span>*)s_ptr + <span class="number">8</span>)));</span><br></pre></td></tr></table></figure><blockquote><ul><li><code>s_ptr</code> 是<code>MyStruct*</code>类型指针，其步长是<code>MyStruct</code>所占内存大小;先转成<code>char*</code>类型，步长为1；</li><li>然后使其指向第三个成员的首地址，将其转成<code>int*</code>类型，告诉编译器是指向<code>int</code>类型地址，进行取值；</li></ul></blockquote><hr><h3 id="二维数组创建"><a href="#二维数组创建" class="headerlink" title="二维数组创建"></a>二维数组创建</h3><blockquote><p>二级指针</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> **arr = (<span class="keyword">int</span>**)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="keyword">int</span>*));</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">	arr[i] = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">memset</span>(arr[i], <span class="number">0</span>, n * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));		<span class="comment">//初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>数组指针</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*arr)[<span class="number">5</span>] = (<span class="keyword">int</span>(*)[<span class="number">5</span>])<span class="built_in">malloc</span>(n*<span class="number">5</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="number">5</span> * n * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));		<span class="comment">//初始化</span></span><br></pre></td></tr></table></figure><blockquote><p>一级指针</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *arr = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(n*n*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="built_in">memset</span>(arr, <span class="number">0</span>, n * n * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));		<span class="comment">//初始化</span></span><br></pre></td></tr></table></figure><hr><h3 id="矩阵旋转-amp-螺旋输出"><a href="#矩阵旋转-amp-螺旋输出" class="headerlink" title="矩阵旋转 &amp; 螺旋输出"></a>矩阵旋转 &amp; 螺旋输出</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> **arr = (<span class="keyword">int</span>**)<span class="built_in">malloc</span>(n *<span class="keyword">sizeof</span>(<span class="keyword">int</span>*));</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">	arr[i] = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="comment">//memset(arr[i], 0, n * sizeof(int));</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向右旋转90度输出</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">	<span class="keyword">for</span> (j = n<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">		(j == n<span class="number">-1</span>) || <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d"</span>, arr[j][i]);</span><br><span class="line">        <span class="comment">// new_arr[j][n-i-1] = arr[i][j];</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">matrix_roate_print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//矩阵螺旋输出</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"...............\n"</span>);</span><br><span class="line">	<span class="keyword">int</span> m, n, i, j;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"请输入矩阵格式：\n"</span>);</span><br><span class="line">	scanf_s(<span class="string">"%d%d"</span>, &amp;m, &amp;n);</span><br><span class="line">	<span class="keyword">int</span> **matrix = (<span class="keyword">int</span>**)<span class="built_in">malloc</span>(m*<span class="keyword">sizeof</span>(<span class="keyword">int</span>*));</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">		matrix[i] = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"请输入矩阵数据：\n"</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">			scanf_s(<span class="string">"%d"</span>, &amp;matrix[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>, direct = <span class="number">0</span>, k;</span><br><span class="line">	i = <span class="number">0</span>;</span><br><span class="line">	j = <span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"矩阵螺旋输出：\n"</span>);</span><br><span class="line">	<span class="keyword">while</span> (count &lt; n * m) &#123;</span><br><span class="line">		<span class="keyword">switch</span> (direct % <span class="number">4</span>) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">for</span> (k = ++j; k &lt; n - direct / <span class="number">4</span>; k++) &#123;</span><br><span class="line">				k == <span class="number">0</span> || <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%d"</span>, matrix[i][k]);</span><br><span class="line">				count++;</span><br><span class="line">			&#125;</span><br><span class="line">			j = k - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			<span class="keyword">for</span> (k = ++i; k &lt; m - direct / <span class="number">4</span>; k++) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%d"</span>, matrix[k][j]);</span><br><span class="line">				count++;</span><br><span class="line">			&#125;</span><br><span class="line">			i = k - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			<span class="keyword">for</span> (k = --j; k &gt;= direct / <span class="number">4</span>; k--) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%d"</span>, matrix[i][k]);</span><br><span class="line">				count++;</span><br><span class="line">			&#125;</span><br><span class="line">			j = k + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">			<span class="keyword">for</span> (k = --i; k &gt;= direct / <span class="number">4</span> + <span class="number">1</span>; k--) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%d"</span>, matrix[k][j]);</span><br><span class="line">				count++;</span><br><span class="line">			&#125;</span><br><span class="line">			i = k + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		direct++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">		<span class="built_in">free</span>(matrix[i]);</span><br><span class="line">		matrix[i] = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(matrix);</span><br><span class="line">	matrix = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="printf-amp-sprintf"><a href="#printf-amp-sprintf" class="headerlink" title="printf() &amp; sprintf()"></a>printf() &amp; sprintf()</h3><blockquote><p>被sprintf()写入的字符串数组长度不足会引起段错误;</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> information[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">char</span> *name = <span class="string">"Li Ming"</span>;</span><br><span class="line"><span class="keyword">char</span> *gender = <span class="string">"male"</span>;</span><br><span class="line">sprintf_s(information, <span class="string">"%s is a %s."</span>, name, gender);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, information);</span><br></pre></td></tr></table></figure><hr><h3 id="malloc-amp-calloc-amp-realloc"><a href="#malloc-amp-calloc-amp-realloc" class="headerlink" title="malloc() &amp; calloc() &amp; realloc()"></a>malloc() &amp; calloc() &amp; realloc()</h3><blockquote><ul><li><p><code>calloc()</code>申请的内存空间是经过初始化的，初始为0；</p></li><li><p><code>malloc()</code>申请的内存空间是未经初始化的；</p></li><li><p>```c<br>void <em>realloc(void</em> _Block, size_t _Size);</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - 当&#96;_Block&#96; 为&#96;NULL&#96;时，其作用相当于&#96;malloc()&#96;；</span><br><span class="line"></span><br><span class="line">  - 否则，若原空间后有足够连续的存储空间分配，则扩充&#96;_Block&#96;，否则，重新分配一块新大小的连续存储空间，然后将原空间的值拷贝到新的存储空间，释放原空间；</span><br><span class="line"></span><br><span class="line">- 申请堆区的存储空间；</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### void &amp; void* &amp; int* &amp; 野指针</span><br><span class="line"></span><br><span class="line">- &#96;void&#96; 不能直接定义变量，编译器不知道分配多大的内存</span><br><span class="line">- 定义一个变量时，编译器必须知道分配多大的内存空间</span><br><span class="line">- &#96;void&#96; 主要用于对函数返回值及函数参数的限定</span><br><span class="line">- &#96;void*&#96; 任何类型指针不通过强制转换都可以转换成该类型</span><br><span class="line">- &#96;void*&#96; 主要用于对函数接口的封装</span><br><span class="line">- 野指针是指所指向的存储空间已经释放的指针，其指向不确定的；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;c++</span><br><span class="line">void *p_var;</span><br><span class="line">int n_var &#x3D; 0;</span><br><span class="line">int *p_nvar &#x3D; &amp;n_var;</span><br><span class="line">p_var &#x3D; p_nvar;</span><br><span class="line">p_nvar &#x3D; (int*)p_var;	&#x2F;&#x2F;强制转换 </span><br></pre></td></tr></table></figure></li></ul></blockquote><hr><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><h4 id="结构体-amp-偏移量"><a href="#结构体-amp-偏移量" class="headerlink" title="结构体 &amp; 偏移量"></a>结构体 &amp; 偏移量</h4><blockquote><ul><li>结构体变量中成员的偏移量必须是<code>min( 当前成员大小， #pagma pack(n) )</code> 的整数倍</li><li>结构体大小必须是 <code>min (结构体中最大成员，#pragma pack(n) )</code> 的整数倍</li><li>结构体中嵌套的结构体的第一个成员的偏移量是结构体中最大成员的整数倍</li><li>地址对齐是由编译器决定的（为了提高CPU访问内存速率），可通过 <code>#pragma pack(n)</code>改变</li><li>结构体成员为数组时，是将数组的每个元素当一个成员来分配，并不是将整个数组当成一个成员来对待；</li></ul><p>内存对齐原因：</p><ul><li>为了提高CPU访问内存的效率；</li><li>某些平台只能在特定的地址处访问特定类型的数据，否则抛出硬件异常给操作系统；</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">test_struct1</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n_var;</span><br><span class="line">	<span class="keyword">char</span>* str;</span><br><span class="line">	<span class="keyword">float</span> f_var;</span><br><span class="line">&#125;Test_struct1;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">test_struct2</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span>* str;</span><br><span class="line">	<span class="keyword">int</span> n_var;</span><br><span class="line">	<span class="keyword">float</span> f_var;</span><br><span class="line">&#125;Test_struct2;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">test_struct3</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> ch1;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="keyword">char</span> ch2;</span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> n_var;</span><br><span class="line">		&#125;ss;</span><br><span class="line">	<span class="keyword">float</span> f_var;</span><br><span class="line">&#125;Test_struct3;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sizeof(Test_struct1) = %d\n"</span>, <span class="keyword">sizeof</span>(Test_struct1));	<span class="comment">//24</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sizeof(Test_struct2) = %d\n"</span>, <span class="keyword">sizeof</span>(Test_struct2));	<span class="comment">//16</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sizeof(Test_struct3) = %d\n"</span>, <span class="keyword">sizeof</span>(Test_struct3));	<span class="comment">//32 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//求偏移量</span></span><br><span class="line"><span class="keyword">size_t</span> off1 = offsetof(Test_struct3, ch1);</span><br><span class="line"><span class="keyword">size_t</span> off2 = offsetof(Test_struct3, ss);</span><br><span class="line"><span class="keyword">size_t</span> off3 = offsetof(Test_struct3, f_var);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, off1, off2, off3);				<span class="comment">// 8 16 24</span></span><br></pre></td></tr></table></figure><blockquote><p><code>#define offsetof(s,m) ((size_t)&amp;(((s*)0)-&gt;m))</code> ，该宏声明于<code>stddef.h</code>头文件中。</p><p><code>(s*)0</code> 是将数字0强制转换为s类型的指针。因此这里0代表内存地址0，即认为内存地址0开始的<code>sizeof(s)</code>大小存储的是一个s类型变量。由于是宏，在编译阶段完成，对内存的0地址未操作。</p></blockquote><h4 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h4><blockquote><p>定义变量使用内存的“位长”;</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">test_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch1:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">char</span> ch2:<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">char</span> ch3:<span class="number">2</span>;</span><br><span class="line">&#125;Test_struct;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(Test_struct));</span><br></pre></td></tr></table></figure><blockquote><p>同一类型连续存在多个位域，则若位宽和所占内存小于类型的存储单元，则这几个连续存放；若超过，则将从存储单元开始。上中<code>ch1,ch2,ch3</code>都是char类型，其位宽分别为4、3、2，则由于前两个所占位宽和7小于char类型的存储单元8，则<code>ch1</code>和<code>ch2</code>在一个char类型存储单元连续存储，而由于<code>ch3</code>的位宽为2，前两者占用的存储单元存储不了，则将在下一个新的char类型存储单元存储。</p></blockquote><hr><h4 id="浅拷贝-amp-深拷贝"><a href="#浅拷贝-amp-深拷贝" class="headerlink" title="浅拷贝 &amp; //深拷贝"></a>浅拷贝 &amp; //深拷贝</h4><blockquote><p>浅拷贝可能存在问题：</p><ul><li>内存空间泄露；</li><li>释放已释放掉的堆空间；</li></ul></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体元素存储空间都是栈上分配的</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;MyStruct1;</span><br><span class="line">MyStruct1 ms1 = &#123;<span class="string">"tom"</span>,<span class="number">19</span>&#125;;</span><br><span class="line">MyStruct1 ms2 = &#123;<span class="string">"william"</span>,<span class="number">15</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//浅拷贝</span></span><br><span class="line">ms1 = ms2;				<span class="comment">//OK</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体元素存储空间都是堆上分配的</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> * name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;MyStruct2;</span><br><span class="line">MyStruct2 s1, s2;</span><br><span class="line">s1.name = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * <span class="number">20</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(s1, <span class="string">"tom"</span>);</span><br><span class="line">s1.age = <span class="number">19</span>;</span><br><span class="line">s2.name = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * <span class="number">20</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(s2, <span class="string">"william"</span>);</span><br><span class="line">s2.age = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//浅拷贝</span></span><br><span class="line">s1 = s2;			<span class="comment">//Nope ,1.内存泄露；2.释放已释放掉的堆空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//深拷贝</span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span> != s1.name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">free</span>(s1.name);</span><br><span class="line">    s1.name = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">s1.name = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * (<span class="built_in">strlen</span>(s2.name)+<span class="number">1</span>));</span><br><span class="line"><span class="built_in">strcpy</span>(s1.name, s2.name);</span><br><span class="line">s1.age = s2.age;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放堆空间</span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span> != s1.name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">free</span>(s1.name);</span><br><span class="line">    s1.name = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span> != s2.name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">free</span>(s2.name);</span><br><span class="line">    s2.name = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h3><blockquote><ul><li>共用体内成员变量共用一个内存空间；</li><li>共用体变量所占用的内存长度等于最长的成员的内存长度；</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> test_union &#123;</span><br><span class="line">	<span class="keyword">char</span> ch1;</span><br><span class="line">	short s_var;           </span><br><span class="line"> 	<span class="keyword">int</span> n_var;</span><br><span class="line">&#125;Test_union;</span><br><span class="line">Test_union test_1;</span><br><span class="line">test_1.n_var = <span class="number">0x0f0f0f0f</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, test_1.ch1, test_1.s_var, test_1.n_var);	<span class="comment">// 15 3855 252645135</span></span><br></pre></td></tr></table></figure><hr><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> test_enum &#123;</span><br><span class="line">	SUNDAY,</span><br><span class="line">	MONDAY</span><br><span class="line">&#125;test_date;</span><br><span class="line">test_date = MONDAY;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, test_date);	 	<span class="comment">// 1</span></span><br></pre></td></tr></table></figure><hr><h3 id="Q：约瑟夫环"><a href="#Q：约瑟夫环" class="headerlink" title="Q：约瑟夫环"></a>Q：约瑟夫环</h3><blockquote><p>有 N个人，围成了一个圆圈，每人被顺序地编了一个序号（分别为 1,2,3… n），从编号为 K 的人开始报 1，下一个人（顺初始数字增长方向计算序号）报 2，依次类推，数到某一个数字 M 的人出列。出列同学的下一个人又从 1 开始继续报数，数到某一个数字 M 的人出列。不断重复这一过程，直到所有人都出列为止。</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单链表结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">circle_create</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; </span><br><span class="line">	Node *temp, *new_node, *head;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="comment">// 创建第一个链表节点并加数据</span></span><br><span class="line">	temp = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">	head = temp;</span><br><span class="line">	head-&gt;data = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 创建第 2 到第 n 个链表节点并加数据</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		new_node = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">		new_node-&gt;data = i;</span><br><span class="line">		temp-&gt;next = new_node;</span><br><span class="line">		temp = new_node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 最后一个节点指向头部构成循环链表</span></span><br><span class="line">	temp-&gt;next = head;</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">count_off</span><span class="params">(Node *head, <span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">1</span>, count;</span><br><span class="line">	Node *p_node = head;</span><br><span class="line">	Node *q_node = head;</span><br><span class="line">    <span class="comment">//当只有一个数据时</span></span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d"</span>, p_node-&gt;data);</span><br><span class="line">  		<span class="built_in">free</span>(p_node);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找到尾指针</span></span><br><span class="line">	<span class="keyword">for</span> (count = <span class="number">1</span>; count &lt; n; count++) &#123;</span><br><span class="line">		q_node = q_node-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//找到指向第k个结点的指针</span></span><br><span class="line">	<span class="keyword">while</span> ((i++) &lt; k) &#123;</span><br><span class="line">		q_node = p_node;</span><br><span class="line">		p_node = p_node-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//当剩下一个结点时</span></span><br><span class="line">	<span class="keyword">while</span> (p_node != p_node-&gt;next) &#123;</span><br><span class="line">		count = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (count++ &lt; m) &#123;</span><br><span class="line">			q_node = p_node;</span><br><span class="line">			p_node = p_node-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>, p_node-&gt;data);</span><br><span class="line">		q_node-&gt;next = p_node-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(p_node);</span><br><span class="line">		p_node = q_node-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, p_node-&gt;data);</span><br><span class="line">	<span class="built_in">free</span>(p_node);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">scanf_s(<span class="string">"%d%d%d"</span>, &amp;n, &amp;k, &amp;m);</span><br><span class="line">Node *head = circle_create(n);</span><br><span class="line">count_off(head, n, k, m);</span><br></pre></td></tr></table></figure><hr><h3 id="Q：魔方阵"><a href="#Q：魔方阵" class="headerlink" title="Q：魔方阵"></a>Q：魔方阵</h3><blockquote><p>一<code>n</code>阶方阵，其由<code>1 ~ n*n</code> 组成，且每行、每列、主副对角线的数字和相同；</p><ul><li><p>奇数阶：</p><ul><li><p>排列法：</p><blockquote><ol><li>置1于首行中间位置；</li><li>若当前位置按行减一列加一的位置没有数字，则填入下一数字；否则，将下一数字填入当前位置的行加一列不变的位置；</li></ol></blockquote></li></ul></li><li><p>4K阶：</p><ul><li><blockquote><ol><li>将主副对角线的位置进行标记；</li><li>按从左至右，从上至下的顺序每移一格数字增一(<code>1~n*n</code>)；填入规则：无标记则填入；</li><li>然后按从右至左，从下至上的顺序每移一格数字增一(<code>1~n*n</code>)；填入规则：未填入则填；</li></ol></blockquote></li></ul><p>4K+2阶：</p><ul><li><blockquote><ol><li>将其分为4个<code>2K+1</code>阶；</li><li>将<code>1 ~ n*n</code> 分成4组依次按排列法在左上、右下、右上、左下填入；</li><li>对左两个而言，按规则对换相应位置的数字；对换规则：对左上<code>(K+1, K+1)</code>位置，从该位置起依次对换左下的<code>K</code>个数字；其余行则从第一列起依次对换左下的<code>K</code>个数字；</li><li>对右两个而言，将大于K+2(<code>n/2+K+2</code>)的列对应位置的数字对换；</li></ol></blockquote></li></ul></li></ul></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_magic_square</span><span class="params">(<span class="keyword">int</span> n_dim)</span></span>&#123;</span><br><span class="line">    <span class="comment">//create a maxtrix</span></span><br><span class="line">    <span class="keyword">int</span>** n_matrix = (<span class="keyword">int</span>**)<span class="built_in">malloc</span>(n_dim * <span class="keyword">sizeof</span>(<span class="keyword">int</span>*));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_dim; i++) &#123;</span><br><span class="line">		n_matrix[i] = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(n_dim * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">        <span class="built_in">memset</span>(n_matrix[i], <span class="number">0</span>, n_dim * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//pull number</span></span><br><span class="line">    <span class="keyword">if</span>(n_dim &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//奇数阶</span></span><br><span class="line">        <span class="keyword">int</span> n_place_1 = <span class="number">0</span>, n_place_2 = n_dim / <span class="number">2</span>;</span><br><span class="line">        n_matrix[n_place_1][n_place_2] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n_dim * n_dim; ) &#123;</span><br><span class="line">            n_place_1 = (n_place_1 - <span class="number">1</span> + n_dim) % n_dim;</span><br><span class="line">            n_place_2 = (n_place_2 + <span class="number">1</span>) % n_dim;</span><br><span class="line">            <span class="keyword">if</span>(n_matrix[n_place_1][n_place_2] != <span class="number">0</span>) &#123;</span><br><span class="line">                n_place_1 = (n_place_1 + <span class="number">2</span>) % n_dim;</span><br><span class="line">            	n_place_2 = (n_place_2 - <span class="number">1</span> + n_dim) % n_dim;</span><br><span class="line">            &#125;</span><br><span class="line">            n_matrix[n_place_1][n_place_2] = (++i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>((n_dim &amp; <span class="number">3</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//4K阶</span></span><br><span class="line">        <span class="keyword">int</span> n_minnum = <span class="number">1</span>, n_maxnum = n_dim * n_dim;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_dim; i++) &#123;</span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n_dim; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>((i % <span class="number">4</span> == j % <span class="number">4</span>) || ((i+j+<span class="number">1</span>)%<span class="number">4</span> ==<span class="number">0</span> &amp;&amp; (i+j+<span class="number">1</span> &gt;= <span class="number">4</span>))) &#123;</span><br><span class="line">                    n_matrix[i][j] = n_maxnum;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    n_matrix[i][j] = n_minnum;</span><br><span class="line">                &#125;</span><br><span class="line">                n_minnum++;</span><br><span class="line">                n_maxnum--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//4K+2阶</span></span><br><span class="line">        <span class="comment">//左上</span></span><br><span class="line">        <span class="keyword">int</span> n_place_1 = <span class="number">0</span>, n_place_2 = n_dim / <span class="number">4</span>;</span><br><span class="line">        n_matrix[n_place_1][n_place_2] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n_dim * n_dim / <span class="number">4</span>; ) &#123;</span><br><span class="line">            n_place_1 = (n_place_1 - <span class="number">1</span> + n_dim / <span class="number">2</span>) % (n_dim / <span class="number">2</span>);</span><br><span class="line">            n_place_2 = (n_place_2 + <span class="number">1</span>) % (n_dim / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(n_matrix[n_place_1][n_place_2] != <span class="number">0</span>) &#123;</span><br><span class="line">                n_place_1 = (n_place_1 + <span class="number">2</span>) % (n_dim / <span class="number">2</span>);</span><br><span class="line">            	n_place_2 = (n_place_2 - <span class="number">1</span> + n_dim / <span class="number">2</span>) % (n_dim / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            n_matrix[n_place_1][n_place_2] = (++i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右下</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n_dim / <span class="number">2</span>; i &lt; n_dim; i++) &#123;</span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> j = n_dim / <span class="number">2</span>; j &lt; n_dim; j++) &#123;</span><br><span class="line">                n_matrix[i][j] = n_matrix[i-n_dim/<span class="number">2</span>][j-n_dim/<span class="number">2</span>] + n_dim * n_dim / <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右上</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_dim / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> j = n_dim / <span class="number">2</span>; j &lt; n_dim; j++) &#123;</span><br><span class="line">                n_matrix[i][j] = n_matrix[i][j-n_dim/<span class="number">2</span>] + n_dim * n_dim / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左下</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n_dim / <span class="number">2</span>; i &lt; n_dim; i++) &#123;</span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n_dim / <span class="number">2</span>; j++) &#123;</span><br><span class="line">                n_matrix[i][j] = n_matrix[i-n_dim/<span class="number">2</span>][j] + <span class="number">3</span> * n_dim * n_dim / <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左对换</span></span><br><span class="line">        <span class="keyword">int</span> n_temp = <span class="number">0</span>, n_clo;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_dim / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            n_clo = <span class="number">0</span>;</span><br><span class="line">            (i == n_dim/<span class="number">4</span>)? n_clo += n_dim/<span class="number">4</span> : n_clo;</span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n_dim / <span class="number">4</span>; j++, n_clo++) &#123;</span><br><span class="line">                n_temp = n_matrix[i][n_clo];</span><br><span class="line">                n_matrix[i][n_clo] = n_matrix[i + n_dim / <span class="number">2</span>][n_clo];</span><br><span class="line">                n_matrix[i + n_dim / <span class="number">2</span>][n_clo] = n_temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右对换</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_dim / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> j = n_dim / <span class="number">2</span> + n_dim / <span class="number">4</span> + <span class="number">2</span>; j &lt; n_dim; j++) &#123;</span><br><span class="line">                n_temp = n_matrix[i][j];</span><br><span class="line">                n_matrix[i][j] = n_matrix[i + n_dim / <span class="number">2</span>][j];</span><br><span class="line">                n_matrix[i + n_dim / <span class="number">2</span>][j] = n_temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//print</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_dim; i++) &#123;</span><br><span class="line">        i == <span class="number">0</span> || <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n_dim; j++) &#123;</span><br><span class="line">            j == <span class="number">0</span> || <span class="built_in">printf</span>(<span class="string">"\t"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, n_matrix[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//test</span></span><br><span class="line">    <span class="keyword">if</span>(test_magic_square(n_matrix, n_dim)) <span class="built_in">printf</span>(<span class="string">"\n...correct!...\n"</span>);</span><br><span class="line">&#125;<span class="comment">//create_magic_square</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">test_magic_square</span><span class="params">(<span class="keyword">int</span>** p_matrix, <span class="keyword">int</span> n_dim)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n_object_sum = (n_dim * n_dim + <span class="number">1</span>) * n_dim / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> n_sum_1, n_sum_2, n_sum_3 = <span class="number">0</span>, n_sum_4 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_dim; i++) &#123;</span><br><span class="line">		n_sum_1 = <span class="number">0</span>, n_sum_2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n_dim; j++) &#123;</span><br><span class="line">            n_sum_1 += p_matrix[i][j];</span><br><span class="line">            n_sum_2 += p_matrix[j][i];</span><br><span class="line">            <span class="keyword">if</span>(i == j) n_sum_3 += p_matrix[i][j];</span><br><span class="line">            <span class="keyword">if</span>(i + j + <span class="number">1</span> == n_dim) n_sum_4 += p_matrix[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n_sum_1 != n_object_sum || n_sum_2 != n_object_sum) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n_sum_3 != n_object_sum || n_sum_4 != n_object_sum) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="变量的存储方式-amp-生存期"><a href="#变量的存储方式-amp-生存期" class="headerlink" title="变量的存储方式&amp;生存期"></a>变量的存储方式&amp;生存期</h3><ul><li><p>按作用域分：</p><ul><li>局部变量：自动变量、静态局部变量、寄存器变量</li><li>全局变量：静态外部变量、外部变量</li></ul></li><li><p>按生存期分：</p><ul><li>动态存储：自动变量、寄存器变量、形式参数</li><li>静态存储：静态局部变量、静态外部变量、外部变量</li></ul></li><li><p>按变量的存放位置分：</p><ul><li>静态存储区：静态局部变量、静态外部变量、外部变量</li><li>动态存储区：自动变量、形式参数</li><li>CPU寄存器：寄存器变量</li></ul></li></ul><h4 id="局部变量的存储类别"><a href="#局部变量的存储类别" class="headerlink" title="局部变量的存储类别"></a>局部变量的存储类别</h4><ul><li><p>自动变量（auto）</p><blockquote><ul><li>函数调用时进行赋初值的</li></ul><p>形参、函数中的局部变量、复合语句中定义的变量等</p></blockquote></li><li><p>静态局部变量（static）</p><blockquote><ul><li>在程序的整个运行期间都不释放；在函数调用后仍然存在，但其他函数不能对其进行引用，只能本函数进行引用，且不能再次定义；</li><li>在编译时赋初值，若没有赋初值，则自动赋值0(‘\0’)；</li></ul></blockquote></li><li><p>寄存器变量（register）</p><blockquote><p>一般，变量的值存于内存中，当程序中有用到其的值时，由控制器发出指令将其值送到运算器中，经过运算操作后若要存值，则需要将其送到内存中去；当一些变量使用频繁时，为了提高效率，可以将局部变量的值存入寄存器中。</p></blockquote></li></ul><hr><h4 id="全局变量的存储类别"><a href="#全局变量的存储类别" class="headerlink" title="全局变量的存储类别"></a>全局变量的存储类别</h4><ul><li>外部变量<ul><li>作用域是从定义开始到本文件结束，位于静态存储区；</li><li>通过extern关键字将其的作用域扩充（在文件内部扩充、扩充到其他文件）</li><li>在编译时分配内存；</li></ul></li><li>静态外部变量<ul><li>只限本文件使用</li></ul></li></ul><hr><h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><ul><li>static声明局部变量，声明存储类型的作用是定义存储的区域以及相应的生存期问题；</li><li>static声明全局变量，声明存储类型的作用是对作用域进行扩展；</li></ul><hr><h4 id="内部函数-static-amp-外部函数-extern"><a href="#内部函数-static-amp-外部函数-extern" class="headerlink" title="内部函数 (static)&amp; 外部函数(extern)"></a>内部函数 (static)&amp; 外部函数(extern)</h4><ul><li>函数调用于定义之后，要在之前使用则需声明函数原型（C中extern可省略）；在其他文件中使用则也要事先声明；</li><li>通过static关键字可以将函数使用限制在本源文件中，其他文件不可调用；</li></ul><hr><h3 id="定义-amp-声明"><a href="#定义-amp-声明" class="headerlink" title="定义&amp;声明"></a>定义&amp;声明</h3><ul><li><p>声明</p><ul><li><p>定义性声明</p><blockquote><p>int nVar = 0;</p></blockquote></li><li><p>扩充性声明</p><blockquote><p>extern int nVar;</p></blockquote></li></ul></li></ul><hr><h3 id="函数指针-amp-指针函数-amp-指针数组-amp-数组指针"><a href="#函数指针-amp-指针函数-amp-指针数组-amp-数组指针" class="headerlink" title="函数指针&amp;指针函数&amp;指针数组&amp;数组指针"></a>函数指针&amp;指针函数&amp;指针数组&amp;数组指针</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*f)(<span class="keyword">int</span>, <span class="keyword">int</span>);	<span class="comment">//指向函数的指针</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">f</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>; 	<span class="comment">//返回值为指针（地址）的函数</span></span><br><span class="line"><span class="keyword">char</span>* str_arr[<span class="number">4</span>]; 	<span class="comment">//指向一个四个char*类型元素的数组</span></span><br><span class="line"><span class="keyword">char</span>(*str_arr)[<span class="number">4</span>];	<span class="comment">//指向一个由四个元素构成的一维数组</span></span><br></pre></td></tr></table></figure><ul><li><p>函数指针</p><blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myFunc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数名是函数的入口地址</span></span><br><span class="line"><span class="comment">//创建一个函数指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*pFunc)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">pFunc = myFunc;</span><br><span class="line">pFunc(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">//创建一个函数指针类型变量</span></span><br><span class="line"><span class="keyword">int</span> (*pFVar)(<span class="keyword">int</span>,<span class="keyword">int</span>) = <span class="literal">NULL</span>;</span><br><span class="line">pFVar = myFunc;</span><br><span class="line">pFVar(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"><span class="comment">//创建一个函数类型</span></span><br><span class="line"><span class="function">typdef <span class="title">int</span> <span class="params">(Func_Type)</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line">Func_Type *pFc= myFunc;</span><br><span class="line">pFc(<span class="number">8</span>, <span class="number">9</span>);</span><br></pre></td></tr></table></figure></blockquote></li></ul><hr><h3 id="浮点型存储"><a href="#浮点型存储" class="headerlink" title="浮点型存储"></a>浮点型存储</h3><h4 id="浮点型转二进制"><a href="#浮点型转二进制" class="headerlink" title="浮点型转二进制"></a>浮点型转二进制</h4><ul><li><p>整数部分：按整数转二进制规则；</p></li><li><p>小数部分：乘2取整，顺序记录；</p></li></ul><blockquote><p>示例：27.75， —&gt; 11011.11</p><blockquote><ul><li><p>整数部分处理： 27 —&gt; 11011</p></li><li><p>小数部分处理： 0.75 —&gt;0.11</p><blockquote><p><code>0.75*2 = 1.5</code> —&gt; 取整1，余0.5</p><p><code>0.5*2 = 1</code> —&gt; 取整1，余0</p></blockquote></li></ul></blockquote></blockquote><hr><h4 id="浮点型在内存中存储"><a href="#浮点型在内存中存储" class="headerlink" title="浮点型在内存中存储"></a>浮点型在内存中存储</h4><ul><li><p>依据IEEE 754，任意一个二进制浮点数可表示为<code>(-1)^S*M*2^E</code></p><blockquote><ul><li><code>(-1)^S</code> 表示符号位，S=0时表正数，S=1时表示负数</li><li><code>M</code> 表示有效数字，大于等于1、小于2</li><li><code>2^E</code> 表示指数位</li></ul></blockquote></li><li><p>IEEE 754规定：</p><blockquote><ul><li><p>对于32位，最高一位是符号位S，接着8位是指数E，剩下23位为有效数字M</p></li><li><p>对于64位，最高一位是符号位S，接着11位是指数E，剩下52位为有效数字M</p></li><li><p>在保存M时，默认这个数第一位总是1，因此可以舍去，只保留小数点后面的数，等读取时再将第一位补上去</p></li><li><p>E是一个<code>unsigned int</code>类型，而指数可以出现负的，因此规定存入内存的E是真实值加上一个中间数（127或1023）</p><blockquote><ul><li><p>E的范围：-126 ~ 128、-1022 ~ 2047</p></li><li><p>E不全为0、不全为1：</p><blockquote><p>取内存中数时，指数E的计算值减去127得真实值，再将有效数字M前加上第一位1</p></blockquote></li><li><p>E全为0：</p><blockquote><p>E等于1-127(或1-1023)即为真实值，有效数字M不再加上第一位的1；这样做是为了表示正负零，以及接近于零的很小数字</p></blockquote></li><li><p>E全为1：</p><blockquote><p>这时有效数字全为0，表示正负无穷大</p></blockquote></li></ul></blockquote></li></ul></blockquote></li></ul><blockquote><p>示例 ：27.75（32位）</p><blockquote><p>27.75的二进制为11011.11，右移直至首位数字为1，则有效数字为1.101111，指数为4，则E= 127+4=131；</p><p>内存存入：<code>0 1000 0011 1011 1100 0000 0000 0000 000</code></p><p>16进制表示： <code>0X41 DE 00 00</code></p></blockquote></blockquote><hr><h3 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h3><ul><li><p>FILE 是指向文件信息的指针变量；</p></li><li><p>fopen() 是为了建立相应的文件信息区、文件缓冲区；</p><blockquote><p>| 文件使用方式 | 含义 | 若指定文件不存在 |<br>| —————— | ————————————————— | ———————— |<br>| “r”（只读） | 输入数据时打开一个已经存在文本文件 | 出错 |<br>| “w”（只写） | 输出数据时打开一个文本文件 | 建立新文件 |<br>| “a”（追加） | 向文本文件尾添加数据 | 出错 |<br>| “r+” | 为了读写，打开一个文本文件 | 出错 |<br>| “w+” | 为了读写，建立一个新的文本文件 | 建立新文件 |<br>| “a+” | 为了读写，打开一个文本文件 | 出错 |<br>| “rb” | 输入数据时打开一个二进制文件 | 出错 |<br>| “wb” | 输出数据时打开一个二进制文件 | 建立新文件 |<br>| “ab” | 向二进制文件尾添加数据 | 出错 |<br>| “rb+” | 为了读写，打开一个二进制文件 | 出错 |<br>| “wb+” | 为了读写，建立一个新的二进制文件 | 建立新文件 |<br>| “ab+” | 为了读写，打开一个二进制文件 | 出错 |</p></blockquote></li><li><p>fclose() 撤销建立的文件信息区、文件缓冲区；</p><blockquote><p>防止误用及缓冲区信息丢失；</p></blockquote></li><li><p>文本文件读写（涉及了ASCII到二进制之间的转换）</p><blockquote><p>计算机输入从ASCII文件读入字符时，遇到回车换行符，系统将其转换为一个换行符，在输出时，将该换行符转换为回车和换行两个字符；</p></blockquote></li><li><p>相关读写函数</p><blockquote><p><code>fgetc()</code> <code>fputc()</code> <code>fgets()</code> <code>fputs</code> <code>fprintf()</code> <code>fscanf()</code></p></blockquote></li><li><p>二进制文件读写一组数据</p><blockquote><p>在内存中的数据形式和输出到外部文件中的数据形式完全一致；</p><p><code>fread()</code> <code>fwrite()</code></p></blockquote></li><li><p>文件位置标记</p><blockquote><p><code>rewind()</code> ： 将文件位置标记设在文件开头</p><p><code>fseek()</code> ：将文件位置标记移动到相应位置</p><blockquote><p>| 名称 | | 起始点 |<br>| ———— | —— | —————— |<br>| SEEK_SET | 0 | 文件开头 |<br>| SEEK_CUR | 1 | 文件当前位置 |<br>| SEEK_END | 2 | 文件尾 |</p></blockquote><p><code>ftell()</code> ：获取当前位置相对于文件头的偏移量</p></blockquote></li><li><p>文件出错检测</p><blockquote><ul><li><p><code>ferror()</code></p><blockquote><p>ferror() 在执行fopen()时初始时置为零，ferror()的值保留至再次调用输入输出函数、或调用clearerr()、或rewind（）;</p></blockquote></li><li><p><code>clearerr()</code></p><blockquote><p>将文件错误标志及文件结束标志置为0；</p></blockquote></li></ul></blockquote></li></ul><hr><h3 id="内存四区模型"><a href="#内存四区模型" class="headerlink" title="内存四区模型"></a>内存四区模型</h3><ul><li>栈区(stack) 高地址 ↓</li><li>堆区(heap) ↑</li><li>全局静态区<ul><li>未初始化数据(bss)</li><li>初始化数据(data)</li><li>文字常量区</li></ul></li><li>代码区(text) 低地址 ↑</li></ul><blockquote><ul><li>对于函数中的局部变量不能返回其地址；因为在函数调用结束后其已释放，原地址中存放的值不确定；</li></ul></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">getFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> str[] = <span class="string">"hello"</span>;</span><br><span class="line">	<span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="keyword">char</span> *s = <span class="literal">NULL</span>;</span><br><span class="line">	s = getFunc();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">test();		<span class="comment">//乱码</span></span><br></pre></td></tr></table></figure><hr><h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><h4 id="函数调用惯例"><a href="#函数调用惯例" class="headerlink" title="函数调用惯例"></a>函数调用惯例</h4><ul><li><p>函数参数的传递顺序和方式</p><blockquote><ul><li><p>栈传递（常见）、寄存器传递</p></li><li><p>有的编译器将参数按从右至左压栈，有的则按从左至右压栈；</p></li></ul></blockquote></li><li><p>栈的维护方式</p><blockquote><p>在将参数压栈后，函数体调用，此后需要将压入栈的参数全部弹出，以使得栈在函数调用前后保持一致。这个工作可以由被调用函数完成，也可由调用函数完成；</p></blockquote></li><li><p>在链接时为了对不同的调用惯例进行区分，编译器对函数本身名字进行修饰，不同调用惯例进行不同修饰；</p><blockquote><p>在c中，存在多个调用惯例，默认的是<code>_cdecl</code> ，任何一个没有显示指定调用惯例的函数都是默认的<code>_cdecl</code>惯例；<code>_cdecl</code>不是标准的关键字，在不同编译器里可能有不同写法；<code>gcc</code>中应使用<code>_attribute_((cdecl))</code>；</p></blockquote><hr><p>| 调用惯例 | 出栈方 | 参数传递 | 名字修饰 |<br>| ———— | ————— | —————————————————————— | ————————————— |<br>| cdecl | 函数调用方 | 从右至左参数入栈 | 下划线+函数名 |<br>| stdcall | 函数本身 | 从右至左参数入栈 | 下划线+函数名+@+参数字节数 |<br>| fastcall | 函数本身 | 前两个参数由寄存器传递，其余参数通过堆栈传递 | @+函数名+@+函数的字节数 |<br>| pascal | 函数本身 | 从左至右参数入栈 | 较复杂 |</p><ul><li><code>cdecl</code>可以处理可变参数的函数，<code>stdcall</code>不能处理带有可变参数的函数；<ul><li>其本质原因是谁去执行清理参数这个任务；对于<code>stdcall</code>而言，在调用函数得到所有参数，完成操作后，并没有去计算或没有一个地方记录了关于参数的栈空间有多大，而由于该任务是调用函数本身完成的，因此出错；</li></ul></li></ul></li></ul><hr><h4 id="函数调用流程"><a href="#函数调用流程" class="headerlink" title="函数调用流程"></a>函数调用流程</h4><ul><li><p>参考代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    sum = x + y;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> nVar1 = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> nVar2 = <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">int</span> nVar3 = <span class="number">0</span>;</span><br><span class="line">	nVar3 = add(nVar1, nVar2);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>反编译</p><blockquote><p>运行环境：x86</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="number">00F</span>220F0  push        ebp  </span><br><span class="line"><span class="number">00F</span>220F1  mov         ebp,esp  </span><br><span class="line"><span class="number">00F</span>220F3  sub         esp,<span class="number">0</span>CCh  </span><br><span class="line"><span class="number">00F</span>220F9  push        ebx  </span><br><span class="line"><span class="number">00F</span>220FA  push        esi  </span><br><span class="line"><span class="number">00F</span>220FB  push        edi  </span><br><span class="line"><span class="number">00F</span>220FC  lea         edi,[ebp<span class="number">-0</span>CCh]  </span><br><span class="line"><span class="number">00F</span>22102  mov         ecx,<span class="number">33</span>h  </span><br><span class="line"><span class="number">00F</span>22107  mov         eax,<span class="number">0</span>CCCCCCCCh  </span><br><span class="line"><span class="number">00F</span>2210C  rep stos    dword ptr es:[edi]  </span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="number">00F</span>2210E  mov         dword ptr [sum],<span class="number">0</span>  </span><br><span class="line">	sum = x + y;</span><br><span class="line"><span class="number">00F</span>22115  mov         eax,dword ptr [x]  </span><br><span class="line"><span class="number">00F</span>22118  add         eax,dword ptr [y]  </span><br><span class="line"><span class="number">00F</span>2211B  mov         dword ptr [sum],eax  </span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line"><span class="number">00F</span>2211E  mov         eax,dword ptr [sum]  </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">00F</span>22121  pop         edi  </span><br><span class="line"><span class="number">00F</span>22122  pop         esi  </span><br><span class="line"><span class="number">00F</span>22123  pop         ebx  </span><br><span class="line"><span class="number">00F</span>22124  mov         esp,ebp  </span><br><span class="line"><span class="number">00F</span>22126  pop         ebp  </span><br><span class="line"><span class="number">00F</span>22127  ret</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  <span class="number">00F</span>216D0  push        ebp  </span><br><span class="line">  <span class="number">00F</span>216D1  mov         ebp,esp  </span><br><span class="line">  <span class="number">00F</span>216D3  sub         esp,<span class="number">0E4</span>h  </span><br><span class="line">  <span class="number">00F</span>216D9  push        ebx  </span><br><span class="line">  <span class="number">00F</span>216DA  push        esi  </span><br><span class="line">  <span class="number">00F</span>216DB  push        edi  </span><br><span class="line">  <span class="number">00F</span>216DC  lea         edi,[ebp<span class="number">-0E4</span>h]  </span><br><span class="line">  <span class="number">00F</span>216E2  mov         ecx,<span class="number">39</span>h  </span><br><span class="line">  <span class="number">00F</span>216E7  mov         eax,<span class="number">0</span>CCCCCCCCh  </span><br><span class="line">  <span class="number">00F</span>216EC  rep stos    dword ptr es:[edi]  </span><br><span class="line">  	<span class="keyword">int</span> nVar1 = <span class="number">10</span>;</span><br><span class="line">  <span class="number">00F</span>216EE  mov         dword ptr [nVar1],<span class="number">0</span>Ah  </span><br><span class="line">  	<span class="keyword">int</span> nVar2 = <span class="number">20</span>;</span><br><span class="line">  <span class="number">00F</span>216F5  mov         dword ptr [nVar2],<span class="number">14</span>h  </span><br><span class="line">  	<span class="keyword">int</span> nVar3 = <span class="number">0</span>;</span><br><span class="line">  <span class="number">00F</span>216FC  mov         dword ptr [nVar3],<span class="number">0</span>  </span><br><span class="line">  	nVar3 = add(nVar1, nVar2);</span><br><span class="line">  <span class="number">00F</span>21703  mov         eax,dword ptr [nVar2]  </span><br><span class="line">  <span class="number">00F</span>21706  push        eax  </span><br><span class="line">  <span class="number">00F</span>21707  mov         ecx,dword ptr [nVar1]  </span><br><span class="line">  <span class="number">00F</span>2170A  push        ecx   </span><br><span class="line">  <span class="number">00F</span>2170<span class="function">B  call        <span class="title">add</span> <span class="params">(<span class="number">0F</span>2126Ch)</span></span></span><br><span class="line">  00F21710  add         esp,8  </span><br><span class="line">  <span class="number">00F</span>21713  mov         dword ptr [nVar3],eax  </span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="number">00F</span>21716  <span class="keyword">xor</span>         eax,eax  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">00F</span>21718  pop         edi  </span><br><span class="line">  <span class="number">00F</span>21719  pop         esi  </span><br><span class="line">  <span class="number">00F</span>2171A  pop         ebx  </span><br><span class="line">  <span class="number">00F</span>2171B  add         esp,<span class="number">0E4</span>h  </span><br><span class="line">  <span class="number">00F</span>21721  cmp         ebp,esp  </span><br><span class="line">  <span class="number">00F</span>21723  call        __RTC_CheckEsp (<span class="number">0F</span>2110Eh)  </span><br><span class="line">  <span class="number">00F</span>21728  mov         esp,ebp  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">00F</span>2172A  pop         ebp  </span><br><span class="line"><span class="number">00F</span>2172B  ret</span><br></pre></td></tr></table></figure></li></ul><hr><p><img src="/2021/03/14/c_notes/c_pictures_1.jpg" alt="函数栈帧"></p><hr><blockquote><p><code>main()</code>：</p><ul><li><p><code>ebp</code>和<code>esp</code>是用来维护函数栈底、栈顶的指针，<code>esp</code>指向栈顶，<code>ebp</code>指向栈底；</p></li><li><p>main() 函数栈帧创建</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00F</span>216D0  push        ebp  					<span class="comment">//记录调用函数函数栈的栈底指针</span></span><br><span class="line"><span class="number">00F</span>216D1  mov         ebp,esp  				<span class="comment">//将main()函数栈底指针ebp指向esp指向处</span></span><br><span class="line"><span class="number">00F</span>216D3  sub         esp,<span class="number">0E4</span>h</span><br><span class="line">    <span class="comment">//将栈顶esp指针向下偏移0E4h大小,即当前开辟了0E4h大小的栈空间</span></span><br><span class="line"><span class="number">00F</span>216D9  push        ebx  					<span class="comment">//压栈，保存寄存器中的值</span></span><br><span class="line"><span class="number">00F</span>216DA  push        esi  					<span class="comment">//压栈，保存寄存器中的值</span></span><br><span class="line"><span class="number">00F</span>216DB  push        edi  					<span class="comment">//压栈，保存寄存器中的值</span></span><br><span class="line"><span class="number">00F</span>216DC  lea         edi,[ebp<span class="number">-0E4</span>h]  	<span class="comment">//加载有效地址，将ebp-0E4h存放到寄存器edi中</span></span><br><span class="line"><span class="number">00F</span>216E2  mov         ecx,<span class="number">39</span>h  				<span class="comment">//将39h放到寄存器ecx中</span></span><br><span class="line"><span class="number">00F</span>216E7  mov         eax,<span class="number">0</span>CCCCCCCCh  		<span class="comment">//将0CCCCCCCCh放到寄存器eax中</span></span><br><span class="line"><span class="number">00F</span>216EC  rep stos    dword ptr es:[edi]  </span><br><span class="line">	<span class="comment">//表示按双字节从ebp-0E4h向下拷贝39h次0CCCCCCCCh，即将上面0E4h大小空间初始化 </span></span><br></pre></td></tr></table></figure></li><li><p>main() 函数局部变量初始化</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">int</span> nVar1 = <span class="number">10</span>;</span><br><span class="line"><span class="number">00</span>C116EE  mov         dword ptr [nVar1],<span class="number">0</span>Ah  	<span class="comment">//将0Ah拷贝到ebp-12指向的地址空间</span></span><br><span class="line">	<span class="keyword">int</span> nVar2 = <span class="number">20</span>;</span><br><span class="line"><span class="number">00</span>C116F5  mov         dword ptr [nVar2],<span class="number">14</span>h  	<span class="comment">//将14h拷贝到ebp-28指向的地址空间</span></span><br><span class="line">	<span class="keyword">int</span> nVar3 = <span class="number">0</span>;</span><br><span class="line"><span class="number">00</span>C116FC  mov         dword ptr [nVar3],<span class="number">0</span>  		<span class="comment">//将0拷贝到ebp-36指向的地址空间</span></span><br></pre></td></tr></table></figure></li><li><p>```c</p><pre><code>nVar3 = add(nVar1, nVar2);
</code></pre><p>//函数形参eax ecx<br>00C11703 mov eax,dword ptr [nVar2] //将nVar2的值拷贝到寄存器eax中<br>00C11706 push eax //压栈<br>00C11707 mov ecx,dword ptr [nVar1] //将nVar1的值拷贝到寄存器ecx中<br>00C1170A push ecx //压栈<br>00C1170B call add (0F2126Ch)</p><pre><code>//call指令，调用函数，在栈顶ecx上开辟了一块新空间，
//用于存放函数的返回地址，即call指令的下一条指令；
//这个地址的作用是在call指令调用add()结束时jmp能够找到下一条指令的地址；
</code></pre><p>00C11710 add esp,8</p><pre><code>//调整栈顶指针，释放函数形参（eax,ecx）所占的空间
</code></pre><p>00C11713 mov dword ptr [nVar3],eax</p><pre><code>//将eax中的值拷贝到ebp-36指向的地址空间
</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;&#96;&#96;c</span><br><span class="line">  	return 0;</span><br><span class="line">  00C11716  xor         eax,eax 		&#x2F;&#x2F;异或运算，将eax寄存器清零（效率高于mov eax,0）</span><br></pre></td></tr></table></figure></li><li><p>```c<br>00C11718 pop edi //出栈，恢复寄存器的值出栈<br>00C11719 pop esi //出栈<br>00C1171A pop ebx //出栈<br>00C1171B add esp,0E4h //栈顶指针偏移0E4h大小，释放之前分配的0E4h大小空间<br>00C11721 cmp ebp,esp<br>00C11723 call __RTC_CheckEsp (0F2110Eh)<br>00C11728 mov esp,ebp //将栈顶指针指向栈顶指针处，释放局部变量<br>00C1172A pop ebp //出栈，恢复栈底指针ebp的值<br>00C1172B ret</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">&#96;add()&#96;：</span><br><span class="line"></span><br><span class="line">- add() 函数栈帧的创建</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;c</span><br><span class="line">  00F220F0  push        ebp  				&#x2F;&#x2F;记录调用函数main()函数栈的栈底指针</span><br><span class="line">  00F220F1  mov         ebp,esp  			&#x2F;&#x2F;将main()函数栈底指针ebp指向esp指向处</span><br><span class="line">  00F220F3  sub         esp,0CCh  		&#x2F;&#x2F;将栈顶esp指针向下偏移0CCh大小</span><br><span class="line">  00F220F9  push        ebx  				&#x2F;&#x2F;压栈，保存寄存器中的值</span><br><span class="line">  00F220FA  push        esi  				&#x2F;&#x2F;压栈	</span><br><span class="line">  00F220FB  push        edi  				&#x2F;&#x2F;压栈</span><br><span class="line">  00F220FC  lea         edi,[ebp-0CCh]  	&#x2F;&#x2F;加载有效地址，将ebp-0CCh存放到寄存器edi	</span><br><span class="line">  00F22102  mov         ecx,33h  			&#x2F;&#x2F;将33h放到寄存器ecx中</span><br><span class="line">  00F22107  mov         eax,0CCCCCCCCh  	&#x2F;&#x2F;将0CCCCCCCCh放到寄存器eax中	</span><br><span class="line">  00F2210C  rep stos    dword ptr es:[edi]  	</span><br></pre></td></tr></table></figure></li><li><p>esp 002DFD4C</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="number">00F</span>2210E  mov         dword ptr [sum],<span class="number">0</span>  	<span class="comment">//将ebp-12地址空间初始化为0</span></span><br><span class="line">	sum = x + y;</span><br><span class="line"><span class="number">00F</span>22115  mov         eax,dword ptr [x]  	</span><br><span class="line">    <span class="comment">//将ebp+8地址中的值拷贝到eax中；</span></span><br><span class="line">    <span class="comment">//ebp+8地址 就是 执行call指令之前压入栈的ecx</span></span><br><span class="line"><span class="number">00F</span>22118  add         eax,dword ptr [y]  	</span><br><span class="line">    <span class="comment">//将eax值和ebp+12值进行add操作，结果放入eax中</span></span><br><span class="line">    <span class="comment">//ebp+8地址 就是 执行call指令之前压入栈的eax</span></span><br><span class="line"><span class="number">00F</span>2211B  mov         dword ptr [sum],eax  	<span class="comment">//将寄存器eax中的值拷贝到ebp-12地址中</span></span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line"><span class="number">00F</span>2211E  mov         eax,dword ptr [sum]  	<span class="comment">//将ebp-12中的值拷贝到eax中</span></span><br></pre></td></tr></table></figure></li><li><p>```c<br>00F22121 pop edi //出栈，恢复寄存器的值出栈<br>00F22122 pop esi //出栈<br>00F22123 pop ebx //出栈<br>00F22124 mov esp,ebp //将栈顶指针指向栈顶指针处，释放局部变量<br>00F22126 pop ebp //出栈，恢复main()函数栈栈底指针ebp的值<br>00F22127 ret //ret指令，弹出栈顶，将其值（函数返回地址）给EIP代码指令寄存器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- RET∶ 指令助记符——返回。</span><br><span class="line"></span><br><span class="line">  - 段内返回</span><br><span class="line"></span><br><span class="line">    &gt; 先将栈顶的字送入IP，然后SP增2 。若带立即数，SP再加立即数（丢弃一些在执行CALL之前入栈的参数）。</span><br><span class="line"></span><br><span class="line">  - 段间返回</span><br><span class="line"></span><br><span class="line">    &gt; 栈顶的字送入IP后（SP增 2），再将栈顶的字送入CS，SP再增2 。若带立即数，则SP再加立即数。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">[详见1：浅谈函数的调用过程，栈桢的创建和销毁](&quot;https:&#x2F;&#x2F;blog.csdn.net&#x2F;spaceman_c&#x2F;article&#x2F;details&#x2F;80045269&quot;)</span><br><span class="line">[详见2：调用栈和各种调用约定的总结对比](&quot;https:&#x2F;&#x2F;www.it610.com&#x2F;article&#x2F;1304355669196967936.htm&quot;)</span><br><span class="line">[详见3：深入理解函数调用跳转地址](&quot;https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_41028621&#x2F;article&#x2F;details&#x2F;87830267&quot;)</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">#### 栈的生长方向 &amp; 内存存放方向 ####</span><br><span class="line"></span><br><span class="line">- 栈：	从高地址向低地址增长;</span><br><span class="line"></span><br><span class="line">- 内存：从低地址向高地址增长;</span><br><span class="line"></span><br><span class="line">**小端对齐：**  栈的低地址对齐于内存低地址，栈的高地址对齐于内存高地址；</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### Q：求解子串在主串中的首位置 ###</span><br><span class="line"></span><br><span class="line">#### 回溯法 ####</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;c</span><br><span class="line">int substrloc(const char * str, const char * sub_str)</span><br><span class="line">&#123;</span><br><span class="line">	const char * p &#x3D; str, *q &#x3D; sub_str;</span><br><span class="line">#if 0</span><br><span class="line">	int loc &#x3D; 0, flag &#x3D; 1;</span><br><span class="line">	while (*p)</span><br><span class="line">	&#123;</span><br><span class="line">		while (*q)</span><br><span class="line">		&#123;</span><br><span class="line">			if (*q++ &#x3D;&#x3D; *p++);</span><br><span class="line">			else</span><br><span class="line">			&#123;</span><br><span class="line">				flag &#x3D; 0;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (!flag)</span><br><span class="line">		&#123;</span><br><span class="line">			p &#x3D; str + ++loc;</span><br><span class="line">			q &#x3D; sub_str;</span><br><span class="line">			flag &#x3D; 1;</span><br><span class="line">		&#125;</span><br><span class="line">		else return (loc + 1);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">#elif 1</span><br><span class="line">	while (*p)</span><br><span class="line">	&#123;</span><br><span class="line">		if (*p &#x3D;&#x3D; *q)</span><br><span class="line">		&#123;</span><br><span class="line">			++p;</span><br><span class="line">			++q;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			p &#x3D; p - q + sub_str + 1;</span><br><span class="line">			q &#x3D; sub_str;</span><br><span class="line">		&#125;</span><br><span class="line">		if (*q &#x3D;&#x3D; &#39;\0&#39;) return ((p - str) - (q - sub_str) + 1);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">#else</span><br><span class="line">	while (*p)</span><br><span class="line">	&#123;</span><br><span class="line">		if (*p !&#x3D; *q)</span><br><span class="line">		&#123;</span><br><span class="line">			++p;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		while (*q)</span><br><span class="line">		&#123;</span><br><span class="line">			if (*q !&#x3D; *p++)</span><br><span class="line">			&#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			++q;</span><br><span class="line">		&#125;</span><br><span class="line">		if (*q &#x3D;&#x3D; &#39;\0&#39;) return ((p - str) - (q - sub_str) + 1);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><ul><li><p>Q： 当主串i位置与子串j位置不匹配时，主串不进行回溯，而是将子串应当滑动到什么位置k，即next[j]是什么</p><blockquote><p>问题详解：当 <code>T[i-j ~ i-1] = P[0 ~ j-1]</code> ，<code>T[i] ≠ P[j]</code>，</p><p>又若 <code>P[j-k ~ j-1] = P[0 ~ k-1]</code>， 则 <code>P[j-k ~ j-1] = T[i-k ~ i-1]</code></p></blockquote></li><li><p>当 <code>P[0 ~ k-1] = P[j-k ~ j-1]</code>，</p><ul><li>若 <code>P[k] = P[j]</code>，则 <code>P[0 ~ k] = P[j-k ~ j]</code>, 即 <code>next[j+1] = k + 1 = next[j] + 1</code>;</li><li>否则，将<code>P[0 ~ k]</code>看作新模串, 将<code>P[0 ~ j]</code>看作新主串，问题变为新主串位置j与新模串位置k不匹配问题，则<code>k = next[k]</code></li></ul></li><li><p>优化：</p><blockquote><p>若主串i位置和子串j位置不匹配时，其要滑动位置k所指向的字符和子串原j位置指向字符相同时，将滑动位置置为 <code>next[j] = next[k]</code> ;</p></blockquote></li></ul><blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">substrloc_kmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * str, <span class="keyword">const</span> <span class="keyword">char</span> * sub_str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> * next = get_nextArray(sub_str);</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> len_str = <span class="built_in">strlen</span>(str);</span><br><span class="line">	<span class="keyword">int</span> len_substr = <span class="built_in">strlen</span>(sub_str);</span><br><span class="line">	<span class="keyword">while</span> (i &lt; len_str &amp;&amp; j &lt; len_substr)</span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">if</span> (j == <span class="number">-1</span> || sub_str[j] == str[i])</span><br><span class="line">		&#123;</span><br><span class="line">			++i;</span><br><span class="line">			++j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			j = next[j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (j == len_substr) <span class="keyword">return</span> (i - j + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//substrloc_kmp</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">get_nextArray</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * str_model)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="built_in">strlen</span>(str_model);</span><br><span class="line">	<span class="keyword">int</span> * next = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(len*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">	<span class="built_in">memset</span>(next, <span class="number">0</span>, len*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">-1</span>, j = <span class="number">0</span>;</span><br><span class="line">	next[j] = k;</span><br><span class="line">	<span class="keyword">while</span> (j &lt; len - <span class="number">1</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (k == <span class="number">-1</span> || str_model[j] == str_model[k])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (str_model[j++] == str_model[k++]) next[j] = next[k];</span><br><span class="line">			<span class="keyword">else</span> next[j] = k;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> k = next[k];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> next;</span><br><span class="line">&#125;<span class="comment">//get_nextArray</span></span><br></pre></td></tr></table></figure></blockquote><hr><h3 id="数组名"><a href="#数组名" class="headerlink" title="数组名"></a>数组名</h3><blockquote><ul><li><p>一般情况下，数组名可看作是指向数组首元素的指针；</p></li><li><p>sizeof 、 取地址&amp;时，不能看作指向数组首元素的指针，是数组类型；</p></li><li><p>数组名是一个常量指针 ；</p></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个数组类型</span></span><br><span class="line">typedef int (ARRAY_TYPE)[5];</span><br><span class="line">ARRAY_TYPE my_arr, * ptr;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(my_arr)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>); ++i) my_arr[i] = i + <span class="number">1</span>;</span><br><span class="line">ptr = &amp;my_arr;		<span class="comment">//数组指针，步长为数组字节大小 		类型：(int*)[5]</span></span><br><span class="line"><span class="comment">// my_arr	类型：int[5]</span></span><br><span class="line"><span class="comment">//（*ptr）是数组名，指向数组首元素的指针  	类型：int[5]</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个数组指针类型</span></span><br><span class="line">typedef int (*PTR_ARRAY_TYPE)[5];</span><br><span class="line">PTR_ARRAY_TYPE ptr1 = &amp;my_arr;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个数组指针变量</span></span><br><span class="line"><span class="keyword">int</span> （*ptr2)[<span class="number">5</span>] = &amp;my_arr;</span><br></pre></td></tr></table></figure></blockquote><hr><h3 id="逆转链表"><a href="#逆转链表" class="headerlink" title="逆转链表"></a>逆转链表</h3><ul><li><p>带头结点</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(LinkList L)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//idea 1:  从链表第二个结点处删除 &amp; 再头插入链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(LinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   	<span class="comment">//链表不存在； 链表为空； 链表只有一个结点；</span></span><br><span class="line">    <span class="keyword">if</span>(!L || !L-&gt;next || !L-&gt;next-&gt;next) <span class="keyword">return</span>;</span><br><span class="line">    LNode *p = head-&gt;next, *q = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>((q = p-&gt;next) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;next = q-&gt;next;</span><br><span class="line">        q-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next = q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//idea 2:  将当前结点的指针域从指向后继改为指向前驱</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(LinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!L || !L-&gt;next || !L-&gt;next-&gt;next) <span class="keyword">return</span>;</span><br><span class="line">	LNode *pCurr = head-&gt;next, *pBef = <span class="literal">NULL</span>, *pAft = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(!pCurr)</span><br><span class="line">    &#123;</span><br><span class="line">        pAft = pCurr-&gt;next;</span><br><span class="line">        pCurr-&gt;next = pBef;</span><br><span class="line">        pBef = pCurr;</span><br><span class="line">        pCurr = pAft;</span><br><span class="line">    &#125;</span><br><span class="line">    head-&gt;next = pBef;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//idea 3:  利用递归思想处理: 从链表中删除并保存第一个结点，逆转新链表，并将第一个结点链接到最后</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(LinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!L || !L-&gt;next || !L-&gt;next-&gt;next) <span class="keyword">return</span>;</span><br><span class="line">	LNode *p = head-&gt;next, *q = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(!p)</span><br><span class="line">    &#123;</span><br><span class="line">        q = p;</span><br><span class="line">        q-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        head-&gt;next = p;</span><br><span class="line">		Reverse(head);</span><br><span class="line">        p-&gt;next = q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="静态库-amp-动态库"><a href="#静态库-amp-动态库" class="headerlink" title="静态库 &amp; 动态库"></a>静态库 &amp; 动态库</h3><ul><li><p>静态链接库：</p><blockquote><ul><li>在编译时将所用到静态库中的函数实现加载到执行文件中</li><li>xxx.lib （Windows）, libxxx.so（Linux）</li></ul></blockquote><ul><li>缺点：<ul><li>内存浪费、磁盘空间浪费比较大</li><li>程序开发和发布时问题</li></ul></li></ul></li><li><p>动态链接库：</p><blockquote><ul><li>在运行时链接动态库，在编译阶段只把函数的重定位信息放到可执行文件中。动态链接库的lib文件只在编译阶段使用，dll文件只在程序运行阶段需要；</li><li>xxx.dll （Windows）, libxxx.a （Linux）</li></ul></blockquote></li></ul><p><a href="&quot;https://blog.csdn.net/hsqyc/article/details/88056983&quot;">1. C/C++库文件全了解</a></p><p><a href="&quot;https://www.processon.com/view/link/5c70f497e4b0feef9f352ea2#map&quot;">2. 编译过程</a></p><hr>]]></content>
      <categories>
        <category>c++</category>
        <category>c</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>notes</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>Notes_2_C++primerplus.md</title>
    <url>/2021/01/17/Notes-2-C-primerplus-md/</url>
    <content><![CDATA[<h2 id="Chapter-2"><a href="#Chapter-2" class="headerlink" title="Chapter 2"></a>Chapter 2</h2><blockquote><p><strong>key:</strong> main()、命名空间、语句、函数、cin、cout；<br><a id="more"></a></p></blockquote><ul><li><pre><code class="lang-c++">int main(void)        // function head  ==&gt; the interface between it and call function
{        // ******** function definition ********
    // ******** 函数体 begin********
    //statement        
    return 0;        // 结束函数
    // ******** 函数体 end********
}
</code></pre><blockquote><ul><li>main()被启动代码调用，而启动代码是由编译器加到程序中的，是程序和OS之间的桥梁。</li><li>C++中的<code>int main(void)</code>和 <code>int main()</code>等效，而在C中，前者意味着对是否接收参数保持沉默。</li><li>ANSI/ISO C++标准允许main()函数后省略<code>return 0；</code>，当编译器到达main()函数末尾时无返回语句则默认以<code>return 0；</code>结尾。</li><li>在windows编程中，可以编写一个动态链接DLL模块，由于DLL模块不是独立的程序，故不需要main()。</li><li>有些编程环境提供一个框架程序，该程序调用一些非标准函数，如_tmain()；在这种情况下，会有一个隐藏的main()调用_tmain()。</li><li>main函数的返回值可以通过windows命令行批处理文件或UNIX的shell脚本来测试。</li><li>main不是一个关键字。</li></ul></blockquote></li><li><p>C++注释：1. “// …” 2.”/<em> … </em>/“（C注释）</p><blockquote><p>注：尽量使用前者，这不涉及到末尾符号与起始符号的正确匹配。（C99标准在C中也添加了注释“//”）</p></blockquote></li><li><p>C++和C一样也是使用一个预处理器；该程序在进行编译之前对源文件进行处理。（当然，有的C++实现使用翻译器将C++程序转换为C程序，该翻译器也是一种预处理器。）不必执行任何特殊操作来调用预处理器，它在编译程序时自动运行。</p><blockquote><p><code>#icnlude&lt;iostream&gt;</code>该编译指令导致预处理器将iostream文件的内容添加到程序中去。</p></blockquote></li></ul><ul><li><p>| 头文件类型 | 约定 | 示例 | 说明 |<br>| —————- | ————————- | ————— | ————————————————- |<br>| c++旧式风格 | 以.h结尾 | iostream.h | c++程序可使用 |<br>| c旧式风格 | 以.h结尾 | math.h | c\c++程序可使用 |<br>| c++新式风格 | 无扩展名 | iostream | c++程序可使用，使用namespace std; |<br>| 转换后的c | 加前缀c，无扩展名 | cmath | c++程序可使用，可使用不是c的特性 |</p></li><li><p>命名空间是C++的一特性，旨在编写大型程序以及将多个厂商现有代码组合起来的程序更容易，有助于组织程序。按照这种方式，类、函数、变量是C++的标准组件，它们都放置在命名空间std之中。故，iostream文件中定义的用于输出的cout变量实际上是std::cout，endl实际上是std::endl。using编译指令，可通过<code>using namespace std;</code>语句表明可使用std命名空间的所有定义的名称。</p><blockquote><p>Microflop::wanda() || Piscine::wanda()</p><p>using std::cout; || using namespace std;</p></blockquote></li><li><p><code>cout &lt;&lt; &quot;hello world！&quot;;</code> 表明程序将一个字符串插入到输出流中。</p><blockquote><ul><li><p><code>cout</code>是ostream类的对象实例。</p></li><li><p><code>&lt;&lt;</code>是插入运算符，指出了信息流动的方向。 实际上是”&lt;&lt;”运算符重载。</p></li><li><code>cout</code>是预定义的对象；从概念上看，输出是一个流，即从程序流出一系列字符。cout表示了这种流。</li><li>c++扩展了运算符的重载概念，允许用户定义的类型（类）重新定义运算符的含义。</li></ul></blockquote></li><li><ol><li>控制符(mainipulator)：诸如endl等对cout有特殊含义的特殊符号；</li><li>换行符：c的符号\n;</li></ol></li></ul><blockquote><p><code>cout&lt;&lt;&quot;\n&quot;;</code>和<code>cout&lt;&lt;endl;</code>两者都可换行。但，后者确保程序继续运行刷新输出（即将其立即显在屏幕上），而前者不能提供这样的保证。这意味着在有些系统中，可能在输入信息后才能显示。</p></blockquote><ul><li>源代码中的标记和空白：<br>token:一行代码中不可分割元素；<br>white space:空格、制表符、回车统称；</li></ul><blockquote><p>通常，必须使用空白将两个标记分开；而有些字符（如括号、逗号）是不需要用空白分开的标记。</p></blockquote><ul><li><p>cin使用&gt;&gt;运算符从输入流中抽取字符。</p></li><li><p>类描述了一种数据类型的全部属性（包括可对其执行的操作），对象是根据这些描述创建的实体。类描述了可对类对象执行的所有操作。要对特定对象执行这些允许的操作，需要给对象发送一条消息。</p><blockquote><p>C++提供了两种发送消息方式：</p><ol><li>使用类方法；（类似函数调用）</li><li>重新定义运算符；（如cin、cout采用）</li></ol></blockquote></li><li><p>在使用函数之前，C++编译器必须知道函数的参数类型和返回值类型。C++提供了这种信息的方式：使用函数原型语句。如果省略分号，编译器将把这行代码解释为函数头，并要求接着提供定义函数的函数体。当然，C++不能在函数内嵌套定义函数。</p><blockquote><p>C\C++将库函数的原型和定义分开，库文件中包含了函数的编译代码，头文件中包含了原型。编译器编译程序时，它必须在库文件搜索要使用的函数。当然，只包含头文件可以提供原型，但不一定会导致编译器搜索正确的库文件。</p></blockquote></li></ul><hr>]]></content>
      <categories>
        <category>c++</category>
        <category>c++primerplus</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>Notes_1_C++primerplus.md</title>
    <url>/2021/01/16/Notes-1-C-primerplus-md/</url>
    <content><![CDATA[<h2 id="Chapter-1"><a href="#Chapter-1" class="headerlink" title="Chapter 1"></a>Chapter 1</h2><blockquote><p><strong>key:</strong> 过程性编程、面向对象编程（OOP）、泛型编程；<br><a id="more"></a></p></blockquote><ul><li><p>C++融合了三中编程方式：</p><ol><li>C语言代表的过程性语言；</li><li>C++在C上添加的以类为代表的面向对象语言；</li><li>C++模板支持的泛型编程；</li></ol></li><li><p>一般而言，计算机要处理两个概念：即 数据（程序使用及处理的信息） + 算法（程序使用的方法）；</p></li><li><p>过程性编程首先要确定计算机应采取的措施，然后使用编程语言来实现这些操作；过程性编程强调编程的算法方面；</p></li><li><p>早期程序语言（FORTRAN, BASIC）遇到组织方面问题；即所谓的“意大利面式编程”；</p><ul><li><p>结构化编程</p><blockquote><p>将分支（决定接下来应执行哪个指令）限制为一小组行为良好的结构。（如，for循环，while循环，do…while…）</p></blockquote></li><li><p>自顶向下(top-down)设计</p><blockquote><p>C中其理念是将大型程序分解为小型的、便于管理任务，一直分解为小型的、便于编程的模块；因此，鼓励程序员开发程序单元（函数）来表示各个程序模块。</p></blockquote></li></ul></li><li><ul><li><p>OOP强调的是数据，与强调算法的过程性编程相比；</p></li><li><p><strong>OOP其理念是设计与问题本质特性相对应的数据格式</strong>。C++中的类是一种规范，描述了这种数据格式，而对象是根据这种规范构造出来的一种特定的数据结构。</p></li><li><p>OOP程序设计方法首先设计类，然后通过设计一个使用这些类的对象程序。</p><blockquote><p>从低级组织（类）到高级组织（程序）的处理过程称为<strong>自下而上</strong>(bottom-up)的编程。</p></blockquote></li><li><p>OOP编程不仅将数据和方法合并为类定义。还有助于创建可重用代码、信息隐藏可以保护数据、多态能为运算符创建多个定义、继承可使旧类派生出新类；</p></li></ul></li><li><p><strong>泛型编程</strong>（generic programming）与OOP目标相同，即使重用代码和抽象通用概念更为简单。不过OOP强调的是编程的数据方面，而泛型编程强调<strong>独立与特定的数据类型</strong>。OOP是一个管理大型项目工具，而泛型编程提供了执行常见任务的工具。</p></li><li><p>C++的二重性：</p><ol><li>OOP部分提供了高级抽象，赋予C++将问题设计概念相联系的能力；</li><li>C部分赋予C++语言紧密联系硬件能力；</li></ol></li><li><p>源代码 —&gt; 编译器 —&gt; 目标代码 ————启动代码+库代码——-&gt; 链接程序 —&gt; 可执行代码</p><hr></li></ul>]]></content>
      <categories>
        <category>c++</category>
        <category>c++primerplus</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构笔记_1</title>
    <url>/2020/09/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0_1/</url>
    <content><![CDATA[<p>Notes_1</p><h2><a href="#" class="headerlink"></a><a id="more"></a></h2><h1 id="1-1-线性表的类型定义"><a href="#1-1-线性表的类型定义" class="headerlink" title="1.1 线性表的类型定义"></a>1.1 线性表的类型定义</h1><p><strong>线性表</strong>：简单来说，一个线性表是n个数据元素的有限序列。</p><p><strong>记录</strong>：数据元素（由若干个数据项组成的那些数据元素）。</p><p><strong>文件</strong>：含有大量记录的线性表。</p><p><strong>线性表的长度</strong>：即线性表中元素的个数。</p><p><strong>位序</strong>：元素$a_i$是线性表L的第i个元素，则称i为$a_i$在L中的位序。</p><blockquote><p>同一线性表中的元素是同一数据对象（即具有相同的特性），并<strong>相邻</strong>的数据元素之间具有<strong>序偶关系</strong>。若将线性表记为$L=(a_1,a_2,…,a_n)$，则除了第一个数据元素以外其余的都具有一个<strong>直接前驱</strong>，除了最后一个数据元素以外其余的都具有一个<strong>直接后继</strong>。</p></blockquote><p><strong>抽象数据类型线性表的定义：</strong><br></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ATD List&#123;</span><br><span class="line">    数据对象：D = &#123;ai | ai∈Elemset，i=<span class="number">1</span>,...,n, n&gt;=<span class="number">0</span>&#125;</span><br><span class="line">    数据关系：R1 = &#123;&lt;ai<span class="number">-1</span>,ai&gt; | ai<span class="number">-1</span>,ai∈D，i=<span class="number">1</span>,...,n&#125;</span><br><span class="line">    基本操作：</span><br><span class="line">        InitList(&amp;L)</span><br><span class="line">        操作结果：构造了一个空的线性表L。</span><br><span class="line">        DestroyList(&amp;L)</span><br><span class="line">        初始条件：线性表L已存在。</span><br><span class="line">        操作结果：销毁线性表L。</span><br><span class="line">        ClearList(&amp;L)</span><br><span class="line">        初始条件：线性表L已存在。</span><br><span class="line">        操作结果：将线性表L置为空表。</span><br><span class="line">        ListEmpty(L)</span><br><span class="line">        初始条件：线性表L已存在。</span><br><span class="line">        操作结果：若L为空表，则返回True，否则返回False。</span><br><span class="line">        ListLength(L)</span><br><span class="line">        初始条件：线性表L已存在。</span><br><span class="line">        操作结果：返回线性表元素个数。</span><br><span class="line">        GetElem(L, i, &amp;e)</span><br><span class="line">        初始条件：线性表L已存在，<span class="number">1</span>&lt;= i &lt;=ListLength(L)。</span><br><span class="line">        操作结果：用e返回L中第i个元素。</span><br><span class="line">        LocateElem(L, e, compare())</span><br><span class="line">        初始条件：线性表L已存在，compare()是数据元素的判别函数。</span><br><span class="line">        操作结果：返回L中第一个与e满足compare()关系的数据元素的位序，若不存在，返回<span class="number">0</span>。</span><br><span class="line">        PriorElem(L, curr_e, &amp;pre_e)</span><br><span class="line">        初始条件：线性表L已存在。</span><br><span class="line">        操作结果：若curr_e是L的元素且不是第一个，则用pre_e返回其的前驱，否则操作失败，pre_e无定义。</span><br><span class="line">        NextElem(L, curr_e, &amp;next_e)</span><br><span class="line">        初始条件：线性表L已存在。</span><br><span class="line">        操作结果：若curr_e是L的元素且不是最后一个，则用next_e返回其的后继，则操作失败，next_e无定义。</span><br><span class="line">        ListInsert(&amp;L, i, e)</span><br><span class="line">        初始条件：线性表L已存在，<span class="number">1</span>&lt;= i &lt;=ListLength(L)+<span class="number">1</span>。</span><br><span class="line">        操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加<span class="number">1</span>。</span><br><span class="line">        ListDelete(&amp;L, i, &amp;e)</span><br><span class="line">        初始条件：线性表L已存在且非空，<span class="number">1</span>&lt;= i &lt;=ListLength(L)。</span><br><span class="line">        操作结果：删除L的第i个元素，用e返回其，L的长度减<span class="number">1</span>。</span><br><span class="line">        ListTraverse(L, visit())</span><br><span class="line">        初始条件：线性表L已存在。</span><br><span class="line">        操作结果：依次对L的每个元素进行visit()操作,一旦visit()失败，则操作失败。        </span><br><span class="line">&#125;ADT List</span><br></pre></td></tr></table></figure><p></p><blockquote><p>eg1.若两个线性表LA、LB分别表示两个结合A、B，则求线性表LC表示集合C=A∪B。</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(List &amp;La, List Lb)</span></span>&#123;</span><br><span class="line">    <span class="comment">//将所有在Lb中但不在La中的数据元素插入到La中</span></span><br><span class="line">    La_len = ListLength(La);</span><br><span class="line">    Lb_len = ListLength(Lb);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt;= Lb_len; i++)&#123;</span><br><span class="line">        GetElem(Lb, i, e);</span><br><span class="line">        <span class="keyword">if</span>(LocateElem(La, e, equal))&#123;</span><br><span class="line">            ListInsert(La, ++La_len, e);        <span class="comment">//++在前表示先自增再赋值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//union</span></span><br></pre></td></tr></table></figure><blockquote><p>eg2.若LA、LB中的数据元素的按值非递减有序排列，则将LA、LB归并后的线性表LC依然保持值非递减有序排列。</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeList</span><span class="params">(List La, List Lb, List &amp;Lc)</span></span>&#123;</span><br><span class="line">    <span class="comment">//已知线性表La和Lb中的数据元素按值非递减有序排列</span></span><br><span class="line">    <span class="comment">//将La和Lb归并后的线性表Lc中的元素也是按值非递减有序排列</span></span><br><span class="line">    InitList(Lc);</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>, j=<span class="number">1</span>, k=<span class="number">0</span>;</span><br><span class="line">    La_len = ListLength(La);</span><br><span class="line">    Lb_len = ListLength(Lb);</span><br><span class="line">    <span class="keyword">while</span>((i &lt;= La_len) &amp;&amp; (j &lt;= Lb_len))&#123;</span><br><span class="line">        GetElem(La, i, ai);</span><br><span class="line">        GetElem(Lb, j, bj);</span><br><span class="line">        <span class="keyword">if</span>(ai &lt;= bj)&#123;</span><br><span class="line">            ListInsert(Lc, ++k, ai); i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ListInsert(Lc, ++k, bj); j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= La_len)&#123;</span><br><span class="line">        GetElem(La, i++, ai);</span><br><span class="line">        ListInsert(Lc, ++k, ai);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= Lb_len)&#123;</span><br><span class="line">        GetElem(Lb, j++, bj);</span><br><span class="line">        ListInsert(Lc, ++k, bj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//MergeList</span></span><br></pre></td></tr></table></figure><hr><h1 id="1-2-线性表的顺序表示和实现"><a href="#1-2-线性表的顺序表示和实现" class="headerlink" title="1.2 线性表的顺序表示和实现"></a>1.2 线性表的顺序表示和实现</h1><p><strong>顺序表</strong>（顺序表示的线性表）：用一组<strong>地址连续</strong>的存储单元存储线性表的数据元素。</p><p><strong>基地址</strong>（起始地址）：线性表的第一个数据元素的存储地址。</p><blockquote><p>第$i$个元素的地址：$Loc(a_i) = Loc(a_1) + (i-1)<em>l$。<br>$Loc(a_1)$是基地址，$l$是单个数据元素所占的存储单元。<br>因此，线性表的<strong>顺序存储结构</strong>是一种<em>*随机存取</em></em>的存储结构。</p><p>// 由于高级程序语言中的数组类型具有随机存取的特性，因此通常以数组来描述顺序存储结构。</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//-----------线性表动态分配的顺序存储结构-----------</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_INIT_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTINCREMENT 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType *elem;     <span class="comment">//存储空间的基址</span></span><br><span class="line">    <span class="keyword">int</span> length;         <span class="comment">//当前的长度</span></span><br><span class="line">    <span class="keyword">int</span> listsize;       <span class="comment">//当前分配的存储容量（以sizeof(ElemType)为单位）</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="function">Status <span class="title">InitList_Sq</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">        <span class="comment">//构造一个空的线性表L</span></span><br><span class="line">        L.elem = (ElemType*)<span class="built_in">malloc</span>(LIST_INIT_SIZE * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">        <span class="keyword">if</span>(!L.elem) <span class="built_in">exit</span>(overflow);         <span class="comment">//存储失败</span></span><br><span class="line">        L.length = <span class="number">0</span>;                       <span class="comment">//空表长度为0</span></span><br><span class="line">        L.listsize = LIST_INIT_SIZE;        <span class="comment">//初始存储容量</span></span><br><span class="line">    &#125;<span class="comment">//InitList_Sq</span></span><br><span class="line">    <span class="function">Status <span class="title">ListInsert_Sq</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i, ElemType e)</span></span>&#123;</span><br><span class="line">        <span class="comment">//在顺序表L的第i个位置插入新的数据元素</span></span><br><span class="line">        <span class="comment">//i的合法值为 1&lt;= i &lt;=L.length +1</span></span><br><span class="line">        <span class="keyword">if</span>((i&lt;<span class="number">1</span>)||(i&gt;L.length+<span class="number">1</span>))   <span class="keyword">return</span> ERROR;</span><br><span class="line">        <span class="keyword">if</span>(L.length &gt;= L.listsize)&#123;</span><br><span class="line">            newbase = (ElemType*)<span class="built_in">malloc</span>((L.listsize + LISTINCREMENT)*<span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">            <span class="keyword">if</span>(!newbase) <span class="built_in">exit</span>(overflow);</span><br><span class="line">            L.elem = newbase;</span><br><span class="line">            L.listsize += LISTINCREMENT;</span><br><span class="line">        &#125;</span><br><span class="line">        q = &amp;(L.elem[i<span class="number">-1</span>]);                 <span class="comment">//指针q、p</span></span><br><span class="line">        <span class="keyword">for</span>(p=&amp;(L.elem[L.length<span class="number">-1</span>]); p&gt;=q; p--)&#123;</span><br><span class="line">            *(p+<span class="number">1</span>) = *p;</span><br><span class="line">        &#125;</span><br><span class="line">        *q = e;</span><br><span class="line">        ++L.length;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;<span class="comment">//ListInsert_Sq</span></span><br><span class="line">    <span class="function">Status <span class="title">ListDelete_sq</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i, ElemType &amp;e)</span></span>&#123;</span><br><span class="line">        <span class="comment">//在顺序表L中删除第i位置的数据元素</span></span><br><span class="line">        <span class="comment">//i的合法值为1&lt;= i &lt;=L.length</span></span><br><span class="line">        <span class="keyword">if</span>((i&lt;<span class="number">1</span>)||(i&gt;L.length)) <span class="keyword">return</span> ERROR;</span><br><span class="line">        p = &amp;(L.elem[i<span class="number">-1</span>]);</span><br><span class="line">        e = *p;</span><br><span class="line">        q = &amp;(L.elem[L.length<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(p++; p&lt;=q; p++)&#123;</span><br><span class="line">            *(p<span class="number">-1</span>) = *p;</span><br><span class="line">        &#125;</span><br><span class="line">        L.length--;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;<span class="comment">//ListDelete_sq</span></span><br><span class="line">``` </span><br><span class="line">&gt; - 顺序表在某位置上的删除和插入操作时间主要消耗在移动元素上。</span><br><span class="line">&gt; - 假设$P_i$是顺序表L在第i个元素之前插入一个元素的概率，则在长度为n的线性链表L中插入一个元素需要移动的次数期望为$∑_1^&#123;n+<span class="number">1</span>&#125; [Pi*(n-i+<span class="number">1</span>)]$。</span><br><span class="line">&gt; - 假设$Q_i$是顺序表L删除第i个元素的概率，则在长度为n的L中删除一个元素需要移动的次数期望为$∑_1^&#123;n&#125;[Qi*(n-i)]$。</span><br><span class="line">&gt; - 不失一般性，若$Pi、Qi$是等概率的，则插入和删除分别平均移$\frac&#123;n&#125;&#123;<span class="number">2</span>&#125;、 \frac&#123;n<span class="number">-1</span>&#125;&#123;<span class="number">2</span>&#125;$。则ListInsert_Sq和ListDelete_sq的时间复杂度为$O(n)$。</span><br><span class="line">    </span><br><span class="line">&gt; <span class="comment">// 函数指针：指向函数的指针；</span></span><br><span class="line">    <span class="comment">// 指针函数：返回值是一个指针的函数；</span></span><br><span class="line">```cpp</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem_Sq</span><span class="params">(SqList L, ElemType e, Status (*compare)(ElemType,ElemType))</span></span>&#123;</span><br><span class="line">    <span class="comment">//在顺序表L中查找与e满足compare()的元素的位序</span></span><br><span class="line">    <span class="comment">//若找到，则返回对应位序，否则返回0</span></span><br><span class="line">    i = <span class="number">1</span>;</span><br><span class="line">    p = L.elem;</span><br><span class="line">    <span class="keyword">while</span>((i&lt;=L.length)&amp;&amp;!(compare(*p++,e)))    i++;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;=L.length) <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">else</span>    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//LocateElem_Sq</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeList_Sq</span><span class="params">(SqList La, SqList Lb, SqList &amp;Lc)</span></span>&#123;</span><br><span class="line">    <span class="comment">//已知顺序表La、Lb的数据元素按值非递减有序排列</span></span><br><span class="line">    <span class="comment">//归并后的顺序表Lc的数据元素也按值非递减有序排列</span></span><br><span class="line">    pa = La.elem;</span><br><span class="line">    pb = Lb.elem;</span><br><span class="line">    Lc.listsize = Lc.length = La.length + Lb.length;</span><br><span class="line">    pc = Lc.elem = (ElemType*)<span class="built_in">malloc</span>(Lc.listsize * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">    <span class="keyword">if</span>(!Lc.elem)    <span class="built_in">exit</span>(overflow);</span><br><span class="line">    pa_last = La.elem + La.length - <span class="number">1</span>;</span><br><span class="line">    pb_last = Lb.elem + Lb.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>((pa&lt;=pa_last)&amp;&amp;(pb&lt;=pb_last))&#123;</span><br><span class="line">        <span class="keyword">if</span>(*pa &lt;= *pb)  *pc++ = *pa++;</span><br><span class="line">        <span class="keyword">else</span>    *pc++ = *pb++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(pa&lt;=pa_last)  *pc++ = *pa++;</span><br><span class="line">    <span class="keyword">while</span>(pb&lt;=pb_last)  *pc++ = *pb++;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">//MergeList_Sq</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>若将第一个while循环中的条件语句改为“switch…case…”语句，并当<code>*pa=*pb</code>的时候改为<code>*pc++ = *pa++;*pb++;</code>由于集合A、B而言是值单增的，则该算法完成的操作和union()相同，但很明显时间复杂度不同。</li><li>时间复杂度不同的原因：<blockquote><ul><li>① 由于La、Lb的值以单增有序排列，则对La中的每一个元素无需从La由表头到表尾进行全程搜索。</li><li>② 用Lc表示合并之后的“并集”，union()中的插入操作是通过“复制”实现的。</li></ul></blockquote></li><li>因此，由快速排序算法的时间复杂度是$O(nlog(n))$，则可知在进行集合合并相关的操作时，先要对集合对应的顺序表进行排序。</li></ul></blockquote><hr><h1 id="1-3-线性表的链式表示和实现"><a href="#1-3-线性表的链式表示和实现" class="headerlink" title="1.3 线性表的链式表示和实现"></a>1.3 线性表的链式表示和实现</h1><blockquote><p>线性表的<strong>链式存储结构</strong>的特点是用一组<strong>任意</strong>的存储单元存储线性表中的数据元素。（这些存储单元可以是连续的，也可以是不连续的）</p></blockquote><p><strong>结点</strong>：数据元素的存储映像（由数据域+指针域组成）。</p><p><strong>数据域</strong>：用于存储数据元素信息的域。</p><p><strong>指针域</strong>：（对单链表而言）存储一个指示其直接后继的信息（即直接后继的地址）。</p><p><strong>指针（链）</strong>：指针域中存储的信息。</p><h2 id="1-3-1-线性链表（单链表）"><a href="#1-3-1-线性链表（单链表）" class="headerlink" title="1.3.1 线性链表（单链表）"></a>1.3.1 线性链表（单链表）</h2><blockquote><p>特点：链表的每个结点中只包含一个指针域。</p></blockquote><p><strong>头指针</strong>：指向链表中第一个结点（即第一个数据元素的映像）。</p><blockquote><ul><li>线性链表的存取必须从头指针开始进行，因此单链表是<strong>非随机存取</strong>的存储结构。由于线性链表的最后一个结点没有直接后继，因此最后一个结点的指针为NULL。</li><li>用线性链表表示线性表时，数据元素之间的逻辑关系是由结点中的指针指示的，因此，<strong>指针</strong>为数据元素之间的<strong>逻辑关系的映像</strong>。</li></ul><p>// 由于单链表可由头指针唯一确定，在C中用结构指针描述<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct LS&#123;</span><br><span class="line">    char name[20];</span><br><span class="line">    int num;</span><br><span class="line">&#125;L1,*p;</span><br><span class="line">&#x2F;&#x2F;L1是LS的别名，p&#x3D;&amp;L1,p是struct LS*类型,p指向L1的首地址，即p和(*p).name表示同一个内存空间，</span><br><span class="line">&#x2F;&#x2F;(*p).name的类型是char*。L1.name,(*p).name,p-&gt;name等价。</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line"></span><br><span class="line">### (1) 线性链表动态存储结构表示</span><br><span class="line">![单链表](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20200908212951823.png#pic_center)</span><br><span class="line">&lt;center&gt;图 1.3.1-1&lt;center&gt;</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;cpp</span><br><span class="line">&#x2F;&#x2F;-----------单链表的动态存储结构-------------</span><br><span class="line">typedef struct LNode&#123;</span><br><span class="line">    ElemType    data;   </span><br><span class="line">    struct LNode *next;</span><br><span class="line">&#125;LNode,*LinkList;</span><br></pre></td></tr></table></figure><br>对于没有头结点的单链表，L是LinkList类型的变量，则L为该单链表的头指针。<code>L=NULL</code>表示空表。<br>对于有头结点的单链表，L是LinkList类型的变量，<code>L-&gt;next=NULL</code>表示空表。<p></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetElem_L</span><span class="params">(LinkList L, <span class="keyword">int</span> i, ElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//L是带头结点的单链表的头指针</span></span><br><span class="line">    <span class="comment">//当第i个元素存在时，用e返回其值且返回OK，否则返回ERROR</span></span><br><span class="line">    p = L-&gt;next;</span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>((j&lt;i)&amp;&amp;p)&#123; p = p-&gt;next;  j++;&#125;</span><br><span class="line">    <span class="keyword">if</span>(!p||j&gt;i) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">//GetElem_L</span></span><br></pre></td></tr></table></figure><blockquote><p>该算法的时间复杂度为$O(n)$。<br></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert_L</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//在带头结点的单链表的第i个位置之前插入元素e</span></span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p&amp;&amp;(j&lt;i<span class="number">-1</span>))&#123; p = p-&gt;next; j++;&#125;           <span class="comment">//寻找指向第i-1位置的指针</span></span><br><span class="line"><span class="comment">//  if(!p||(j&gt;i-1)) return ERROR;</span></span><br><span class="line">    s = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(!s) <span class="built_in">exit</span>(overflow);</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">//ListInsert_L</span></span><br></pre></td></tr></table></figure><br>该算法的时间复杂度为$O(n)$。<p></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListDelete_L</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, ElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//删除带头结点的单链表的第i个位置元素，并用e返回其值</span></span><br><span class="line">    p = L;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((p-&gt;next)&amp;&amp;(j&lt;i<span class="number">-1</span>))&#123;p = p-&gt;next; j++;&#125;    <span class="comment">//寻找指向第i-1位置的指针</span></span><br><span class="line"><span class="comment">//  if(!(p-&gt;next)||(j&gt;i-1)) return ERROR;</span></span><br><span class="line">    q = p-&gt;next;</span><br><span class="line">    e = q-&gt;data;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">//ListDelete_L</span></span><br></pre></td></tr></table></figure><blockquote><p>该算法的时间复杂度为$O(n)$。</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateList_L</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//逆位序输入n个元素的值，建立带有头结点的单链表L</span></span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n; i&gt;=<span class="number">1</span>; i--)&#123;</span><br><span class="line">        p = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line"><span class="comment">//      if(!p)&#123;ClearList_L(L);  exit(overflow);&#125;</span></span><br><span class="line">        <span class="built_in">scanf</span>(&amp;p-&gt;data);</span><br><span class="line">        p-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//CreateList_L</span></span><br></pre></td></tr></table></figure><blockquote><p>显然易见，按逆位序建立的时间复杂度为$O(n)$，而按顺位序建立的时间复杂度为$O(n^2)$。<br></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeList_L</span><span class="params">(LinkList &amp;La, LinkList &amp;Lb, LinkList &amp;Lc)</span></span>&#123;</span><br><span class="line">    <span class="comment">//已知单链表La,Lb是按值不减有序排列</span></span><br><span class="line">    <span class="comment">//归并La和Lb得单链表Lc，Lc也是按值不减有序排列</span></span><br><span class="line">    pa = La-&gt;next;</span><br><span class="line">    pb = Lb-&gt;next;</span><br><span class="line">    Lc = pc = La;</span><br><span class="line">    <span class="keyword">while</span>(pa&amp;&amp;pb)&#123;</span><br><span class="line">        <span class="keyword">if</span>((pa-&gt;data)&lt;=(pb-&gt;data)))&#123;</span><br><span class="line">            pc-&gt;next = pa; </span><br><span class="line">            pc = pa; </span><br><span class="line">            pa = pa-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123; </span><br><span class="line">            pc-&gt;next = pb; </span><br><span class="line">            pc = pb; </span><br><span class="line">            pb = pb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pc-&gt;next = pa?pa:pb;</span><br><span class="line">    <span class="built_in">free</span>(pb);</span><br><span class="line">&#125;MergeList_L</span><br></pre></td></tr></table></figure><br>该算法的时间复杂度为$O(ListLength_L(La)+ListLength_L(Lb))$。<br>该算法与之前MergeList_Sq()的空间复杂度不同，因为该算法在归并两个链表时，不需建立新表的存储关系，只需将原来两个链表中结点之间的关系解除然后在重新按值非递减将所有结点链接成一个链表即可。<p></p></blockquote><h3 id="2-线性链表静态存储结构表示"><a href="#2-线性链表静态存储结构表示" class="headerlink" title="(2) 线性链表静态存储结构表示"></a>(2) 线性链表静态存储结构表示</h3><p><img src="https://img-blog.csdnimg.cn/20200908231321251.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JsdWVfZGF3bg==,size_16,color_FFFFFF,t_70#pic_center" alt="静态单链表1"><br><img src="https://img-blog.csdnimg.cn/20200908231212199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JsdWVfZGF3bg==,size_16,color_FFFFFF,t_70#pic_center" alt="静态单链表2"></p><p><center>图 1.3.1-2<center></center></center></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//---------------线性链表的静态单链表的存储结构--------------------------</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">int</span> cur;</span><br><span class="line">&#125;component,SLinkList[MAXSIZE];</span><br></pre></td></tr></table></figure><blockquote><ul><li>定义了一个匿名结构体，component是其的别名，SLinkList是component类型的数组。</li><li>数组的一个分量表示一个结点，游标（指示器cur）代替指针指示结点在数组中的相对位置。数组的第零个分量可以看成是头结点，其指针域指示链表的第一个结点。这种存储结构需要预先分配一个较大的存储空间，但作为线性表的插入和删除操作无需移动元素，仅需修改指针，故仍具有链式存储结构的主要优点。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetElem_SL</span><span class="params">(SLinkList L, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//在静态链表L中查找值为e的第1个元素</span></span><br><span class="line">    <span class="comment">//若找到，则返回对应位序，否则返回0</span></span><br><span class="line">    i = L[<span class="number">0</span>].cur;</span><br><span class="line">    <span class="keyword">while</span>(i&amp;&amp;(L[i].data!=e))&#123;</span><br><span class="line">        i = L[i].cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;<span class="comment">//GetElem_SL </span></span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList_SL</span><span class="params">(SLinkList &amp;space)</span></span>&#123;</span><br><span class="line">    <span class="comment">//将一维数组space的各分量链接成一个备用链表，头指针为space[0].cur</span></span><br><span class="line">    <span class="comment">//“0”代表空指针</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;MAXSIZE<span class="number">-1</span>; i++)&#123; space[i].cur = i+<span class="number">1</span>;&#125;</span><br><span class="line">    space[MAXSIZE<span class="number">-1</span>].cur = <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//InitList_SL</span></span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Malloc_SL</span><span class="params">(SLinkList &amp;space)</span></span>&#123;</span><br><span class="line">    <span class="comment">//若备用链表非空，则返回分配结点下标，否则返回0</span></span><br><span class="line">    i = space[<span class="number">0</span>].cur;</span><br><span class="line">    <span class="keyword">if</span>(space[<span class="number">0</span>].cur)    space[<span class="number">0</span>].cur = space[i].cur;</span><br><span class="line">    <span class="keyword">return</span>  i;</span><br><span class="line">&#125;<span class="comment">//Malloc_SL</span></span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Free_SL</span><span class="params">(SLinkList &amp;space, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="comment">//将下标为k的空闲结点回收到备用链表</span></span><br><span class="line">    space[k].cur = space[<span class="number">0</span>].cur;</span><br><span class="line">    space[<span class="number">0</span>].cur = k;</span><br><span class="line">&#125;<span class="comment">//Free_SL</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">difference</span><span class="params">(SLinkList &amp;space, <span class="keyword">int</span> &amp;S)</span></span>&#123;</span><br><span class="line">    <span class="comment">//依次输入A、B集合的元素，在一维数组space中建立集合(A-B)∪(B-A)的静态链表，S为其的头指针。</span></span><br><span class="line">    <span class="comment">//假设备用空间足够大，space[0].cur为其头指针。</span></span><br><span class="line">    InitList_SL(space);</span><br><span class="line">    S = Malloc_SL(space);</span><br><span class="line">    r = S;</span><br><span class="line">    <span class="built_in">scanf</span>(m,n);                 <span class="comment">//m,n分别是A和B的元素个数</span></span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=m; j++)&#123;</span><br><span class="line">        i = Malloc_SL(space);</span><br><span class="line">        <span class="built_in">scanf</span>(space[i].data);</span><br><span class="line">        space[r].cur = i;</span><br><span class="line">        r = i;                  <span class="comment">//r指向当前S的最后一个结点，即（合并前、后）属于A的最后一个结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    space[r].cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=n; j++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(b);</span><br><span class="line">        p = S;</span><br><span class="line">        k = space[S].cur;</span><br><span class="line">        <span class="keyword">while</span>((space[k].data!=b)&amp;&amp;(space[r].cur!=k))&#123;</span><br><span class="line">            p = k;</span><br><span class="line">            k = space[k].cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k == space[r].cur)&#123;</span><br><span class="line">            i = Malloc_SL(space);</span><br><span class="line">            space[i].data = b;</span><br><span class="line">            space[i].cur = space[r].cur;        </span><br><span class="line">            space[r].cur = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            space[p].cur = space[k].cur;</span><br><span class="line">            Free_SL(space, k);</span><br><span class="line">            <span class="keyword">if</span>(r == k)  r = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//difference</span></span><br><span class="line">```     </span><br><span class="line">&gt; 该算法的时间复杂度为$O(m*n)$。</span><br><span class="line"></span><br><span class="line">&gt;  eg. 线性表$La=(c,b,e,g,f,d)$表示结合A，线性表$Lb=(a,b,n,f)$表示B, difference()求$(A-B)\cup(B-A)$，其中space静态单链表如前图 <span class="number">1.3</span><span class="number">.1</span><span class="number">-2</span>所示。</span><br><span class="line"></span><br><span class="line">## <span class="number">1.3</span><span class="number">.2</span> 循环链表</span><br><span class="line">&gt; - 特点：表中的最后一个结点的指针域指向头结点，整个链表形成一个环。</span><br><span class="line">&gt; - 循环链表的操作和线性链表的操作基本一致，不同在于算法中的**循环条件**由p或p-&gt;next非空，而是是否等于头指针;</span><br><span class="line">&gt; - 但有时候，在循环链表设立尾指针而不设头指针，则可使某些操作简化。如在合并两个线性表时，只需将一个表的表尾和另一个表的表头的相连接即可，时间复杂度为$O(<span class="number">1</span>)$。</span><br><span class="line">    </span><br><span class="line">## <span class="number">1.3</span><span class="number">.3</span> 双向链表</span><br><span class="line">&gt; 特点：各结点中有两个指针域，一个指向直接后继，一个指向直接前驱。</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="comment">//-----------------线性表的双向链表存储结构--------------------</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> *<span class="title">prior</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;DuLNode,*DuLinkList;</span><br></pre></td></tr></table></figure><h3 id="1-双向循环链表"><a href="#1-双向循环链表" class="headerlink" title="(1) 双向循环链表"></a>(1) 双向循环链表</h3><blockquote><p>特点：<code>d-&gt;next-&gt;prior = d-&gt;prior-&gt;next = d</code></p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200908213528656.png#pic_center" alt="双向循环链表"></p><p><center>图 1.3.3-1<center></center></center></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert_DuL</span><span class="params">(DuLinkList &amp;L, <span class="keyword">int</span> i, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//在带头结点的双向循环链表L中第i个位置之前插入元素e</span></span><br><span class="line">    <span class="comment">//i的合法值为 1&lt;=i&lt;=表长+1</span></span><br><span class="line">    <span class="keyword">if</span>(!GetElem_DuL(L,i))   <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">if</span>(!(s = (DuLinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DuLNode))))  <span class="keyword">return</span> ERROR;</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    p-&gt;prior-&gt;next = s;</span><br><span class="line">    s-&gt;prior = p-&gt;prior;</span><br><span class="line">    s-&gt;next = p;</span><br><span class="line">    p-&gt;prior = s;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">//ListInsert_DuL</span></span><br></pre></td></tr></table></figure><blockquote><p>该算法的时间复杂度为$O(n)$;</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListDelete_DuL</span><span class="params">(DuLinkList &amp;L, <span class="keyword">int</span> i, ElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//删除带头结点的双向循环链表L中第i个位置的元素</span></span><br><span class="line">    <span class="comment">//i的合法值为1&lt;=i&lt;=表长，且用e返回该元素</span></span><br><span class="line">    <span class="keyword">if</span>(!GetElem_DuL(L,i))   <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    p-&gt;prior-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next-&gt;prior = p-&gt;prior;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">//ListDelete_DuL</span></span><br></pre></td></tr></table></figure><blockquote><p>该算法的时间复杂度为$O(n)$;</p></blockquote><h2 id="1-3-4-一般线性链表存储表示"><a href="#1-3-4-一般线性链表存储表示" class="headerlink" title="1.3.4 一般线性链表存储表示"></a>1.3.4 一般线性链表存储表示</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*Link,*Position;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Link head,tail;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">&#125;LinkList;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">MakeNode</span><span class="params">(Link &amp;p, ElemType e)</span></span>;</span><br><span class="line"><span class="comment">//分配由p指向值为e的结点，并返回OK；若分配失败，返回ERROR；</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FreeNode</span><span class="params">(Link &amp;p)</span></span>;</span><br><span class="line"><span class="comment">//释放p指向的结点</span></span><br><span class="line"><span class="function">Status <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span></span>;</span><br><span class="line"><span class="comment">//构造一个空的线性链表L</span></span><br><span class="line"><span class="function">Status <span class="title">DestroyList</span><span class="params">(LinkList &amp;L)</span></span>;</span><br><span class="line"><span class="comment">//销毁线性链表L</span></span><br><span class="line"><span class="function">Status <span class="title">ClearList</span><span class="params">(LinkList &amp;L)</span></span>;</span><br><span class="line"><span class="comment">//将线性链表L置位空表，并释放原来链表的结点空间</span></span><br><span class="line"><span class="function">Status <span class="title">InsFirst</span><span class="params">(Link h, Link s)</span></span>;</span><br><span class="line"><span class="comment">//已知h指向线性链表的头结点，将s指向的结点插入在第一个节点之前</span></span><br><span class="line"><span class="function">Status <span class="title">DelFirst</span><span class="params">(Link h, Link &amp;q)</span></span>;</span><br><span class="line"><span class="comment">//已知h指向线性链表的头结点，删除线性链表的第一个结点并返回q</span></span><br><span class="line"><span class="function">Status <span class="title">Append</span><span class="params">(LinkList &amp;L, Link s)</span></span>; </span><br><span class="line"><span class="comment">//将指针s所指的一串结点(彼此以指针相互链接)链接在线性链表的最后一个结点，并改变L的尾指针指向新链表的尾结点</span></span><br><span class="line"><span class="function">Status <span class="title">Remove</span><span class="params">(LinkList &amp;L, Link &amp;q)</span></span>;</span><br><span class="line"><span class="comment">//删除线性链表的尾结点，并以q返回，并改变L的尾指针指向新的尾结点</span></span><br><span class="line"><span class="function">Status <span class="title">InsBefore</span><span class="params">(LinkList &amp;L, Link &amp;p, Link s)</span></span>;</span><br><span class="line"><span class="comment">//已知p指向L中的一个结点，将s指向的结点插入在p所指的结点之前，并修改指针p指向新插入的结点</span></span><br><span class="line"><span class="function">Status <span class="title">InsAfter</span><span class="params">(LinkList &amp;L, Link &amp;p, Link s)</span></span>;</span><br><span class="line"><span class="comment">//已知p指向L中的一个结点，将s指向的结点插入在p所指的结点之后，并修改指针p指向新插入的结点</span></span><br><span class="line"><span class="function">Status <span class="title">SetCurElem</span><span class="params">(Link &amp;p, ElemType e)</span></span>;</span><br><span class="line"><span class="comment">//已知p指向线性链表的一个结点，用e更新p所指结点的数据元素的值</span></span><br><span class="line"><span class="function">ElemType <span class="title">GetCurElem</span><span class="params">(Link p)</span></span>;</span><br><span class="line"><span class="comment">//已知p指向线性链表的一个结点，返回p所指结点的数据元素的值</span></span><br><span class="line"><span class="function">Status <span class="title">ListEmpty</span><span class="params">(LinkList L)</span></span>;</span><br><span class="line"><span class="comment">//若线性链表为空表，则返回True，否则返回False。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength</span><span class="params">(LinkList L)</span></span>;</span><br><span class="line"><span class="comment">//返回线性链表的元素个数</span></span><br><span class="line"><span class="function">Position <span class="title">GetHead</span><span class="params">(LinkList L)</span></span>;</span><br><span class="line"><span class="comment">//返回线性链表头结点的位置</span></span><br><span class="line"><span class="function">Position <span class="title">GetLast</span><span class="params">(LinkList L)</span></span>;</span><br><span class="line"><span class="comment">//返回线性链表最后一个结点的位置</span></span><br><span class="line"><span class="function">Position <span class="title">PriorPos</span><span class="params">(LinkList L, Link &amp;p)</span></span>;</span><br><span class="line"><span class="comment">//已知p指向线性链表L中的一个结点，返回p所指结点的直接前驱的位置，若无前驱返回NULL</span></span><br><span class="line"><span class="function">Position <span class="title">NextPos</span><span class="params">(LinkList L, Link &amp;p)</span></span>;</span><br><span class="line"><span class="comment">//已知p指向线性链表L中的一个结点，返回p所指结点的直接后继的位置，若无后继返回NULL</span></span><br><span class="line"><span class="function">Status <span class="title">LocatePos</span><span class="params">(LinkList L, <span class="keyword">int</span> i, Link &amp;p)</span></span>;</span><br><span class="line"><span class="comment">//返回p指示线性链表L的第i个结点的位置并返回OK，i值不合法时返回ERROR</span></span><br><span class="line"><span class="function">Position <span class="title">LocateElem</span><span class="params">(LinkList L, ElemType e, Status (*compare)(ElemType,ElemType))</span></span>;</span><br><span class="line"><span class="comment">//返回线性链表第一个与e符合compare()判定关系的元素位置，若不存在则返回NULL</span></span><br><span class="line"><span class="function">Status <span class="title">ListTraverse</span><span class="params">(LinkList L, Status(*visit)())</span></span>;</span><br><span class="line"><span class="comment">//依次对L的每个元素进行visit，一旦visit失败则操作失败</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> i, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//在带头结点的单链表L中第i个位置之前插入元素e</span></span><br><span class="line">    <span class="keyword">if</span>(!LocatePos(L,i<span class="number">-1</span>,h)) <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">if</span>(!MakeNode(s,e))  <span class="keyword">return</span> ERROR;</span><br><span class="line">    InsFirst(h,s);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">//ListInsert</span></span><br><span class="line">        </span><br><span class="line"><span class="function">Status <span class="title">MergeList</span><span class="params">(LinkList &amp;La, LinkList &amp;Lb, LinkList &amp;Lc)</span></span>&#123;</span><br><span class="line">    <span class="comment">//已知单链表La,Lb是按值不减有序排列</span></span><br><span class="line">    <span class="comment">//归并La和Lb得单链表Lc，Lc也是按值不减有序排列</span></span><br><span class="line">    <span class="keyword">if</span>(!InitList(Lc))   <span class="keyword">return</span> ERROR;</span><br><span class="line">    ha = GetHead(La);</span><br><span class="line">    hb = GetHead(Lb);</span><br><span class="line">    pa = NextPos(La,ha);</span><br><span class="line">    pb = NextPos(Lb,hb);</span><br><span class="line">    <span class="keyword">while</span>(pa&amp;&amp;pb)&#123;</span><br><span class="line">        a = GetCurElem(pa);</span><br><span class="line">        b = GetCurElem(pb);</span><br><span class="line">        <span class="keyword">if</span>((*compare)(a,b)&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            DelFirst(ha,q);</span><br><span class="line">            Append(Lc,q);</span><br><span class="line">            pb = NextPos(Lb,hb);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            DelFirst(hb,q);</span><br><span class="line">            Append(Lc,q);</span><br><span class="line">            pa = NextPos(La,ha);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pa)  Append(Lc,pa);</span><br><span class="line">    <span class="keyword">else</span>    Append(Lc,pb);</span><br><span class="line">    FreeNode(ha);</span><br><span class="line">    FreeNode(hb);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">//MergeList</span></span><br></pre></td></tr></table></figure><hr><h1 id="1-4-一元多项式的表示及相加"><a href="#1-4-一元多项式的表示及相加" class="headerlink" title="1.4 一元多项式的表示及相加"></a>1.4 一元多项式的表示及相加</h1><p><code>顺序存储表示</code> <code>链式存储表示</code></p><blockquote><p>有序链表和线性链表的基本操作有两处不同：<br>① 是LocateElem()职能不同；② 是需增加按有序关系进行插入的操作<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Status LocateElem(LinkList L, ElemType e, Position &amp;q, int (*compare)(ElemType,ElemType));</span><br><span class="line">&#x2F;&#x2F;若有序链表L中存在与e符合compare()值为0的元素，则q指向L中第一个值为e的结点，并返回True</span><br><span class="line">&#x2F;&#x2F;否则，q指示第一个与e满足compare()取值&gt;0的元素的前驱，并返回False</span><br><span class="line">Status OrderInsert(LinkList &amp;L, ElemType e, int (*compare)(ElemType,ElemType));</span><br><span class="line">&#x2F;&#x2F;按有序判定函数compare将值为e的结点插入到L的适当位置</span><br></pre></td></tr></table></figure><p></p><h2 id="-1"><a href="#-1" class="headerlink"></a><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">float</span> coef;</span><br><span class="line">    <span class="keyword">int</span> expn;</span><br><span class="line">&#125;term, ElemType;</span><br><span class="line"><span class="keyword">typedef</span> LinkList polynomial;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//----------------基本操作的函数原型说明-------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatPolyn</span><span class="params">(polynomial &amp;P, <span class="keyword">int</span> m)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyPolyn</span><span class="params">(polynomial &amp;P)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPolyn</span><span class="params">(polynomial P)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PolynLength</span><span class="params">(polynomial P)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddPolyn</span><span class="params">(polynomial &amp;Pa, polynomial &amp;Pb)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SubtractPolyn</span><span class="params">(polynomial &amp;Pa, polynomial &amp;Pb)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MutiplyPolyn</span><span class="params">(polynomial &amp;Pa, polynomial &amp;Pb)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//--------------------算法描述-------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(term a, term b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  (a.expn&gt;b.expn)?<span class="number">1</span>:((a.expn &lt; b.expn)?<span class="number">-1</span>:<span class="number">0</span>);</span><br><span class="line">&#125;<span class="comment">//cmp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatPolyn</span><span class="params">(polynomial &amp;P, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    InitList(P);</span><br><span class="line">    h = GetHead(P);</span><br><span class="line">    e.coef = <span class="number">0</span>;</span><br><span class="line">    e.expn = <span class="number">-1</span>;</span><br><span class="line">    SetCurElem(h,e);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=m; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(e.coef,e.expn);</span><br><span class="line">        <span class="keyword">if</span>(!LocateElem(P,e,q,(*cmp)()))&#123;</span><br><span class="line">        <span class="keyword">if</span>(!MakeNode(s,e))  InsFirst(q,s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//CreatPolyn</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddPolyn</span><span class="params">(PolynLength &amp;Pa, polynomial &amp;Pb)</span></span>&#123;</span><br><span class="line">    ha = GetHead(Pa);</span><br><span class="line">    hb = GetHead(Pb);</span><br><span class="line">    qa = NextPos(ha);</span><br><span class="line">    qb = NextPos(hb);</span><br><span class="line">    <span class="keyword">while</span>(qa&amp;&amp;qb)&#123;</span><br><span class="line">        a = GetCurElem(qa);</span><br><span class="line">        b = GetCurElem(qb);</span><br><span class="line">        swith(*cmp(a,b))&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">-1</span>:    </span><br><span class="line">                ha = qa; qa = NextPos(Pa, qa);  <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                sum = a.coef + b.coef;</span><br><span class="line">                <span class="keyword">if</span>(sum != <span class="number">0.0</span>)&#123;</span><br><span class="line">                    SetCurElem(qa,sum);</span><br><span class="line">                    ha = qa;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    DelFirst(ha,qa);</span><br><span class="line">                    FreeNode(qa);</span><br><span class="line">                &#125;</span><br><span class="line">                DelFirst(hb,qb);</span><br><span class="line">                FreeNode(qb);</span><br><span class="line">                qb = NextPos(Pb,hb);</span><br><span class="line">                qa = NextPos(Pa,ha);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                DelFirst(hb,qb);</span><br><span class="line">                InsFirst(ha,qb);</span><br><span class="line">                qb = NextPos(Pb,hb);</span><br><span class="line">                ha = NextPos(Pa,ha);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!ListEmpty(Pb))  Append(Pa,qb);</span><br><span class="line">    FreeNode(hb);</span><br><span class="line">&#125;<span class="comment">//AddPolyn</span></span><br></pre></td></tr></table></figure></h2></blockquote>]]></content>
      <categories>
        <category>考研</category>
        <category>专业课</category>
        <category>数据结构</category>
        <category>计算机</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>List1</title>
    <url>/2020/09/05/List1/</url>
    <content><![CDATA[<p>…<br><a id="more"></a><br><img src="/2020/09/05/List1/1.jpg" alt="List 1"></p><hr>]]></content>
      <categories>
        <category>考研</category>
        <category>英语</category>
        <category>单词</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title>List15</title>
    <url>/2020/09/05/List15/</url>
    <content><![CDATA[<p>…<br><a id="more"></a><br><img src="/2020/09/05/List15/1.jpg" alt="List 15"></p>]]></content>
      <categories>
        <category>考研</category>
        <category>英语</category>
        <category>单词</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title>List16</title>
    <url>/2020/09/05/List16/</url>
    <content><![CDATA[<p>…<br><a id="more"></a><br><img src="/2020/09/05/List16/1.jpg" alt="List 16"></p>]]></content>
      <categories>
        <category>考研</category>
        <category>英语</category>
        <category>单词</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title>List17</title>
    <url>/2020/09/05/List17/</url>
    <content><![CDATA[<p>…<br><a id="more"></a><br><img src="/2020/09/05/List17/1.jpg" alt="List 17"></p>]]></content>
      <categories>
        <category>考研</category>
        <category>英语</category>
        <category>单词</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title>List18</title>
    <url>/2020/09/05/List18/</url>
    <content><![CDATA[<p>…<br><a id="more"></a><br><img src="/2020/09/05/List18/1.jpg" alt="List 18"></p>]]></content>
      <categories>
        <category>考研</category>
        <category>英语</category>
        <category>单词</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title>List19</title>
    <url>/2020/09/05/List19/</url>
    <content><![CDATA[<p>…<br><a id="more"></a><br><img src="/2020/09/05/List19/1.jpg" alt="List 19"></p>]]></content>
      <categories>
        <category>考研</category>
        <category>英语</category>
        <category>单词</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title>List 20</title>
    <url>/2020/08/31/List20/</url>
    <content><![CDATA[<p>…<br><a id="more"></a><br><img src="/2020/08/31/List20/1.jpg" alt="List 20"></p>]]></content>
      <categories>
        <category>考研</category>
        <category>英语</category>
        <category>单词</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构笔记_0</title>
    <url>/2020/08/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0_0/</url>
    <content><![CDATA[<p>Notes_0<br><a id="more"></a></p><p>数据结构是一门研究非数值计算的程序中计算机的操作对象以及它们之间的关系和操作的学科。</p><hr><h1 id="0-1-基本术语："><a href="#0-1-基本术语：" class="headerlink" title="0.1 基本术语："></a>0.1 基本术语：</h1><p><strong>数据</strong> ：在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号总称。</p><p><strong>数据元素</strong>：是数据的基本单位。有时一个数据元素可由若干个数据项组成。</p><p><strong>数据项</strong>：是数据的不可分割的最小的单位。</p><p><strong>数据对象</strong>：是性质相同的数据元素的集合。是数据的一个子集。</p><p><strong>数据结构</strong>：是相互之间存在一种或多种特定关系的数据元素的集合。</p><blockquote><p>形式定义：二元组（D,S），D是数据元素的有限集，S是在D上关系的有限集。</p></blockquote><p>常见的基本结构（<strong>逻辑结构</strong>）:</p><ul><li>集合</li><li>线性结构</li><li>树形结构</li><li>图状结构/网状结构</li></ul><p><strong>物理结构（存储结构）</strong>：数据结构在计算机中的映像。</p><p><strong>位（bit）</strong>：在计算机中表示信息的最小单位。</p><p><strong>元素（结点）</strong>：在计算机中用来表示数据元素的位串（若干个位组合而成）。</p><p><strong>数据域</strong>：若数据元素由若干个数据项组成，位串中对应于各数据项的子位串称数据域。</p><blockquote><p>元素（结点）可看作是数据元素在计算机中的映像。</p></blockquote><p><strong>顺序映像</strong>：通过元素在存储器中的相对位置来表示数据元素之间的逻辑关系的方法。</p><p><strong>非顺序映像</strong>：通过指示元素的存储地址的指针来表示数据元素之间的逻辑关系的方法。</p><p><strong>顺序存储结构</strong>：顺序映像的实现。<br><strong>链式存储结构</strong>：非顺序映像的实现。</p><p><strong>虚拟存储结构</strong>：用C语言的“一维数组”类型来描述顺序存储结构，用C语言的“指针”来描述链式存储结构。</p><p><strong>数据类型</strong>：是一个值的集合和定义在这个值集上的一组操作的总称。</p><blockquote><p>按照“值”的不同特性可将高级程序语言的数据类型分为：</p><ul><li><strong>原子类型</strong>（值不可分解）（如C中的整型、实型、字符型、枚举型；指针类型；空类型；）</li><li><strong>结构类型</strong>（值是由若干成分按照某种结构组成的）（如，数组）</li></ul><p>此外，数据类型的概念还存在在计算机硬件、软件中。引入“数据类型”，从硬件的角度来说，是作为解释计算机内存中信息含义的一种手段，而对于使用数据类型的用户来说，实现了信息的屏蔽。</p></blockquote><p><strong>抽象数据类型（ADT）</strong>：是指一个数学模型以及定义在该模型上的一组操作的总称。</p><blockquote><ul><li>ADT的定义只取决于它的一组逻辑特性，而与在计算机内部如何表示和实现无关。</li><li>DT可以看做是一种特殊的ADT。（如，整型在不同处理机上的实现可以不同，但由于其定义的数学特性相同，因此在用户看来是相同的。）</li><li><p>ADT可由三元组（D,S,P）表示，D是数据对象，S是D上的关系集，P是对D的基本操作集 。</p></li><li><p><strong>原子类型</strong> （属于原子类型的变量的值不可分解）</p></li><li><strong>固定聚合类型</strong> （该类型的变量的值是由确定数目的成分按某种结构组成）</li><li><strong>可变聚合类型</strong> （构成“值”的成分的数目不确定）</li></ul></blockquote><hr><h1 id="0-2-ADT的表示和实现"><a href="#0-2-ADT的表示和实现" class="headerlink" title="0.2 ADT的表示和实现"></a>0.2 ADT的表示和实现</h1><blockquote><p>// 严慧敏的数据结构中采用类C语言</p></blockquote><h2 id="1-预定义常量和类型"><a href="#1-预定义常量和类型" class="headerlink" title="(1) 预定义常量和类型"></a>(1) 预定义常量和类型</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数结果状态代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE    1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE   0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK      1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR   0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFEASIBLE  -1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW    -2</span></span><br><span class="line"><span class="comment">//Status是函数的类型，其值是函数结果状态代码</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status</span><br></pre></td></tr></table></figure><h2 id="2-存储结构及数据元素类型"><a href="#2-存储结构及数据元素类型" class="headerlink" title="(2) 存储结构及数据元素类型"></a>(2) 存储结构及数据元素类型</h2><p>数据结构的表示（存储结构）用<code>typedef</code>描述。<br>数据元素的类型约定为<code>ElemType</code>。</p><h2 id="3-ADT格式"><a href="#3-ADT格式" class="headerlink" title="(3) ADT格式"></a>(3) ADT格式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ADT抽象数据类型名&#123;</span><br><span class="line">    数据对象：&lt;数据对象的定义&gt;</span><br><span class="line">    数据关系：&lt;数据关系的定义&gt;  </span><br><span class="line">    基本操作：&lt;基本操作的定义&gt;</span><br><span class="line">    &#x2F;&#x2F;基本操作有两种参数：赋值参数、引用参数(&amp;)。</span><br><span class="line">        基本操作名(参数表)</span><br><span class="line">            初始条件：&lt;初始条件描述&gt;</span><br><span class="line">            操作结果：&lt;操作结果描述&gt;</span><br><span class="line">&#125;ADT抽象数据类型名</span><br></pre></td></tr></table></figure><h2 id="4-抽象数据类型Triplet的表示和实现"><a href="#4-抽象数据类型Triplet的表示和实现" class="headerlink" title="(4) 抽象数据类型Triplet的表示和实现"></a>(4) 抽象数据类型Triplet的表示和实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//--------采用动态分配的顺序存储结构---------        </span></span><br><span class="line"><span class="keyword">typedef</span> ElemType *Triplet;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//--------基本操作的函数原型说明------------</span></span><br><span class="line"><span class="function">Status <span class="title">InitTriplet</span><span class="params">(Triplet &amp;T, ElemType t1, ElemType t2, ElemType t3)</span></span>;</span><br><span class="line"><span class="comment">//操作结果：构造三元组T，参数t1,t2,t3进行赋值。</span></span><br><span class="line"><span class="function">Status <span class="title">DestoryTriplet</span><span class="params">(Triplet &amp;T)</span></span>;</span><br><span class="line"><span class="comment">//操作结果：三元组被销毁。</span></span><br><span class="line"><span class="function">Status <span class="title">Get</span><span class="params">(Triplet T, <span class="keyword">int</span> i, ElemType &amp;e)</span></span>;</span><br><span class="line"><span class="comment">//初始条件：三元组T已存在，且1 &lt;= i &lt;= 3。</span></span><br><span class="line"><span class="comment">//操作结果：用e返回T的第i元的值。</span></span><br><span class="line"><span class="function">Status <span class="title">Put</span><span class="params">(Triplet &amp;T, <span class="keyword">int</span> i, ElemType e)</span></span>;</span><br><span class="line"><span class="comment">//初始条件：三元组T已存在，且1 &lt;= i &lt;= 3。</span></span><br><span class="line"><span class="comment">//操作结果：改变T的第i元的值为e。</span></span><br><span class="line"><span class="function">Status <span class="title">IsAscending</span><span class="params">(Triplet T)</span></span>;</span><br><span class="line"><span class="comment">//初始条件：三元组T已存在。</span></span><br><span class="line"><span class="comment">//操作结果：如果T的三个元素按升序排列，则返回1，否则返回0。</span></span><br><span class="line"><span class="function">Status <span class="title">IsDescending</span><span class="params">(Triplet T)</span></span>;</span><br><span class="line"><span class="comment">//初始条件：三元组T已存在。</span></span><br><span class="line"><span class="comment">//操作结果：如果T的三个元素按降序排列，则返回1，否则返回0。</span></span><br><span class="line"><span class="function">Status <span class="title">Max</span><span class="params">(Triplet T, ElemType &amp;e)</span></span>;</span><br><span class="line"><span class="comment">//初始条件：三元组T已存在。</span></span><br><span class="line"><span class="comment">//操作结果：用e返回T中三个元素的最大值。</span></span><br><span class="line"><span class="function">Status <span class="title">Min</span><span class="params">(Triplet T, ElemType &amp;e)</span></span>;</span><br><span class="line"><span class="comment">//初始条件：三元组T已存在。</span></span><br><span class="line"><span class="comment">//操作结果：用e返回T中三个元素的最小值。</span></span><br></pre></td></tr></table></figure><blockquote><ul><li><strong>malloc()</strong> 是动态内存分配，用于申请一块连续的指定大小的内存区域以<code>void*</code>类型返回分配的内存区域地址。若无法获得符合要求的内存块，则返回<code>NULL指针</code>。</li><li><strong>free()</strong> 释放内存块。</li><li><strong>overflow</strong>：一般用于exit参数中，如创建指针时，若内存分配不成功则调用<code>return exit(overflow);</code></li><li><strong>infeasible</strong>：如求后继元素时，若是最后一个元素，则求后继不可行，调用<code>return infeasible;</code></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//-----------基本操作实现-------------</span></span><br><span class="line"><span class="function">Status <span class="title">InitTriplet</span><span class="params">(Triplet &amp;T, ElemType t1, ElemType t2, ElemType t3)</span></span>&#123;</span><br><span class="line">    <span class="comment">//构造三元组T，参数t1,t2,t3进行赋值。</span></span><br><span class="line">    T = (ElemType *)<span class="built_in">malloc</span>(<span class="number">3</span> * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">    <span class="keyword">if</span>(!T) <span class="built_in">exit</span>(OVERFLOW);      <span class="comment">//分配存储空间失败</span></span><br><span class="line">    T[<span class="number">0</span>] = t1;</span><br><span class="line">    T[<span class="number">1</span>] = t2;</span><br><span class="line">    T[<span class="number">2</span>] = t3;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">//InitTriplet</span></span><br><span class="line">        </span><br><span class="line"><span class="function">Status <span class="title">DestoryTriplet</span><span class="params">(Triplet &amp;T)</span></span>&#123;</span><br><span class="line">    <span class="comment">//销毁三元组T。</span></span><br><span class="line">    <span class="built_in">free</span>(T);</span><br><span class="line">    T = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">//DestoryTriplet</span></span><br><span class="line">        </span><br><span class="line"><span class="function">Status <span class="title">Get</span><span class="params">(Triplet T, <span class="keyword">int</span> i, ElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//用e返回T的第i元的值。</span></span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;<span class="number">3</span>)  <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = T[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">//Get</span></span><br><span class="line">        </span><br><span class="line"><span class="function">Status <span class="title">Put</span><span class="params">(Triplet &amp;T, <span class="keyword">int</span> i, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//改变T的第i元的值为e。</span></span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;<span class="number">3</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    T[i<span class="number">-1</span>] = e;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">//Put</span></span><br><span class="line">        </span><br><span class="line"><span class="function">Status <span class="title">IsAscending</span><span class="params">(Triplet T)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果T的三个元素按升序排列，则返回1，否则返回0。</span></span><br><span class="line">    <span class="keyword">return</span> (T[<span class="number">0</span>] &lt;= T[<span class="number">1</span>]) &amp;&amp; (T[<span class="number">1</span>] &lt;= T[<span class="number">2</span>])</span><br><span class="line">&#125;<span class="comment">//IsAscending</span></span><br><span class="line">        </span><br><span class="line">Status IsDescending(Triplet T)&#123;</span><br><span class="line">    <span class="comment">//如果T的三个元素按降序排列，则返回1，否则返回0。</span></span><br><span class="line">    <span class="keyword">return</span> (T[<span class="number">0</span>] &gt;= T[<span class="number">1</span>]) &amp;&amp; (T[<span class="number">1</span>] &gt;= T[<span class="number">2</span>])</span><br><span class="line">&#125;<span class="comment">//IsDescending</span></span><br><span class="line">        </span><br><span class="line">Status Max(Triplet T, ElemType &amp;e)&#123;</span><br><span class="line">    <span class="comment">//用e返回T中三个元素的最大值。</span></span><br><span class="line">    <span class="keyword">if</span>(T[<span class="number">0</span>] &gt;= T[<span class="number">1</span>])&#123;</span><br><span class="line">        e = T[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        e = T[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(e &lt; T[<span class="number">2</span>])&#123;</span><br><span class="line">        e = T[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">//Max</span></span><br><span class="line">        </span><br><span class="line"><span class="function">Status <span class="title">Min</span><span class="params">(Triplet T, ElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//用e返回T中三个元素的最小值。</span></span><br><span class="line">    e = (T[<span class="number">0</span>]&lt;=T[<span class="number">1</span>])?((T[<span class="number">2</span>]&lt;=T[<span class="number">0</span>])?T[<span class="number">2</span>]:T[<span class="number">0</span>]):(T[<span class="number">2</span>]&lt;=T[<span class="number">1</span>])?T[<span class="number">2</span>]:T[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">//Min</span></span><br></pre></td></tr></table></figure><hr><h1 id="0-3-算法分析"><a href="#0-3-算法分析" class="headerlink" title="0.3 算法分析"></a>0.3 算法分析</h1><p>算法的特性：<br><code>有穷性</code> <code>确定性</code> <code>可行性</code> <code>输入</code> <code>输出</code></p><p>算法设计要求：<br><code>正确性</code> <code>可读性</code> <code>健壮性</code> <code>效率与低存储量需求</code></p><p>算法效率的度量：</p><ul><li><p><strong>时间复杂度</strong>：以问题的基本操作重复执行的次数作为时间度量；<script type="math/tex">T(n)=O(f(n))</script>;</p></li><li><p><strong>空间复杂度</strong>：<script type="math/tex">S(n)=O(f(n))</script>;</p><blockquote><ul><li>若输入数据所占空间只取决于问题本身，和算法无关，则只需分析除输入和程序之外的额外空间；否则，应同时考虑输入本身所占空间。</li><li>若额外空间相对于输入数据量来说是常数，则称此算法在<strong>原地工作</strong>，若所占空间量依赖与特定的输入，则一般考虑最坏的情况。</li></ul></blockquote></li></ul><hr><p>​<br>​</p>]]></content>
      <categories>
        <category>考研</category>
        <category>专业课</category>
        <category>数据结构</category>
        <category>计算机</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>英语泛读_day_2</title>
    <url>/2020/06/27/%E8%8B%B1%E8%AF%AD%E6%B3%9B%E8%AF%BB_day_2/</url>
    <content><![CDATA[<p><center>Banking Is for the 1%</center><br><a id="more"></a><br>&emsp;&emsp;The rich are different, as F.Scott Fitzgerald famously wrote and so are their banking services. While most of us struggle to keep our balances high enough to avoid a slew of extra fees for everything from writing checks to making ATM withdrawals, wealthy individuals enjoy the special extras provided by banks, which increasingly seen more like high-end concierges than financial institutions. If you are rich, your bank will happily arrange everything from Broadway tickets to spa trip.</p><p>&emsp;&emsp;Oh, and you’ll have an easier time getting a loan too. A recent report by the Goldman Sachs Global Markets Institute,the public-policy unit of the financial giant,found that while the rich have ample access to credit and banking services six years on from the financial crisis, low-and mediunm-income consumers do not. Instead,they pay more for everything from mortgages to credit cards,and generally,the majority of consumers have worse access to credit than they did before the crisis. As the Goldman report puts it,”For a near-mimimun-wage worker who has maintained some access to bank credit (and it is important to note that many have not in the wake of the financial crisis),the added annual interest expences associated with a typical level of debt would be roughly equivalent to one week’s wages.” Small and midsize business,meanwhile,have seen interest rates on their loans go up 1.75% relative to those for larger companies. This is a major problem because it damps economic growth and slows creation.</p><p>&emsp;&emsp;It’s that IRDNIC comes from Goldman Sachs, which like serveral other big banks—Morgan Stanley,UBS—is putting its future bets on wealth-management services catering to rich idividuals rather than the masses. Banks would say this is because the cost of doing business with regular people has grown too high in the wake of Dodd-Frank regulation. It’s true that in one sense, new regulations dictating how much risk banks can take and how much capital they have to maintain make it easier to provide services to the rich. That’s one reason why,for example,the rates on jumbo mortagages—the kind the wealthy take out to buy expensive homes—have fallen relative to those of 30-year loans,which typically cater to the middle class. It also explains why access to credit cards is constrained for lower-income people compared with those higher up the economic ladder.</p><p>&emsp;&emsp;Regulation isn’t entirely to blame.For starters,banks are increasingly looking to wealthy individuals to make up for the profits they aren’t making by trading. Even without Dodd-Frank, it would have been difficult for banks to maintain their precrisis trading revenue in a market with the lowest volatility levels in decades. (Huge market shifts mean huge profits for banks on the right side of a trade.)The market calm is largely due to the Federal Reserve Bank’s unprecedented Sq trillion money dump,which is itself an effort to prop up an anemic recovery.</p><p>&emsp;&emsp;All of this leads to a self-perpetuating vicious cycle:the lack of access to banking services,loans and capital fuels America’s growing wealth divide,which is particularly sharke when it comes to race.A May study by the Center for Global Policy Solutions,a Washington-based consultancy,and Duke University found that the median amount of liquid wealth(assets that can easily be turned into cash) held by African-American households was $200.For Latino households it was $340.</p><p>&emsp;&emsp;The median for white households was $23,000.One reason for the difference is that a disproportionate number of minorities(along with women and younger workers of all races) have no access to formal retirement-savings plans.No surprise that asset management,the fastest-growing area of finance,is yet another area in which big banks focus mainly on serving the rich.</p><p>&emsp;&emsp;In lieu of focusing banks to lend to lower-income groups,something that is being tried with mixed results in the U.K.,what to do? Smarter housing policy would be a good place to start. The majority of Americans still keep most of their wealth in their homes.But so far,investors and rich buyers who can largely pay in cash have led the housing recovery.That’s partly why home sales are up but mortgage applications are down.Policymaker and banks need to rethink who is a “good” borrower.One 10-year study by the University of North Carolina,Chapel Hill,for example,found that poor buyers putting less than 5% down can be better-than-average credit risks if vetted by metric aside from how much cash they have on hand.If banks won’t take the risk of lending to them,they may eventually find their own growth prospects in peril.After all,1% can you only so far.</p><p>&emsp;&emsp;（Time,2014.9）</p>]]></content>
      <categories>
        <category>考研</category>
        <category>英语</category>
        <category>泛读</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>CGTN</tag>
        <tag>泛读</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统基本知识概述</title>
    <url>/2020/06/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p><img src="/2020/06/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E6%A6%82%E8%BF%B0/1.png" alt><br><a id="more"></a></p><h2 id="1-操作系统-OS-："><a href="#1-操作系统-OS-：" class="headerlink" title="1 操作系统(OS)："></a>1 操作系统(OS)：</h2><p>&emsp;&emsp;是控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配；（<strong>是系统资源的管理者</strong>）以提供给用户和其他软件方便的接口和环境；（<strong>向上层提供方便易用的服务</strong>）它是计算机系统中最基本的系统软件（<strong>是最接近硬件的一层软件</strong>）。</p><h3 id="1-1-OS作为系统资源的管理者："><a href="#1-1-OS作为系统资源的管理者：" class="headerlink" title="1.1 OS作为系统资源的管理者："></a>1.1 OS作为系统资源的管理者：</h3><blockquote><p>提供的功能：处理机管理、存储器管理、文件管理、设备管理；<br>目标：安全、高效；</p></blockquote><p>&emsp;&emsp;【补充：<strong>执行一个软件之前要将其放到内存中，才能被CPU处理</strong>】</p><p>例子：（用QQ视频聊天过程）<br>&emsp;&emsp;step1: 在各个文件夹下找到QQ的安装位置； 【文件管理功能】<br>&emsp;&emsp;step2: 双击打开QQ.exe； 【存储器管理功能】<br>&emsp;&emsp;step3: QQ程序正常运行； 【处理机管理功能】<br>&emsp;&emsp;step4: QQ视频聊天； 【设备管理功能】</p><h3 id="1-2-OS向上层提供方便易用的服务："><a href="#1-2-OS向上层提供方便易用的服务：" class="headerlink" title="1.2 OS向上层提供方便易用的服务："></a>1.2 OS向上层提供方便易用的服务：</h3><blockquote><p><strong>封装思想</strong>：OS把一些复杂的硬件功能封装成简单易用的服务，使用户更加方便地使用计算机，用户无需关心底层硬件的原理，只需对OS发出命令即可。</p></blockquote><p><strong>提供的服务：</strong></p><blockquote><ul><li>图形化用户接口（GUI,Graphical User Interface）;</li><li>命令接口：<ul><li>联机命令接口（交互式命令接口）：<br>【特点：<strong>用户说一句，系统跟着做一句</strong>】</li><li>脱机命令接口（批处理命令接口）：<br>【特点：<strong>用户说一堆，系统跟着做一堆</strong>】</li></ul></li><li>程序接口：可以在程序中进行<strong>系统调用（广义指令)</strong>来使用。普通用户不能直接使用程序接口，只能通过程序代码<strong>间接</strong>使用。（<strong>由一系列系统调用组成</strong>）</li></ul></blockquote><h3 id="1-3-OS作为最接近硬件的系统软件："><a href="#1-3-OS作为最接近硬件的系统软件：" class="headerlink" title="1.3 OS作为最接近硬件的系统软件："></a>1.3 OS作为最接近硬件的系统软件：</h3><blockquote><p>功能：实现对硬件机器的拓展；</p></blockquote><p>&emsp;&emsp;在裸机上安装OS，可以提供资源管理功能和方便用户的服务，将裸机改造成功能更强、使用更加方便的机器。<br>&emsp;&emsp;通常将覆盖了软件的机器称为<strong>扩充机器</strong>或<strong>虚拟机</strong>）。</p><hr><h2 id="2-OS的特征："><a href="#2-OS的特征：" class="headerlink" title="2 OS的特征："></a>2 OS的特征：</h2><blockquote><p>并发、共享、【<strong>两个最基本的特征，互为存在条件</strong>】 虚拟、异步；</p></blockquote><h3 id="2-1-OS的并发性："><a href="#2-1-OS的并发性：" class="headerlink" title="2.1 OS的并发性："></a>2.1 OS的并发性：</h3><p>&emsp;&emsp;指两个或多个进程在同一时间间隔内运行。这些进程在宏观上是同时进行的，而在微观上是交替进行的；<br>&emsp;&emsp;<strong>并行</strong>：指两个或多个进程在同一时刻同时运行。<br>&emsp;&emsp;OS是伴随着“多道程序技术”而出现的。OS和程序并发是同时诞生的。</p><h3 id="2-2-共享："><a href="#2-2-共享：" class="headerlink" title="2.2 共享："></a>2.2 共享：</h3><p>&emsp;&emsp;即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用；</p><blockquote><ul><li><strong>互斥共享方式：</strong><br>【在一个时间段内只允许一个进程访问该资源】<br>【例子：（摄像头设备资源）】</li><li><strong>同时共享方式：</strong><br>【允许在一个时间段内多个进程“同时”对该资源进行访问】<br>【例子：（QQ和微信“同时”发送文件）（游戏音效和音乐同时播放）】</li></ul></blockquote><p>&emsp;&emsp;<strong>如果失去并发性，即系统中只有一个程序在运行，则共享性就失去了存在的意义；如果失去共享性，则多个程序不能同时访问系统资源，就无法实现并发。</strong></p><h3 id="2-3-虚拟："><a href="#2-3-虚拟：" class="headerlink" title="2.3 虚拟："></a>2.3 虚拟：</h3><blockquote><p>即把一个物理上的实体变为若干个逻辑上的对应物。前者实际存在，后者是用户感受到的。</p></blockquote><p>&emsp;&emsp;虚拟存储器技术 （空分复用技术）<br>&emsp;&emsp;虚拟处理器技术 （时分复用技术）</p><h3 id="2-4-异步："><a href="#2-4-异步：" class="headerlink" title="2.4 异步："></a>2.4 异步：</h3><blockquote><p>在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底，而是走走停停的，以不可预知的速度向前推进。</p></blockquote><p>&emsp;&emsp;异步性使得操作系统在一种随机环境下运行，可能导致进程产生与时间相关的错误。但是，只要<strong>运行环境相同</strong>，OS必须保证在多次运行后都能获得<strong>相同的结果</strong>。</p><hr><h2 id="3-OS的发展史："><a href="#3-OS的发展史：" class="headerlink" title="3 OS的发展史："></a>3 OS的发展史：</h2><blockquote><ul><li>手工操作阶段</li><li>批处理阶段：<ul><li>单道批处理系统</li><li>多道批处理系统（操作系统开始出现）</li></ul></li><li>分时操作系统</li><li>实时操作系统</li><li>网络操作系统</li><li>分布式操作系统</li><li>个人计算机操作系统</li></ul></blockquote><h3 id="3-1-手工操作阶段："><a href="#3-1-手工操作阶段：" class="headerlink" title="3.1 手工操作阶段："></a>3.1 手工操作阶段：</h3><p>&emsp;&emsp;人 —- 纸带机 —- 计算机 —- 纸带机 —- 人<br>&emsp;&emsp;（输入速度慢）（计算处理速度快） （输出速度慢）<br>&emsp;&emsp;<strong>主要缺点</strong>：<br>&emsp;&emsp;&emsp;&emsp;①用户独占全机<br>&emsp;&emsp;&emsp;&emsp;②人机速度矛盾导致资源利用率极低</p><h3 id="3-2-单道批处理系统："><a href="#3-2-单道批处理系统：" class="headerlink" title="3.2 单道批处理系统："></a>3.2 单道批处理系统：</h3><blockquote><p>引入了脱机输入/输出技术，并由监督程序负责控制作业的输入、输出；</p></blockquote><p>&emsp;&emsp;人 —- 纸带机 —- 磁盘&emsp;&emsp;&emsp;&emsp;磁盘 —- 计算机 —- 磁盘<br>&emsp;&emsp;<strong>主要优点</strong>：缓解了一定的人机速度矛盾，资源利用率有所提升；<br>&emsp;&emsp;<strong>主要缺点</strong>：内存中仅能有一道程序运行，只有该程序运行结束后才能调入下一道程序。CPU有很大的一段时间都在空闲地等待I/O的完成。资源利用率依然很低。</p><h3 id="3-3-多道批处理系统："><a href="#3-3-多道批处理系统：" class="headerlink" title="3.3 多道批处理系统："></a>3.3 多道批处理系统：</h3><blockquote><p>每次往程序中读入多道程序；操作系统诞生，用于支持多道程序并发执行；</p></blockquote><p>&emsp;&emsp;<strong>主要优点</strong>：多道程序并发执行，共享计算机资源。资源利用率大幅度提升。CPU和其他资源可以长时间处于“忙碌”状态，系统吞吐量增大。<br>&emsp;&emsp;<strong>主要缺点</strong>： 用户响应时间长，没有人机交互。（用户提交完自己的作业就只能等待计算机处理完成，中间不能控制自己的作业执行【无法调试、无法调参】）</p><h3 id="3-4-分时操作系统："><a href="#3-4-分时操作系统：" class="headerlink" title="3.4 分时操作系统："></a>3.4 分时操作系统：</h3><blockquote><p>计算机以时间片为单位轮流为各个用户/作业服务，各个用户可通过终端和计算机进行交互。</p></blockquote><p>&emsp;&emsp;<strong>主要优点</strong>：用户请求可以被立即响应，解决人机交互的问题。允许多个用户同时使用一台计算机，并且对计算机的操作相互独立。<br>&emsp;&emsp;<strong>主要缺点</strong>： 不能优先处理一些紧急任务。操作系统对于每个用户来说都是完全公平的，循环的为每个用户/作业服务一个时间片，不区分任务的紧急性。</p><h3 id="3-5-实时操作系统："><a href="#3-5-实时操作系统：" class="headerlink" title="3.5 实时操作系统："></a>3.5 实时操作系统：</h3><p>&emsp;&emsp;<strong>主要优点</strong>：能够优先的响应一些紧急任务，某些紧急任务不需要时间片排队。<br>&emsp;&emsp;在实时操作系统的控制下，计算机系统接收到外部信号后进行及时处理，并且在严格的时限内处理完事件。主要特点是及时性和可靠性。</p><blockquote><ul><li>硬实时操作系统：<br>【必须在规定的时限内完成处理】（导弹控制系统）</li><li>软实时操作系统：<br>【允许偶尔违反时间规定】（12306火车订票系统）</li></ul></blockquote><h3 id="3-6-其他的操作系统："><a href="#3-6-其他的操作系统：" class="headerlink" title="3.6 其他的操作系统："></a>3.6 其他的操作系统：</h3><p>&emsp;&emsp;网络操作系统：<br>&emsp;&emsp;&emsp;&emsp;是伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机的结合起来，实现数据传送等功能，实现网络中各种资源的共享和各台计算机之间的通信。（Windows NT 就是一种典型的网络操作系统）</p><p>&emsp;&emsp;分布式操作系统：<br>&emsp;&emsp;&emsp;&emsp;主要特点：分布性和并行性。系统中个台计算机的地位相同，任何工作都可以分布在这些计算机上，由它们并行、协同的完成这个任务。</p><p>&emsp;&emsp;个人计算机操作系统： 如Windows XP、MacOS，方便个人使用。</p><hr><h2 id="4-OS的运行机制："><a href="#4-OS的运行机制：" class="headerlink" title="4 OS的运行机制："></a>4 OS的运行机制：</h2><p><strong>程序简单运行：</strong><br>&emsp;&emsp;高级语言编写代码 —-&gt;(编译) 机器指令<br>&emsp;&emsp;即程序的运行过程就是CPU执行一条一条机器指令的过程；<br>&emsp;&emsp;【指令： 就是CPU能够处理和执行的最基本的命令】</p><p><strong>两类程序：</strong></p><blockquote><ul><li>内核程序 【特权指令、非特权指令】 【内核态】</li><li>应用程序 【非特权指令】 【用户态】</li></ul></blockquote><p><strong>两类指令：</strong></p><blockquote><ul><li>特权指令(如内存清零)</li><li>非特权指令</li></ul></blockquote><p>&emsp;&emsp;【补充：CPU在设计和生产的时候就划分了特权指令与非特权指令，因此CPU在执行一指令前就能判断出其类型。】</p><p><strong>两种处理器状态：</strong></p><blockquote><ul><li>内核态/管态：<br>【当CPU处于内核态时，说明此时正在运行的是内核程序，可以执行特权指令】</li><li>用户态/目态：<br>【当CPU处于用户态时，说明此时正在运行的是应用程序，只能执行非特权指令】</li></ul></blockquote><p>&emsp;&emsp;【补充：CPU中有一个寄存器叫做 程序状态字寄存器PSW，其中用一个二进制位来表示用户态/内核态】</p><p><strong>内核(Kernel)</strong>：是由很多的内核程序组成计算机内核。它是OS最重要最核心的部分。</p><p><strong>如何切换CPU状态：</strong></p><blockquote><ul><li>内核态 —-&gt; 用户态<br>【执行一条修改PSW的特权指令】</li><li>用户态 —-&gt; 内核态<br>【由“中断”引起，硬件自动完成切换CPU状态过程】</li></ul></blockquote><p>例子：<br>&emsp;&emsp;①刚开机，CPU为“内核态”，操作系统内核程序现在CPU上运行；<br>&emsp;&emsp;②开机之后，用户启动某个应用程序；<br>&emsp;&emsp;③操作系统内核程序在合适的时候让出CPU，让该应用程序在CPU上运行； 【OS内核在让出CPU之前，会用一条特权指令把PSW的标志位设置为“用户态”】<br>&emsp;&emsp;④应用程序运行，CPU处于“用户态”；<br>&emsp;&emsp;⑤若由于某种原因，此时应用程序中出现一条特权指令…<br>&emsp;&emsp;⑥CPU发现接下来要执行的指令时特权指令，而此时CPU处于“用户态”；<br>&emsp;&emsp;⑦这个非法事件引发一个 中断信号； 【CPU检测到中断信号后，会立即切换到“内核态”，并停止当前运行的应用软 件，转而运行处理中断信号的内核软件】<br>&emsp;&emsp;⑧“中断”是的操作系统再次夺回CPU的控制权；<br>&emsp;&emsp;⑨OS对引发中断信号的时间进行处理，处理完之后再将CPU的使用权交给其他应用程序；</p><hr><h2 id="5-中断和异常："><a href="#5-中断和异常：" class="headerlink" title="5 中断和异常："></a>5 中断和异常：</h2><p><strong>中断的作用：</strong><br>&emsp;&emsp;使CPU的状态由 用户态 切换到 内核态，也是让操作系统夺回CPU使用权的唯一途径。</p><p><strong>中断：</strong></p><blockquote><ul><li><strong>内中断(异常):</strong> 【与当前指令有关，中断信号来源于CPU内部】<ul><li><strong>陷阱/陷入(trap)</strong>：<br>【由陷入指令引发，是应用程序故意引发的】<br>&emsp;&emsp;（当应用程序请求操作系统内核的服务，此时执行一条特殊指令，即陷入指令，该指令会引发一个内部中断信号）<br>【“系统调用”就是通过 陷入指令来实现的】</li><li><strong>故障(fault)</strong>：<br>【由错误条件引发的，可能被内核程序修复】<br>内核程序修复后将CPU使用权还给应用程序，让其继续执行（如：缺页故障）</li><li><strong>终止(abort)</strong>：<br>【由致命错误引发的，内核程序无法修复该错误】<br>直接终止应用程序<br>&emsp;&emsp;（试图在用户态下执行特权指令；执行除法指令时除数为0）</li></ul></li><li><strong>外中断:</strong> 【与当前指令无关，中断信号来源于CPU外部】<ul><li>时钟中断<br>&emsp;&emsp;时钟每隔一个时间片会给CPU发送一个时钟中断信号）</li><li>I/O中断请求</li></ul></li></ul></blockquote><p><strong>中断机制的基本原理：</strong><br>&emsp;&emsp;不同的中断信号，需要用不同的中断处理程序来处理。当CPU检测到中断信号后，会根据中断信号的类型去查询“中断向量表”，以此来找到相应的中断处理程序在内存中的存放位置。</p><p><strong>检查中断信号：</strong></p><blockquote><ul><li>内中断: CPU在执行指令时会检查是否有异常发生</li><li>外中断：每个指令周期末尾，CPU都会检查是否有外中断信号需要处理</li></ul></blockquote><hr><h2 id="6-系统调用："><a href="#6-系统调用：" class="headerlink" title="6 系统调用："></a>6 系统调用：</h2><blockquote><p>操作系统为上层提供方便易用的服务。主要包括GUI、命令接口、程序接口。程序接口是由一组系统调用组成的。系统调用是操作系统提供给应用程序/用户 使用的接口，应用程序可以提供系统调用来获得操作系统内核服务。</p></blockquote><p><strong>系统调用和库函数的区别：</strong><br>&emsp;&emsp;<em>普通应用程序</em>&emsp;&emsp;【可直接进行系统调用，也可以使用库函数，【有的库函数涉及系统调用（创建一个文件），有的不涉及（绝对值库函数）】】<br>&emsp;&emsp;<em>编程语言</em>&emsp;&emsp;【向上层提供库函数。有时会将系统调用封装成库函数，以隐藏系统调用的一些细节，使程序员编码更加方便】<br>&emsp;&emsp;<em>操作系统</em>&emsp;&emsp;【向上层提供系统调用，是上层程序能请求内核服务】<br>&emsp;&emsp;<em>裸机</em></p><p><strong>为什么系统调用是必须的：</strong><br>&emsp;&emsp;由操作系统对共享资源进行统一管理，并向上层提供系统调用，用户进程想要使用共享资源时，只能通过系统调用向内核发出请求。内核对各个请求进行协调处理。保证系统的稳定性与安全性，防止用户进行非法操作。<br>&emsp;&emsp;比如，WPS 和 Word 两个应用程序同时使用 打印机 这个共享资源，如果这两个程序随意地、并发地共享打印机资源，那么打印的文件将会出错;因此，通过系统调用，使在共享 打印机资源时 请求操作系统内核来协调管理 共享资源。</p><p><strong>系统调用按功能分类：</strong></p><blockquote><ul><li>设备管理&emsp;&emsp;&emsp;&emsp;完成设备的 请求/释放/启动 等功能</li><li>文件管理&emsp;&emsp;&emsp;&emsp;完成文件的 读/写/创建/删除 等功能</li><li>进程控制&emsp;&emsp;&emsp;&emsp;完成进程的 创建/撤销/阻塞/唤醒 等功能</li><li>进程通信&emsp;&emsp;&emsp;&emsp;完成进程之间的 消息传递/信号传递 等功能</li><li>内存管理&emsp;&emsp;&emsp;&emsp;完成内存的 分配/回收 等功能</li></ul></blockquote><p><strong>系统调用的过程：</strong><br>&emsp;&emsp;传递系统调用参数 —-&gt; 执行陷入命令（用户态） —-&gt; 执行相应的内核程序请求处理系统调用（核心态） —-&gt; 返回应用程序<br>&emsp;&emsp;【通过传参指令给CPU的寄存器传入参数；（如指明系统调用类型的参数）参数可以有多个】<br>&emsp;&emsp;【trap指令引发一个内中断】<br>&emsp;&emsp;【执行系统调用入口程序(根据其他参数判断需要哪种系统调用服务)】</p><p>注意：<br>&emsp;&emsp;1.trap指令是在用户态下执行的，执行trap指令后立即引发一个内中断，使CPU进入核心态<br>&emsp;&emsp;2.发出系统调用的请求实在用户态下，二对系统调用的相应处理是在内核态下</p><hr><h2 id="7-操作系统的体系结构："><a href="#7-操作系统的体系结构：" class="headerlink" title="7 操作系统的体系结构："></a>7 操作系统的体系结构：</h2><p><img src="/2020/06/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E6%A6%82%E8%BF%B0/2.png" alt="计算机系统的层次结构"><br>&emsp;&emsp;非内核功能（如GUI）<br>&emsp;&emsp;操作系统内核：<br>&emsp;&emsp;&emsp;&emsp;进程管理、存储器管理、设备管理;&emsp;&emsp;【对系统资源进行管理功能；这些管理工作更多的是对数据结构的操作，不会直接涉及硬件】<br>&emsp;&emsp;&emsp;&emsp;时钟管理;&emsp;&emsp;【利用时钟中断实现计时功能】<br>&emsp;&emsp;&emsp;&emsp;中断处理;&emsp;&emsp;【负责中断机制，CPU从用户态切换到核心态】<br>&emsp;&emsp;&emsp;&emsp;原语（设备驱动、CPU切换等）;&emsp;&emsp;【原语是一种特殊的程序，具有原子性。也就是说，这种程序的运行是一气呵成，不能被“中断”】【运行时间较短，调用频繁】</p><p><strong>大内核/宏内核：</strong><br>&emsp;&emsp;【优点：高性能】<br>&emsp;&emsp;【缺点：内核代码庞大、结构混乱，难以维护】<br><strong>微内核：</strong> 【只包含时钟管理、中断处理、原语】<br>&emsp;&emsp;【优点：内核功能少，结构清晰，方便维护】<br>&emsp;&emsp;【缺点：需要频繁在内核态与用户态之间切换，系统性能低】</p><p>&emsp;&emsp;【补充：CPU的切换状态 是有成本的，要消耗不少时间，频繁的切换会降低系统性能】</p><hr>]]></content>
      <categories>
        <category>考研</category>
        <category>专业课</category>
        <category>操作系统</category>
        <category>计算机</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>英语短语_day_1</title>
    <url>/2020/06/04/%E8%8B%B1%E8%AF%AD%E7%9F%AD%E8%AF%AD_day_1/</url>
    <content><![CDATA[<p>&emsp;&emsp;<strong>a bit</strong>&emsp;&emsp;&emsp;&emsp;稍微，有点<br>&emsp;&emsp;<strong>a body of</strong>&emsp;&emsp;&emsp;&emsp;大量，大批（信息、知识等）<br>&emsp;&emsp;<strong>a case in point</strong>&emsp;&emsp;&emsp;&emsp;恰当的例子，例证<br><a id="more"></a><br>&emsp;&emsp;<strong>a chance of lifetime = an once-in-a-life-time opportunity</strong>&emsp;&emsp;&emsp;&emsp;千载难逢的机会<br>&emsp;&emsp;<strong>a copy of</strong>&emsp;&emsp;&emsp;&emsp;一本，一份<br>&emsp;&emsp;<strong>a couple of</strong>&emsp;&emsp;&emsp;&emsp;一双，一对；几个<br>&emsp;&emsp;<strong>a fraction of</strong>&emsp;&emsp;&emsp;&emsp;一小部分<br>&emsp;&emsp;<strong>a handful of</strong>&emsp;&emsp;&emsp;&emsp;一小撮<br>&emsp;&emsp;<strong>a host of</strong>&emsp;&emsp;&emsp;&emsp;许多，一大群<br>&emsp;&emsp;<strong>a large number of</strong>&emsp;&emsp;&emsp;&emsp;大量的（+可数n）<br>&emsp;&emsp;<strong>a large quantity of</strong>&emsp;&emsp;&emsp;&emsp;大量的（+可/不可数n）<br>&emsp;&emsp;<strong>a matter of</strong>&emsp;&emsp;&emsp;&emsp;（关于）问题<br>&emsp;&emsp;<strong>a multitude of</strong>&emsp;&emsp;&emsp;&emsp;许多，大量<br>&emsp;&emsp;<strong>a number of</strong>&emsp;&emsp;&emsp;&emsp;若干<br>&emsp;&emsp;<strong>a passing fad</strong>&emsp;&emsp;&emsp;&emsp;流行一时<br>&emsp;&emsp;<strong>a range of</strong>&emsp;&emsp;&emsp;&emsp;一系列<br>&emsp;&emsp;<strong>a wide range of</strong>&emsp;&emsp;&emsp;&emsp;范围广的，多方面的<br>&emsp;&emsp;<strong>a sea of</strong>&emsp;&emsp;&emsp;&emsp;一大片<br>&emsp;&emsp;<strong>a sequence of</strong>&emsp;&emsp;&emsp;&emsp;一连串<br>&emsp;&emsp;<strong>a series of</strong>&emsp;&emsp;&emsp;&emsp;接连发生的<br>&emsp;&emsp;<strong>a string of</strong>&emsp;&emsp;&emsp;&emsp;一连串<br>&emsp;&emsp;<strong>a sum of</strong>&emsp;&emsp;&emsp;&emsp;一笔，一定数量<br>&emsp;&emsp;<strong>a swarm of</strong>&emsp;&emsp;&emsp;&emsp;一大群<br>&emsp;&emsp;<strong>a ton of</strong>&emsp;&emsp;&emsp;&emsp;许多，大量<br>&emsp;&emsp;<strong>a variety of</strong>&emsp;&emsp;&emsp;&emsp;各种各样的<br>&emsp;&emsp;<strong>a/the majority of</strong>&emsp;&emsp;&emsp;&emsp;大多数的，大部分<br>&emsp;&emsp;<strong>abandon oneself to</strong>&emsp;&emsp;&emsp;&emsp;沉溺于<br>&emsp;&emsp;<strong>abide by</strong>&emsp;&emsp;&emsp;&emsp; 恪守，遵守</p><hr>]]></content>
      <categories>
        <category>考研</category>
        <category>英语</category>
        <category>短语</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>短语</tag>
      </tags>
  </entry>
  <entry>
    <title>英语泛读_day_1</title>
    <url>/2020/06/01/%E8%8B%B1%E8%AF%AD%E6%B3%9B%E8%AF%BB_day_1/</url>
    <content><![CDATA[<p><center>India Undermines Its Own Economy</center><br><a id="more"></a><br>&emsp;&emsp;When Indian Prime Minister Manmohan Singh last visited the White House in 2009, he heralded “a moment of great opportunity” for the two countries, calling on both sides to work together to “harness the immense potential of our talented and enterprising people and support each other’s growth and prosperity.” Yet,as Singh prepares for his visit to Washington this week, India’s trade and investment policies threaten to undermine, rather than harness, the potential.</p><p>&emsp;&emsp;With the United States still recovering from a recession and the continued slowdown in India’s economic growth, the potential value of a deepening partnership has only increased. From my personal experience in India over the last two decades, I have witnessed firsthand the progress that has been made to solidify the relationship between India and the U.S. Between 2000 and 2011, revenue from U.S. exports to India increased seven-fold,and India’s exports to the U.S. more than tripled as the trade and investment relationship gathered momentum.</p><p>&emsp;&emsp;Yet,four years after Singh’s initial visit, the potential of the relationship still remains largely unfullfilled. Suprisingly, India remains only the 13th largest trading partner of the United States, even though it may soon become the world’s third largest economy.The United States trades more with Korea than with India, despite its being only a tiny fraction of India’s size.</p><p>&emsp;&emsp;Recent actioins taken by the India government have only impeded further progress in the relationship .India has resorted to “compulsory licensing” to appropriate foreign firm’s intellectual property in violation of international trade norms. It has overriden, revoked or infringed upon approximately a dozen pharmaceutical patents held by foreign firms since 2012 alone. And its industrial policy expressly calls for such measures in other sectors as well. These actions create an atmosphere or distrust that will only discourage new investment in India.</p><p>&emsp;&emsp;India has only mandated local content requirements,charged exorbitant tariffs at the border in certain sectors and maintained onerous market entry barriers and foreign equity caps. One headline aptly captured India’s ambivalence towards easing market access:”The License Raj is Dead.Long Live the License Raj.” These barriers hinder investment in banking, financial services,insurance,retail,telecommunications and many other sectors.</p><p>&emsp;&emsp;This year, India will experience only 5 percent growth - the lowest in a decade. Foreign investment has fallen by nearly two-thirds in the past year, and the rupee has plummeted. Although short-term protectionism may appeal to domestic constituencies as the campaign begins for next year’s elections in India, history has proven that such policies are inconsistent with a dynamic economy that generates wealth over the long-term. And given the state of its economy, this is hardly the time for India to alienate foreign investors.</p><p>&emsp;&emsp;Certainly the U.S. can do its part,too, by implementing sorely needed reforms to our immigration policy and ensuring that highly-skilled workers can continue to learn from and contribute to our economy through the H-1B visa program. But frankly there is far more to be done on the Indian side to ensure fairness in our economic relationship. Respecting intellectual property rights and beginning to remove restrictive barriers to trade and investment will be essential first steps along this path.</p><p>&emsp;&emsp;President Obama should use Prime Minster Singh’s upcoming visit to raise concern that the relationship’s “immense potential” that was heralded four years ago remains unfullfilled. While important progress has been made on the strategic front,India’s recent economic policies are hurting the relationship. Mr.Singh’s visit represents a new moment of opportunity - we can only hope that the opportunity is seized more effectively than four years ago.</p><p>&emsp;&emsp;(U.S. News &amp; World Report,2013.9)</p>]]></content>
      <categories>
        <category>考研</category>
        <category>英语</category>
        <category>泛读</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>CGTN</tag>
        <tag>泛读</tag>
      </tags>
  </entry>
  <entry>
    <title>英语晨读_day_5</title>
    <url>/2020/05/07/%E8%8B%B1%E8%AF%AD%E6%99%A8%E8%AF%BB_day_5/</url>
    <content><![CDATA[<h3 id="SOURCE"><a href="#SOURCE" class="headerlink" title="SOURCE:"></a>SOURCE:</h3><p><a href="https://news.cgtn.com/news/2020-05-07/First-COVID-19-vaccine-test-on-animals-successful-Qi8WFGpvY4/index.html" target="_blank" rel="noopener">First COVID-19 vaccine test on animals successful</a><br><a id="more"></a></p><h3 id="NOTES"><a href="#NOTES" class="headerlink" title="NOTES:"></a>NOTES:</h3><hr><p><img src="/2020/05/07/%E8%8B%B1%E8%AF%AD%E6%99%A8%E8%AF%BB_day_5/5–7/1.jpg" alt="1"><br><img src="/2020/05/07/%E8%8B%B1%E8%AF%AD%E6%99%A8%E8%AF%BB_day_5/5–7/2.jpg" alt="2"></p><h2 id="—"><a href="#—" class="headerlink" title="—-"></a>—-</h2><p>&emsp;&emsp;<strong>prove</strong> &emsp;&emsp;&emsp;&emsp; 证实；检验<br>&emsp;&emsp;<strong>life forms</strong> &emsp;&emsp;&emsp;&emsp; 生物<br>&emsp;&emsp;<strong>crippled virus</strong> &emsp;&emsp;&emsp;&emsp; 灭活病毒<br>&emsp;&emsp;<strong>inject</strong> &emsp;&emsp;&emsp;&emsp; 注射<br>&emsp;&emsp;<strong>expose</strong> &emsp;&emsp;&emsp;&emsp; 暴露<br>&emsp;&emsp;<strong>dose</strong> &emsp;&emsp;&emsp;&emsp; 剂量<br>&emsp;&emsp;<strong>lung</strong> &emsp;&emsp;&emsp;&emsp;肺<br>&emsp;&emsp;<strong>meanwhile</strong> &emsp;&emsp;&emsp;&emsp; 同时<br>&emsp;&emsp;<strong>pneumonia</strong> &emsp;&emsp;&emsp;&emsp; 急性肺炎<br>&emsp;&emsp;<strong>undergo</strong> &emsp;&emsp;&emsp;&emsp; 经历；承受<br>&emsp;&emsp;<strong>Sinopharm</strong> &emsp;&emsp;&emsp;&emsp; 国药公司<br>&emsp;&emsp;<strong>the second phase</strong> &emsp;&emsp;&emsp;&emsp; 第二阶段<br>&emsp;&emsp;<strong>clinical trials</strong> &emsp;&emsp;&emsp;&emsp; 临床试验</p><hr>]]></content>
      <categories>
        <category>英语</category>
        <category>晨读</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>晨读</tag>
        <tag>CGTN</tag>
      </tags>
  </entry>
  <entry>
    <title>英语晨读_day_4</title>
    <url>/2020/05/05/%E8%8B%B1%E8%AF%AD%E6%99%A8%E8%AF%BB_day_4/</url>
    <content><![CDATA[<h3 id="SOURCE"><a href="#SOURCE" class="headerlink" title="SOURCE:"></a>SOURCE:</h3><p><a href="https://news.cgtn.com/news/2020-05-04/Tesla-to-build-4-000-Model-3s-per-week-in-Shanghai-by-mid-2020-QdcrSajSmc/index.html" target="_blank" rel="noopener">Tesla to build 4,000 Model 3s per week in Shanghai by mid-2020</a><br><a id="more"></a></p><h3 id="NOTES"><a href="#NOTES" class="headerlink" title="NOTES:"></a>NOTES:</h3><hr><p><img src="/2020/05/05/%E8%8B%B1%E8%AF%AD%E6%99%A8%E8%AF%BB_day_4/5–5/1.jpg" alt="1"><br><img src="/2020/05/05/%E8%8B%B1%E8%AF%AD%E6%99%A8%E8%AF%BB_day_4/5–5/2.jpg" alt="2"></p><h2 id="—"><a href="#—" class="headerlink" title="—-"></a>—-</h2><p>&emsp;&emsp;<strong>gross margin</strong> &emsp;&emsp;&emsp;&emsp; 毛利润<br>&emsp;&emsp;<strong>the first quarter</strong> &emsp;&emsp;&emsp;&emsp; 第一季度<br>&emsp;&emsp;<strong>gigafactory</strong> &emsp;&emsp;&emsp;&emsp; 超级工厂<br>&emsp;&emsp;<strong>product line</strong> &emsp;&emsp;&emsp;&emsp; 产品线<br>&emsp;&emsp;<strong>launch</strong> &emsp;&emsp;&emsp;&emsp; 发起<br>&emsp;&emsp;<strong>configurator</strong> &emsp;&emsp;&emsp;&emsp; 配置器<br>&emsp;&emsp;<strong>ramp up</strong> &emsp;&emsp;&emsp;&emsp; 提升；增加<br>&emsp;&emsp;<strong>assemble line</strong> &emsp;&emsp;&emsp;&emsp;生产线<br>&emsp;&emsp;<strong>delivery</strong> &emsp;&emsp;&emsp;&emsp; 投递；交付<br>&emsp;&emsp;<strong>eligibility</strong> &emsp;&emsp;&emsp;&emsp;适合，合适；参赛资格<br>&emsp;&emsp;<strong>subsidy</strong> &emsp;&emsp;&emsp;&emsp;补贴；补助金</p><hr>]]></content>
      <categories>
        <category>英语</category>
        <category>晨读</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>晨读</tag>
        <tag>CGTN</tag>
      </tags>
  </entry>
  <entry>
    <title>英语晨读_day_3</title>
    <url>/2020/05/04/%E8%8B%B1%E8%AF%AD%E6%99%A8%E8%AF%BB_day_3/</url>
    <content><![CDATA[<h3 id="SOURCE"><a href="#SOURCE" class="headerlink" title="SOURCE:"></a>SOURCE:</h3><p><a href="http://www.ecns.cn/news/sci-tech/2020-05-04/detail-ifzvxzhm6834329.shtml" target="_blank" rel="noopener">German telecom carrier: We need Huawei in 5G network construction</a><br><a id="more"></a></p><h3 id="NOTES"><a href="#NOTES" class="headerlink" title="NOTES:"></a>NOTES:</h3><hr><p><img src="/2020/05/04/%E8%8B%B1%E8%AF%AD%E6%99%A8%E8%AF%BB_day_3/5–4/1.jpg" alt="1"><br><img src="/2020/05/04/%E8%8B%B1%E8%AF%AD%E6%99%A8%E8%AF%BB_day_3/5–4/2.jpg" alt="2"><br><img src="/2020/05/04/%E8%8B%B1%E8%AF%AD%E6%99%A8%E8%AF%BB_day_3/5–4/3.jpg" alt="3"></p><h2 id="—"><a href="#—" class="headerlink" title="—-"></a>—-</h2><p>&emsp;&emsp;<strong>telecom carrier</strong> &emsp;&emsp;&emsp;&emsp;电信运营商(telecom operator)<br>&emsp;&emsp;<strong>construction</strong> &emsp;&emsp;&emsp;&emsp; 建设<br>&emsp;&emsp;<strong>board director</strong> &emsp;&emsp;&emsp;&emsp; 董事会<br>&emsp;&emsp;<strong>board member</strong> &emsp;&emsp;&emsp;&emsp; 董事会成员<br>&emsp;&emsp;<strong>general manager</strong> &emsp;&emsp;&emsp;&emsp; 总经理<br>&emsp;&emsp;<strong>remark</strong> &emsp;&emsp;&emsp;&emsp; 评论<br>&emsp;&emsp;<strong>base station</strong> &emsp;&emsp;&emsp;&emsp; 基站<br>&emsp;&emsp;<strong>point out</strong> &emsp;&emsp;&emsp;&emsp; 指出<br>&emsp;&emsp;<strong>compatible</strong> &emsp;&emsp;&emsp;&emsp; 兼容的<br>&emsp;&emsp;<strong>antennas</strong> &emsp;&emsp;&emsp;&emsp; 天线<br>&emsp;&emsp;<strong>vice versa</strong> &emsp;&emsp;&emsp;&emsp; 反之亦然<br>&emsp;&emsp;<strong>eliminate</strong> &emsp;&emsp;&emsp;&emsp; 消除<br>&emsp;&emsp;<strong>cite</strong> &emsp;&emsp;&emsp;&emsp; 引用<br>&emsp;&emsp;<strong>shun</strong> &emsp;&emsp;&emsp;&emsp; 避开；避免<br>&emsp;&emsp;<strong>prolong</strong> &emsp;&emsp;&emsp;&emsp; 延长<br>&emsp;&emsp;<strong>inform</strong> &emsp;&emsp;&emsp;&emsp; 告诉<br>&emsp;&emsp;<strong>intensify</strong> &emsp;&emsp;&emsp;&emsp; 增加；增强<br>&emsp;&emsp;<strong>population intensity</strong> &emsp;&emsp;&emsp;&emsp; 人口密集<br>&emsp;&emsp;<strong>state</strong> &emsp;&emsp;&emsp;&emsp; 陈述<br>&emsp;&emsp;<strong>subsequent</strong> &emsp;&emsp;&emsp;&emsp; 随后的<br>&emsp;&emsp;<strong>summit</strong> &emsp;&emsp;&emsp;&emsp; 峰会；顶点<br>&emsp;&emsp;<strong>advisory</strong> &emsp;&emsp;&emsp;&emsp; 提供咨询的；劝告的，忠告的；顾问的</p><hr>]]></content>
      <categories>
        <category>英语</category>
        <category>晨读</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>晨读</tag>
        <tag>CGTN</tag>
      </tags>
  </entry>
  <entry>
    <title>英语晨读_day_2</title>
    <url>/2020/05/02/%E8%8B%B1%E8%AF%AD%E6%99%A8%E8%AF%BB_day_2/</url>
    <content><![CDATA[<h3 id="SOURCE"><a href="#SOURCE" class="headerlink" title="SOURCE:"></a>SOURCE:</h3><p><a href="https://news.cgtn.com/news/2020-05-02/WHO-says-it-s-assured-coronavirus-is-natural-in-origin--Q9HrBeEulO/index.html" target="_blank" rel="noopener">WHO says it’s ‘assured’ coronavirus is ‘natural in origin’</a><br><a id="more"></a></p><h3 id="NOTES"><a href="#NOTES" class="headerlink" title="NOTES:"></a>NOTES:</h3><hr><p><img src="/2020/05/02/%E8%8B%B1%E8%AF%AD%E6%99%A8%E8%AF%BB_day_2/5–2/1.jpg" alt="1"><br><img src="/2020/05/02/%E8%8B%B1%E8%AF%AD%E6%99%A8%E8%AF%BB_day_2/5–2/2.jpg" alt="2"><br><img src="/2020/05/02/%E8%8B%B1%E8%AF%AD%E6%99%A8%E8%AF%BB_day_2/5–2/3.jpg" alt="3"></p><h2 id="—"><a href="#—" class="headerlink" title="—-"></a>—-</h2><p>&emsp;&emsp;<strong>is natural in origin</strong> &emsp;&emsp;&emsp;&emsp;来源于自然<br>&emsp;&emsp;<strong>WHO</strong> &emsp;&emsp;&emsp;&emsp;World Health Organisation<br>&emsp;&emsp;<strong>reiterate</strong> &emsp;&emsp;&emsp;&emsp;重申<br>&emsp;&emsp;<strong>emerge</strong> &emsp;&emsp;&emsp;&emsp;出现；涌向<br>&emsp;&emsp;<strong>seafood market</strong> &emsp;&emsp;&emsp;&emsp;海鲜市场<br>&emsp;&emsp;<strong>exotic</strong> &emsp;&emsp;&emsp;&emsp;来自国外的<br>&emsp;&emsp;<strong>virtual press conference</strong> &emsp;&emsp;&emsp;&emsp; 虚拟新闻发布会<br>&emsp;&emsp;<strong>previously</strong> &emsp;&emsp;&emsp;&emsp; 以前；之前<br>&emsp;&emsp;<strong>in a matter of months</strong> &emsp;&emsp;&emsp;&emsp; 在短短几个月<br>&emsp;&emsp;<strong>establish</strong> &emsp;&emsp;&emsp;&emsp; 证实；建立<br>&emsp;&emsp;<strong>natural host</strong> &emsp;&emsp;&emsp;&emsp; 天然宿主<br>&emsp;&emsp;<strong>breach</strong> &emsp;&emsp;&emsp;&emsp; 违反；在….留下缺口<br>&emsp;&emsp;<strong>put in place</strong> &emsp;&emsp;&emsp;&emsp; 实施；实现；做到<br>&emsp;&emsp;<strong>push back</strong> &emsp;&emsp;&emsp;&emsp; 反击<br>&emsp;&emsp;<strong>suspend</strong> &emsp;&emsp;&emsp;&emsp; 暂停<br>&emsp;&emsp;<strong>downplay</strong> &emsp;&emsp;&emsp;&emsp; 轻视；忽视…的重要性<br>&emsp;&emsp;<strong>sound</strong> &emsp;&emsp;&emsp;&emsp; 使发声<br>&emsp;&emsp;<strong>constitute</strong> &emsp;&emsp;&emsp;&emsp; 建立；构造；等同于<br>&emsp;&emsp;<strong>briefing</strong> &emsp;&emsp;&emsp;&emsp; 简报<br>&emsp;&emsp;<strong>intervene</strong> &emsp;&emsp;&emsp;&emsp; 阻碍；干涉<br>&emsp;&emsp;<strong>remain</strong> &emsp;&emsp;&emsp;&emsp;仍然是<br>&emsp;&emsp;<strong>recommendation</strong> &emsp;&emsp;&emsp;&emsp; 谏言<br>&emsp;&emsp;<strong>maintain</strong> &emsp;&emsp;&emsp;&emsp; 维持，保持<br>&emsp;&emsp;<strong>zoonotic</strong> &emsp;&emsp;&emsp;&emsp; 动物传染病的<br>&emsp;&emsp;<strong>introduction</strong> &emsp;&emsp;&emsp;&emsp;引入<br>&emsp;&emsp;<strong>appropriate</strong> &emsp;&emsp;&emsp;&emsp; 恰当的；适合的<br>&emsp;&emsp;<strong>humanitarian aid</strong> &emsp;&emsp;&emsp;&emsp; 人道主义援助<br>&emsp;&emsp;<strong>ground</strong> &emsp;&emsp;&emsp;&emsp; 禁飞<br>&emsp;&emsp;<strong>call for</strong> &emsp;&emsp;&emsp;&emsp; 要求（+ n.）<br>&emsp;&emsp;<strong>call on</strong> &emsp;&emsp;&emsp;&emsp; 邀请；号召；要求<br>&emsp;&emsp;<strong>call in</strong> &emsp;&emsp;&emsp;&emsp; 来访；用电话通知<br>&emsp;&emsp;<strong>call up</strong> &emsp;&emsp;&emsp;&emsp; （军）召集；给…打电话</p><hr>]]></content>
      <categories>
        <category>英语</category>
        <category>晨读</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>晨读</tag>
        <tag>CGTN</tag>
      </tags>
  </entry>
  <entry>
    <title>英语晨读_day_1</title>
    <url>/2020/04/28/%E8%8B%B1%E8%AF%AD%E6%99%A8%E8%AF%BB_day_1/</url>
    <content><![CDATA[<h3 id="SOURCE"><a href="#SOURCE" class="headerlink" title="SOURCE:"></a>SOURCE:</h3><p><a href="https://news.cgtn.com/news/2020-04-28/Will-a-pandemic-accelerate-adoption-of-meatless-meat-in-China--Q3MaBdoQXS/index.html" target="_blank" rel="noopener">Will a pandemic accelerate adoption of meatless meat in China?</a><br><a id="more"></a></p><h3 id="NOTES"><a href="#NOTES" class="headerlink" title="NOTES:"></a>NOTES:</h3><hr><p><img src="/2020/04/28/%E8%8B%B1%E8%AF%AD%E6%99%A8%E8%AF%BB_day_1/4–28/1.jpg" alt="1"><br><img src="/2020/04/28/%E8%8B%B1%E8%AF%AD%E6%99%A8%E8%AF%BB_day_1/4–28/2.jpg" alt="2"><br><img src="/2020/04/28/%E8%8B%B1%E8%AF%AD%E6%99%A8%E8%AF%BB_day_1/4–28/3.jpg" alt="3"><br><img src="/2020/04/28/%E8%8B%B1%E8%AF%AD%E6%99%A8%E8%AF%BB_day_1/4–28/4.jpg" alt="4"><br><img src="/2020/04/28/%E8%8B%B1%E8%AF%AD%E6%99%A8%E8%AF%BB_day_1/4–28/5.jpg" alt="5"><br><img src="/2020/04/28/%E8%8B%B1%E8%AF%AD%E6%99%A8%E8%AF%BB_day_1/4–28/6.jpg" alt="6"></p><h2><a href="#" class="headerlink"></a><img src="/2020/04/28/%E8%8B%B1%E8%AF%AD%E6%99%A8%E8%AF%BB_day_1/4–28/7.jpg" alt="7"></h2><hr><p>&emsp;&emsp;<strong>pandemic</strong> &emsp;&emsp;&emsp;&emsp;（全球范围的，全球性的）流行病<br>&emsp;&emsp;<strong>gingerly</strong>&emsp;&emsp;&emsp;&emsp; 小心翼翼地<br>&emsp;&emsp;<strong>sank</strong> &emsp;&emsp;&emsp;&emsp;下沉，使沉没 (sink）<br>&emsp;&emsp;<strong>offering</strong> &emsp;&emsp;&emsp;&emsp;用品；提供物<br>&emsp;&emsp;<strong>alternative</strong>&emsp;&emsp;&emsp;&emsp; 可替代的<br>&emsp;&emsp;<strong>faux</strong>&emsp;&emsp;&emsp;&emsp;假的；人造的<br>&emsp;&emsp;<strong>pork</strong>&emsp;&emsp;&emsp;&emsp; 猪肉<br>&emsp;&emsp;<strong>substitute</strong> &emsp;&emsp;&emsp;&emsp;替代品<br>&emsp;&emsp;<strong>unfold</strong> &emsp;&emsp;&emsp;&emsp;展现，呈现<br>&emsp;&emsp;<strong>prompt</strong>&emsp;&emsp;&emsp;&emsp; 促使<br>&emsp;&emsp;<strong>aficionado</strong>&emsp;&emsp;&emsp;&emsp; …迷<br>&emsp;&emsp;<strong>take a crack at the dish</strong>&emsp;&emsp;&emsp;&emsp;原指“仔细品尝这道菜”，好好考虑下这个问题（对肉类安全的担忧）；<br>&emsp;&emsp;<strong>swine</strong> &emsp;&emsp;&emsp;&emsp;猪；讨厌的人<br>&emsp;&emsp;<strong>authentic</strong>&emsp;&emsp;&emsp;&emsp; 真的；有根据的；可靠的<br>&emsp;&emsp;<strong>hit</strong>&emsp;&emsp;&emsp;&emsp; 袭击；影响<br>&emsp;&emsp;<strong>as such</strong>&emsp;&emsp;&emsp;&emsp; 因此<br>&emsp;&emsp;<strong>foray</strong>&emsp;&emsp;&emsp;&emsp; 侵袭；冒险<br>&emsp;&emsp;<strong>make foray into China</strong> &emsp;&emsp;&emsp;&emsp;进军中国<br>&emsp;&emsp;<strong>introduce</strong> &emsp;&emsp;&emsp;&emsp;引入；提出；推行<br>&emsp;&emsp;<strong>going green</strong>&emsp;&emsp;&emsp;&emsp;绿色环保<br>&emsp;&emsp;<strong>renewable</strong> &emsp;&emsp;&emsp;&emsp;可再生的；可更新的<br>&emsp;&emsp;<strong>hurdle</strong>&emsp;&emsp;&emsp;&emsp; 困难，障碍<br>&emsp;&emsp;<strong>On the surface</strong> &emsp;&emsp;&emsp;&emsp;表面上<br>&emsp;&emsp;<strong>manageable</strong> &emsp;&emsp;&emsp;&emsp;易处理的；易控制的<br>&emsp;&emsp;<strong>handout</strong>&emsp;&emsp;&emsp;&emsp;讲义；施舍品;救济品；印刷品<br>&emsp;&emsp;<strong>veggie</strong> &emsp;&emsp;&emsp;&emsp;素食者<br>&emsp;&emsp;<strong>veggie burger</strong> &emsp;&emsp;&emsp;&emsp;素食汉堡<br>&emsp;&emsp;<strong>texture</strong> &emsp;&emsp;&emsp;&emsp;质地；质感<br>&emsp;&emsp;<strong>bland</strong> &emsp;&emsp;&emsp;&emsp;温和的；平淡的<br>&emsp;&emsp;<strong>reserve almost strictly</strong>&emsp;&emsp;&emsp;&emsp; 量身定做<br>&emsp;&emsp;<strong>convert</strong> &emsp;&emsp;&emsp;&emsp;转变；改变<br>&emsp;&emsp;<strong>rank among the best</strong> &emsp;&emsp;&emsp;&emsp;名列前茅<br>&emsp;&emsp;<strong>carnivor</strong> &emsp;&emsp;&emsp;&emsp;食肉动物，食草动物<br>&emsp;&emsp;<strong>long for</strong>&emsp;&emsp;&emsp;&emsp;渴望<br>&emsp;&emsp;<strong>heme</strong> &emsp;&emsp;&emsp;&emsp;血红素<br>&emsp;&emsp;<strong>molecule</strong> &emsp;&emsp;&emsp;&emsp;分子，微小颗粒<br>&emsp;&emsp;<strong>raw</strong> &emsp;&emsp;&emsp;&emsp;未加工的<br>&emsp;&emsp;<strong>metallic</strong> &emsp;&emsp;&emsp;&emsp;金属的<br>&emsp;&emsp;<strong>savory</strong> &emsp;&emsp;&emsp;&emsp;好吃的，体面的<br>&emsp;&emsp;<strong>tender and juicy</strong> &emsp;&emsp;&emsp;&emsp;嫩而多汁<br>&emsp;&emsp;<strong>rely</strong> &emsp;&emsp;&emsp;&emsp;依靠；信赖<br>&emsp;&emsp;<strong>proprietary</strong>&emsp;&emsp;&emsp;&emsp;专有的，专利的；（商品）专卖的<br>&emsp;&emsp;<strong>replicate</strong>&emsp;&emsp;&emsp;&emsp; 重复<br>&emsp;&emsp;<strong>brew</strong> &emsp;&emsp;&emsp;&emsp;酿造<br>&emsp;&emsp;<strong>genetically modified yeast</strong> &emsp;&emsp;&emsp;&emsp;转基因酵母<br>&emsp;&emsp;<strong>fermentation</strong> &emsp;&emsp;&emsp;&emsp;发酵<br>&emsp;&emsp;<strong>concoction</strong>&emsp;&emsp;&emsp;&emsp; 混合物<br>&emsp;&emsp;<strong>resemble</strong>&emsp;&emsp;&emsp;&emsp;类似于<br>&emsp;&emsp;<strong>ground</strong> &emsp;&emsp;&emsp;&emsp;磨碎的；磨细的<br>&emsp;&emsp;<strong>ground beef</strong> &emsp;&emsp;&emsp;&emsp;碎牛肉<br>&emsp;&emsp;<strong>recipe</strong> &emsp;&emsp;&emsp;&emsp;食谱；处方；秘诀<br>&emsp;&emsp;<strong>somewhat</strong> &emsp;&emsp;&emsp;&emsp;稍微有点；达到某程度<br>&emsp;&emsp;<strong>in terms of</strong> &emsp;&emsp;&emsp;&emsp;根据；就…而言;在…方面<br>&emsp;&emsp;<strong>manipulate</strong>&emsp;&emsp;&emsp;&emsp; 控制<br>&emsp;&emsp;<strong>fibrous</strong> &emsp;&emsp;&emsp;&emsp;富含纤维的<br>&emsp;&emsp;<strong>exacerbate</strong> &emsp;&emsp;&emsp;&emsp;恶化；使严重<br>&emsp;&emsp;<strong>cholesterol</strong> &emsp;&emsp;&emsp;&emsp;胆固醇<br>&emsp;&emsp;<strong>well-documented</strong>&emsp;&emsp;&emsp;&emsp; 有充分的数据<br>&emsp;&emsp;<strong>revolting</strong> &emsp;&emsp;&emsp;&emsp;使人厌恶的；叛乱的<br>&emsp;&emsp;<strong>sanitation</strong> &emsp;&emsp;&emsp;&emsp;卫生系统或设备<br>&emsp;&emsp;<strong>turn out</strong> &emsp;&emsp;&emsp;&emsp;证实是；结果是<br>&emsp;&emsp;<strong>a tip of iceberg</strong> &emsp;&emsp;&emsp;&emsp;冰山一角<br>&emsp;&emsp;<strong>vice</strong> &emsp;&emsp;&emsp;&emsp;缺陷；恶习<br>&emsp;&emsp;<strong>a slew of</strong> &emsp;&emsp;&emsp;&emsp;许多的<br>&emsp;&emsp;<strong>account for</strong>&emsp;&emsp;&emsp;&emsp;占据<br>&emsp;&emsp;<strong>methane</strong> &emsp;&emsp;&emsp;&emsp;甲烷<br>&emsp;&emsp;<strong>precipitate</strong>&emsp;&emsp;&emsp;&emsp; 使发生；促使<br>&emsp;&emsp;<strong>livestock</strong>&emsp;&emsp;&emsp;&emsp; 牲畜<br>&emsp;&emsp;<strong>antibiotic</strong> &emsp;&emsp;&emsp;&emsp;抗生素<br>&emsp;&emsp;<strong>confine</strong> &emsp;&emsp;&emsp;&emsp;限制<br>&emsp;&emsp;<strong>slaughter</strong> &emsp;&emsp;&emsp;&emsp;屠宰<br>&emsp;&emsp;<strong>embrace</strong> &emsp;&emsp;&emsp;&emsp;拥抱；接受<br>&emsp;&emsp;<strong>infectious disease</strong>&emsp;&emsp;&emsp;&emsp; 传染病<br>&emsp;&emsp;<strong>on the rise</strong>&emsp;&emsp;&emsp;&emsp;在上涨<br>&emsp;&emsp;<strong>hazard</strong>&emsp;&emsp;&emsp;&emsp; 危险，危害<br>&emsp;&emsp;<strong>bodybuilding</strong> &emsp;&emsp;&emsp;&emsp;健美运动<br>&emsp;&emsp;<strong>side effect</strong>&emsp;&emsp;&emsp;&emsp; 副作用<br>&emsp;&emsp;<strong>reservation</strong>&emsp;&emsp;&emsp;&emsp; 保留；保留意见<br>&emsp;&emsp;<strong>extract</strong> &emsp;&emsp;&emsp;&emsp;提取<br>&emsp;&emsp;<strong>additive</strong> &emsp;&emsp;&emsp;&emsp;添加剂<br>&emsp;&emsp;<strong>poll</strong>&emsp;&emsp;&emsp;&emsp; 投票<br>&emsp;&emsp;<strong>cite</strong>&emsp;&emsp;&emsp;&emsp; 引用<br>&emsp;&emsp;<strong>milestone</strong> &emsp;&emsp;&emsp;&emsp;里程碑<br>&emsp;&emsp;<strong>quite</strong> &emsp;&emsp;&emsp;&emsp;确实<br>&emsp;&emsp;<strong>per</strong> &emsp;&emsp;&emsp;&emsp;根据<br>&emsp;&emsp;<strong>diehard</strong> &emsp;&emsp;&emsp;&emsp;顽固分子<br>&emsp;&emsp;<strong>in the wake of</strong> &emsp;&emsp;&emsp;&emsp;尾随；紧跟<br>&emsp;&emsp;<strong>nonetheless</strong> &emsp;&emsp;&emsp;&emsp;(nevertheless)虽然如此，但是<br>&emsp;&emsp;<strong>disrupt</strong>&emsp;&emsp;&emsp;&emsp; 使混乱；破坏；使中断<br>&emsp;&emsp;<strong>sow stock</strong>&emsp;&emsp;&emsp;&emsp; 母猪储量<br>&emsp;&emsp;<strong>piglet</strong> &emsp;&emsp;&emsp;&emsp;小猪<br>&emsp;&emsp;<strong>spiral</strong>&emsp;&emsp;&emsp;&emsp; 螺旋形的<br>&emsp;&emsp;<strong>surge</strong>&emsp;&emsp;&emsp;&emsp; 激增<br>&emsp;&emsp;<strong>factor</strong> &emsp;&emsp;&emsp;&emsp;因素</p><hr>]]></content>
      <categories>
        <category>英语</category>
        <category>晨读</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>晨读</tag>
        <tag>CGTN</tag>
      </tags>
  </entry>
  <entry>
    <title>英语阅读_day_2</title>
    <url>/2020/04/23/%E8%8B%B1%E8%AF%AD%E9%98%85%E8%AF%BB_day_2/</url>
    <content><![CDATA[<h2 id="经济类"><a href="#经济类" class="headerlink" title="经济类"></a>经济类</h2><h3 id="Unit-2"><a href="#Unit-2" class="headerlink" title="Unit 2"></a>Unit 2</h3><a id="more"></a><p>&emsp;&emsp;The American economy has been shedding jobs for nearly two years, but now comes a sign that the gloom could eventually lift. The Bureau of Labour Statistics released new data on payroll employment on Friday December 4th, and across the board the numbers came in better than had been expected.</p><p>&emsp;&emsp;Some 11,000 jobs were lost in November, the smallest total since the recession began late in 2007. And despite the continued job losses, the overall unemployment rate fell from 10.2% to 10.0%. So, too, did broader measures of unemployment which include marginally attached workers and those who work only part time (for economic reasons).</p><p>&emsp;&emsp;The payroll report will leave markets and policymakers happy, for a day at least. Most forecasters had expected that 100,000 jobs, or more, would have been lost, and most thought that the unemployment rate would hold steady or rise. A private employment report for November, which is published just before the official payroll report, showed that nearly 170,000 workers lost their jobs.</p><p>&emsp;&emsp;None of this means that the troubles are all over, however. The unemployment rate had once before declined in 2009, from June to July, before proceeding to rise for the next three months. A steady decline now will be hard to achieve: one estimate suggests that the American economy needs to add around 150,000 jobs each month just to keep up with population growth.</p><p>&emsp;&emsp;Employment growth in the economy remains concentrated in just a few sectors. There are encouraging signs in professional and business services; a 52,000 job increase in temporary help services in this category indicates that employers may soon begin creating more permanent positions.（Although by one measure non-manufacturing businesses are losing confidence, according to an index produced by the Institute for Supply Management this week.） Education, health services, and government are the only other sources of employment growth; the manufacturing, construction, and retail sectors continued to cut jobs in November.</p><p>&emsp;&emsp;That is particularly disappointing given that manufacturing activity has expanded for four consecutive months. More troubling still, the rate of manufacturing expansion declined in November. Increasing activity to data had largely been because of the replenishment of depleted inventories. If this brief spurt of expansion has exhausted itself without creating new jobs, then that bodes ill for recovery in other sources of demand, including consumer spending.</p><p>&emsp;&emsp;And then there are the ugliest statistics of all. Just over 15m Americans are unemployed, an increase of 8m from the start of the recession. Nearly 6m of those are considered long-term unemployed. Almost 40% of jobless workers have been out of work for 27 weeks or more. Bringing most of these workers back into the labour force will require strong economic growth, of the sort that is unlikely to prevail for at least the next year or so. This unexpectedly sharp decline in lost jobs is a silver lining on an extremely dark cloud.</p><hr><blockquote><p><strong>shed</strong> &emsp;&emsp;&emsp;&emsp; v.去除；摆脱；使落下；掉落（货物） n.简易房；工棚，厂<br><strong>lift</strong> &emsp;&emsp;&emsp;&emsp; 移动，移开<br><strong>payroll</strong> &emsp;&emsp;&emsp;&emsp; 薪资表<br><strong>recession</strong> &emsp;&emsp;&emsp;&emsp; 衰退期<br><strong>overall</strong> &emsp;&emsp;&emsp;&emsp; adj.全面的；综合的；总体的 adv.全部；总计；一般来说；大致上 n.工装服<br><strong>marginally</strong> &emsp;&emsp;&emsp;&emsp; adv.少量地；最低限度地<br><strong>work one part time</strong> &emsp;&emsp;&emsp;&emsp; 兼职<br><strong>for a day</strong> &emsp;&emsp;&emsp;&emsp; 就目前来看<br><strong>proceed</strong> &emsp;&emsp;&emsp;&emsp; v.继续进行；接着做；（活动、过程或事件） n.收入，收益<br><strong>estimate</strong> &emsp;&emsp;&emsp;&emsp; n.预测；估算；评价；判断；估算单<br><strong>concertrate</strong> &emsp;&emsp;&emsp;&emsp; 集中（注意力）；使…集中<br><strong>category</strong> &emsp;&emsp;&emsp;&emsp; n.种类；类别<br><strong>manufacturing activity</strong> &emsp;&emsp;&emsp;&emsp; 制造业<br><strong>consecutive</strong> &emsp;&emsp;&emsp;&emsp; adj.连续不断的；接连而来的<br><strong>of the sort</strong> &emsp;&emsp;&emsp;&emsp; 那样的；诸如那样的<br><strong>exhaust</strong> &emsp;&emsp;&emsp;&emsp; v.用尽；耗尽<br><strong>replenishment</strong> &emsp;&emsp;&emsp;&emsp; n.再装满，补充，充满<br><strong>inventory</strong> &emsp;&emsp;&emsp;&emsp; n.清单上的货品，存货<br><strong>spurt</strong> &emsp;&emsp;&emsp;&emsp; n.短暂激增；迸发<br><strong>prevail</strong> &emsp;&emsp;&emsp;&emsp; v.流行，盛行；普遍发生<br><strong>sliver lining</strong> &emsp;&emsp;&emsp;&emsp; （不幸或失望中的）一线希望<br><strong>index</strong> &emsp;&emsp;&emsp;&emsp; n.指标；索引；量度；标志</p></blockquote><hr><h3 id="NOTES"><a href="#NOTES" class="headerlink" title="NOTES"></a>NOTES</h3><hr><p><img src="/2020/04/23/%E8%8B%B1%E8%AF%AD%E9%98%85%E8%AF%BB_day_2/notes_1.jpg" alt><br><img src="/2020/04/23/%E8%8B%B1%E8%AF%AD%E9%98%85%E8%AF%BB_day_2/notes_2.jpg" alt="第 1 遍"></p><hr><p><img src="/2020/04/23/%E8%8B%B1%E8%AF%AD%E9%98%85%E8%AF%BB_day_2/notes_3.jpg" alt><br><img src="/2020/04/23/%E8%8B%B1%E8%AF%AD%E9%98%85%E8%AF%BB_day_2/notes_4.jpg" alt="第 2 遍"></p><hr>]]></content>
      <categories>
        <category>考研</category>
        <category>英语</category>
        <category>阅读</category>
        <category>经济类</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>英语</tag>
        <tag>考研阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>英语阅读_day_1</title>
    <url>/2020/04/19/%E8%8B%B1%E8%AF%AD%E9%98%85%E8%AF%BB_day_1/</url>
    <content><![CDATA[<h2 id="经济类"><a href="#经济类" class="headerlink" title="经济类"></a>经济类</h2><h3 id="Unit-1"><a href="#Unit-1" class="headerlink" title="Unit 1"></a>Unit 1</h3><a id="more"></a><p>&emsp;&emsp;The very loans that are supposed to help seniors stay in their homes are in many cases pushing them out.</p><p>&emsp;&emsp;Reverse mortgages, which allow homeowners 62 and older to borrow money against the value of their homes and not pay it back until they move out or die, have long been fraught with problems. But federal and state regulators are documenting new instances of abuse as smaller mortgage brokers, including former subprime lenders, flood the market after the recent exit of big banks and as defaults on the loans hit record rates.</p><p>&emsp;&emsp;Some lenders are aggressively pitching loans to seniors who cannot afford the fees associated with them, not to mention the property taxes and maintenance. Others are wooing seniors with promises that the loans are free money that can be used to finance long-coveted cruises, without clearly explaining the risks. Some widows are facing eviction after they say they were pressured to keep their name off the deed without being told that they could be left facing foreclosure after their husbands died.</p><p>&emsp;&emsp;Now, as the vast baby boomer generation heads for retirement and more seniors grapple with dwindling savings, the newly minted Consumer Financial Protection Bureau is working on new rules that could mean better disclosure for consumers and stricter supervision of lenders. More than 775,000 of such loans are outstanding, according to the federal government.</p><p>&emsp;&emsp;Concerns about the multibillion-dollar reverse mortgage market echo those raised in the lead-up to the financial crisis when consumers were marketed loans—often carrying hidden risks—that they could not afford.</p><p>&emsp;&emsp;“There are many of the same red flags, including explosive growth and the fact that these loans are often peddled aggressively without regard to suitability,” said Lori Swanson, the Minnesota attorney general, who is working on reforming the reverse mortgage market.</p><hr><blockquote><p><strong>stay in their homes</strong> &emsp;&emsp;&emsp;&emsp; 居有所定<br><strong>mortgage</strong> &emsp;&emsp;&emsp;&emsp; 抵押<br><strong>fraught</strong> &emsp;&emsp;&emsp;&emsp; 充满（令人不满）的；担忧的；忧虑的<br><strong>broker</strong> &emsp;&emsp;&emsp;&emsp; n经纪人v安排，协商（尤指两国之间）<br><strong>subprime lender</strong> &emsp;&emsp;&emsp;&emsp;次贷人<br><strong>flood</strong> &emsp;&emsp;&emsp;&emsp;涌入<br><strong>default</strong> &emsp;&emsp;&emsp;&emsp; 不还债；违约；缺席<br><strong>aggressively</strong> &emsp;&emsp;&emsp;&emsp; 积极地；有进取心地；<br><strong>pitch</strong> &emsp;&emsp;&emsp;&emsp; 投掷；倾斜；搭帐篷<br><strong>maintenance</strong> &emsp;&emsp;&emsp;&emsp; 维护费<br><strong>woo</strong> &emsp;&emsp;&emsp;&emsp; 争取…的支持；追求；恳求<br><strong>long-coveted</strong> &emsp;&emsp;&emsp;&emsp; 觊觎已久的<br><strong>cruise</strong> &emsp;&emsp;&emsp;&emsp; 出游<br><strong>eviction</strong> &emsp;&emsp;&emsp;&emsp; 逐出，赶出；收回<br><strong>deed</strong> &emsp;&emsp;&emsp;&emsp; 行为，行动；（房产的）契约<br><strong>head for</strong> &emsp;&emsp;&emsp;&emsp; 朝…前进<br><strong>grapple</strong> &emsp;&emsp;&emsp;&emsp; 努力克服；抓住；与…争斗<br><strong>dwindle</strong> &emsp;&emsp;&emsp;&emsp; 减少，减小<br><strong>saving</strong> &emsp;&emsp;&emsp;&emsp; 储蓄<br><strong>minted</strong> &emsp;&emsp;&emsp;&emsp; 已完成的；崭新的<br><strong>disclosure</strong> &emsp;&emsp;&emsp;&emsp; 公开；透露<br><strong>outstanding</strong> &emsp;&emsp;&emsp;&emsp; 未偿付的；显著的；未解决的<br><strong>lead-up</strong> &emsp;&emsp;&emsp;&emsp; 前奏<br><strong>market</strong> &emsp;&emsp;&emsp;&emsp; 推销<br><strong>red flags</strong> &emsp;&emsp;&emsp;&emsp; 危险的信号<br><strong>peddle</strong> &emsp;&emsp;&emsp;&emsp; 兜售；散播<br><strong>regard to</strong> &emsp;&emsp;&emsp;&emsp; 顾虑；关于</p></blockquote><hr><h3 id="NOTES"><a href="#NOTES" class="headerlink" title="NOTES"></a>NOTES</h3><hr><p><img src="/2020/04/19/%E8%8B%B1%E8%AF%AD%E9%98%85%E8%AF%BB_day_1/notes_1.jpg" alt="第 1 遍"></p><hr><p><img src="/2020/04/19/%E8%8B%B1%E8%AF%AD%E9%98%85%E8%AF%BB_day_1/notes_2.jpg" alt="第 2 遍"></p><hr><hr><ol><li><p>The very loans that are supposed to help seniors stay in their homes are in many cases pushing them out.<br>&emsp;&emsp;主干： The very loans pushing them out.<br>&emsp;&emsp;that引导的定语从句修饰loans<br>&emsp;&emsp;be supposed to 主语为“人”，means “应该；被期望” 主语为“物”，means“本应；本该”<br>&emsp;&emsp;stay in their homes 居有定所<br>&emsp;&emsp;in many cases 作状语<br>&emsp;&emsp;翻译：那些本应该帮助老年人居有定所的贷款，在很多情况下，却使得他们居无定所。</p></li><li><p>Reverse mortgages,which allow homeowners 62 and older to borrow money against the value of their homes and not pay it back until they move out or die,have long been fraught with problems.<br>&emsp;&emsp;主干： Reverse mortgages have long been fraught with problems.<br>&emsp;&emsp;which 引导的定语从句修饰 reverse mortgages<br>&emsp;&emsp;borrow 和 pay 并列<br>&emsp;&emsp;翻译：反向抵押贷款允许62岁及以上的屋主以房子作抵押来借钱，直到他们搬走或逝去再偿还。这种方式的反向抵押贷款一直问题重重。</p></li><li><p>But federal and state regulators are documenting new instances of abuse as smaller mortgage brokers,including former subprimer lenders,flood the market after the recent exit of big banks and as defaults on the loans hit record rates.<br>&emsp;&emsp;主干：Federal and state regulators are documenting new instances of abuse.<br>&emsp;&emsp;as 引导状语从句<br>&emsp;&emsp;状语从句中 主干：Smaller mortgage brokers flood the market and as defaults &emsp;&emsp;on the loans hit record rates.<br>&emsp;&emsp;including former subprimer lenders 修饰 smaller mortgage brokers<br>&emsp;&emsp;翻译：然而，随着一些业务规模较小的抵押代理人，包括之前的一些次贷方，在近期大银行退出后涌入市场，以及贷款拖欠的情况屡创新高，联邦政府和各州的调控机构正在记载新的滥用案例。</p></li><li><p>Some lenders are aggressively pitching loans to seniors who cannot afford the fees associated with them, not to mention the property taxes and maintenance.<br>&emsp;&emsp;主干：Some lenders are pitching loans to seniors.<br>&emsp;&emsp;who 引导定语从句修饰 seniors<br>&emsp;&emsp;associate v.联想；联系；使与..有关系；公开支持；与…交往；与…为伍 a.副的；准的 n.（尤指）同事；合伙人；伙伴<br>&emsp;&emsp;不定式 作状语<br>&emsp;&emsp;翻译：一些贷款方积极地将钱贷款给那些无力自己支付贷款相关费用的老年人，更不用说财产税和维护费。</p></li><li><p>Others are wooing seniors with promises that the loans are free money that can be used to finance long-conveted crusises,without clearly explaining the risks.<br>&emsp;&emsp;主干：Others are wooing seniors with promises.<br>&emsp;&emsp;that 引导的从句修饰promises<br>&emsp;&emsp;without clearly explaining the risks 作状语<br>&emsp;&emsp;finance v.提供资金；资助 n.财政；财务状况<br>&emsp;&emsp;翻译：另一些人在争取老年人的同时没有清楚地解释贷款风险，只是承诺贷款是免费的，可以用来支付他们觊觎已久的出游。</p></li><li><p>Some widows are facing eviction after they say they<br>were pressured to keep their name off the deed without being told that they<br>could be left facing foreclosure after their husbands died.<br>&emsp;&emsp;主干：Some widows are facing eviction.<br>&emsp;&emsp;after + … 作状语<br>&emsp;&emsp;say 后省略了that， that 引导宾语从句<br>&emsp;&emsp;keep … off … 使…不在…上<br>&emsp;&emsp;forclosure 丧失抵押品赎回权<br>&emsp;&emsp;翻译：一些孤寡妇人称，当初她们是被迫不让自己的名字出现在合约上，但并没有被告知，如果她们的丈夫离世她们将会面临丧失抵押品赎回权，现在她们正在面临驱逐出自己房子的困境。</p></li><li><p>Now, as the vast baby boomer generation heads for retirement and more seniors grapple with dwindling savings, the newly minted Consumer Financial Protection Bureau is working on new rules that could mean better disclosure for consumers and stricter supervision of lenders.<br>&emsp;&emsp;主干：CFPB is working on new rules.<br>&emsp;&emsp;翻译：目前，随着大量婴儿潮时代出生的人进入退休阶段以及一些老年人正在解决积蓄减少这一问题。新成立的消费者金融保护局开始制定新的政策，这一措施可以使消费者有更好的知情权，并且借贷方将面临严格的监管。</p></li><li><p>More than 775,000 of such loans are outstanding, according to the federal government.<br>&emsp;&emsp;主干：More than 775,000 of such loans are outstanding.<br>&emsp;&emsp;翻译：据联邦政府透露，超过775000的借款人未偿还贷款.</p></li><li><p>Concerns about the multibillion-dollar reverse mortgage market echo those raised in the lead-up to the financial crisis when consumers were marketed loans—-often carrying hidden risks—that they could not afford.<br>&emsp;&emsp;主干： Concerns echo those.<br>&emsp;&emsp;翻译：对于百万元的反向抵押市场的担忧使人们联想起财政危机的前奏，那时的借款人没有能力支付贷款，并且这些贷款携带着隐藏的风险。</p></li><li><p>“There are many of the same red flags, including explosive growth and the fact that these loans are often peddled aggressively without regard to suitability.”<br>&emsp;&emsp;主干：There are many of the same red flags.<br>&emsp;&emsp;翻译：有很多这样的危险信号，包括爆炸性增长，包括积极兜售贷款并没有顾虑是否适合.</p></li></ol><hr>]]></content>
      <categories>
        <category>考研</category>
        <category>英语</category>
        <category>阅读</category>
        <category>经济类</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>英语</tag>
        <tag>考研阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>review_英语单词_day_1</title>
    <url>/2020/04/18/review_%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D_day_1/</url>
    <content><![CDATA[<h2 id="List-19"><a href="#List-19" class="headerlink" title="List 19"></a>List 19</h2><h2><a href="#" class="headerlink"></a><a id="more"></a></h2><h3 id="Page-356-357"><a href="#Page-356-357" class="headerlink" title="Page(356-357)"></a>Page(356-357)</h3><ol><li>interim</li><li>jury</li><li>line-up</li><li>medicaid</li><li>monthly</li><li>occasionally</li><li>overly</li><li>persuasion</li><li>address</li><li>offset</li><li>long-standing</li><li>refocus</li><li>revelation</li><li>reveal</li><li>astonishing</li><li>inherent</li><li>inherently</li><li>inherit</li><li>scattered</li><li>silly</li><li>spirit</li><li>successive</li><li>succession</li><li>preside over</li><li>squeeze</li><li>dicline</li><li>tragedy</li><li>unemployed</li></ol><hr><h3 id="Page-358-359"><a href="#Page-358-359" class="headerlink" title="Page(358-359)"></a>Page(358-359)</h3><ol><li>upstart</li><li>as the old saying goes</li><li>entrepreneur</li><li>prestige</li><li>wealthy</li><li>workday</li><li>circuit</li><li>Federal Cricuit</li><li>curb</li><li>dramatic</li><li>about-face</li><li>introduce</li><li>approve</li><li>pool</li><li>divide</li><li>divisive</li><li>involve</li><li>involved</li><li>pocket</li><li>source</li><li>day-to-day experience</li><li>soul-crashingly hard</li><li>dampen</li><li>arm</li><li>document</li><li>poet</li><li>poetry</li><li>around</li><li>domain</li><li>dome</li></ol><hr><h3 id="Page-360-361"><a href="#Page-360-361" class="headerlink" title="Page(360-361)"></a>Page(360-361)</h3><ol><li>point</li><li>point-and-click</li><li>miss the point</li><li>beside the point</li><li>selling point</li><li>pointed</li><li>arrange</li><li>arrangement</li><li>irrelevent</li><li>pointless</li><li>ridge</li><li>community</li><li>compromise</li><li>irresponsibility</li><li>poison</li><li>poisonous</li><li>span</li><li>attention span</li><li>arrival</li><li>issue</li><li>abbreviation</li><li>article</li><li>hand out</li><li>hand in</li><li>hand over</li><li>hand in hand</li><li>pole</li><li>righteous</li><li>spear</li></ol><hr><h2 id="Sentence"><a href="#Sentence" class="headerlink" title="Sentence"></a>Sentence</h2><ol><li><p>USFWS also set a interim goal for restoring prairie chicken populations to an annual average of 67000 birds over the next 10 years.</p></li><li><p>Relying on ethical persuasion rather than law to address the misuse of body ideals may be the best step.</p></li><li><p>The latter step would largely offset the financial burden of anunally pre-funding retiree health care,thus addressing a long-standing complaint by the OSPS and its union.</p></li><li><p>One of the astonishing revelations was how little she knew of what went on in her newsroom,how little she thought to ask and the fact that she never inquired how the stories arrived.</p></li><li><p>The goals of prize-givers seem as scattered as criticism.</p></li><li><p>But successive governments have presided over selling green spaces,squeezing money from local authorities and declining attention on sport in education.</p></li><li><p>You cannot buy class,as the old saying goes,and these upstart entrepreneurs cannot buy their prizes the prestige of Nobels.</p></li><li><p>Curbs on bussiness-method claims would be a dramatic about-face,because it was the Federal Circuit itself that introduced such patents with its 1998 desicion in the so-called State Street Bank case, approving a patent on a way of pooling mutual-fund assets.</p></li><li><p>Even though the day-to-day experience of rasing kids can be soul-crashingly hard,Senior writes that “the very things that in the moment dampen our moods can later be source of intense gratification and delight.”</p></li><li><p>Citizens still have a right to expect private documents to remain private and protected by the Consitution’s prohibition on unresonable searches.</p></li><li><p>Devoted concertgoers who reply that recordings are no subsitute for live performance are missing the point.</p></li><li><p>The astronomy community is making compromises to change its use of Mauna Kea.</p></li><li><p>G.I. is just a military abbreviation meaning Government Issure,and it was on all of the articles handed out to soldiers.</p></li></ol><hr>]]></content>
      <categories>
        <category>考研</category>
        <category>英语</category>
        <category>单词</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>英语</tag>
        <tag>考研单词</tag>
      </tags>
  </entry>
  <entry>
    <title>英语单词_day_1</title>
    <url>/2020/04/18/%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D_day_1/</url>
    <content><![CDATA[<h2 id="List-19"><a href="#List-19" class="headerlink" title="List 19"></a>List 19</h2><hr><a id="more"></a><h3 id="Page-356-357"><a href="#Page-356-357" class="headerlink" title="Page(356-357)"></a>Page(356-357)</h3><ol><li><p><strong>interim</strong> &emsp;&emsp;&emsp;&emsp; 临时的，暂时的<br>&emsp;&emsp;<code>inter-</code> 两者之间的&emsp;&emsp;&emsp;&emsp;<code>rim-</code> 边<br>&emsp;&emsp;“在两者之间擦边而过，停留片刻的”</p><blockquote><p>USFWS also set an interim goal of restoring prairie chicken(草原榛鸡.北美产) populations to an annual average of 67000 birds over the next 10 years.</p></blockquote></li><li><p><strong>jury</strong> &emsp;&emsp;&emsp;&emsp; 陪审团<br>&emsp;&emsp;<code>jur-</code> 法律；公正&emsp;&emsp;&emsp;&emsp;<code>ry-</code> 集合名词后缀<br>&emsp;&emsp;“维护法律公正的一群人”</p></li><li><p><strong>line-up</strong> &emsp;&emsp;&emsp;&emsp; 队列，阵容；一组（人）；一排；电视节目的时刻表<br>&emsp;&emsp;<code>line-</code> 线、排&emsp;&emsp;&emsp;&emsp;<code>up-</code> 上<br>&emsp;&emsp;“一个接一个地排上”</p></li><li><p><strong>medicaid</strong> &emsp;&emsp;&emsp;&emsp;医疗救助计划，医疗补助制度<br>&emsp;&emsp;<code>medic-</code>医学的、医药的&emsp;&emsp;&emsp;&emsp;<code>aid-</code> 援助、帮助</p></li><li><p><strong>monthly</strong>&emsp;&emsp;&emsp;&emsp;每月地，按月地；月刊</p></li><li><p><strong>occasionally</strong> &emsp;&emsp;&emsp;&emsp;偶然地；偶尔地</p></li><li><p><strong>overly</strong> &emsp;&emsp;&emsp;&emsp;极度地；过度地</p></li><li><p><strong>persuasion</strong>&emsp;&emsp;&emsp;&emsp;劝告，说服；信仰，信念</p><blockquote><p>Relying on ethical persuasion rather than law to address the misuse of body ideals may be the best step.</p></blockquote></li><li><p><strong>address</strong>&emsp;&emsp;&emsp;&emsp;地址；演讲；对付，处理</p><blockquote><p>The latter step would largely offset the financial burden of anunally pre-funding retiree health care,thus addressing a long-standing complaint by the OSPS and its union.</p></blockquote></li><li><p><strong>offset</strong> &emsp;&emsp;&emsp;&emsp;抵消；补偿；分支</p></li><li><p><strong>long-standing</strong>&emsp;&emsp;&emsp;&emsp;长期存在的</p></li><li><p><strong>refocus</strong>&emsp;&emsp;&emsp;&emsp;重新聚焦，重新关注</p></li><li><p><strong>revelation</strong>&emsp;&emsp;&emsp;&emsp; 揭露；内情；启示<br>&emsp;&emsp;<code>revel- = reveal-</code> 揭露，展现</p><blockquote><p>One of the astonishing revelations was how little she knew of what went on in her newsroom,how little she thought to ask and the fact that she never inquired how the stories arrived.</p></blockquote></li><li><p><strong>astonishing</strong>&emsp;&emsp;&emsp;&emsp;令人吃惊的</p></li><li><p><strong>inherent</strong>&emsp;&emsp;&emsp;&emsp;内在的，固有的；与生俱来的<br>&emsp;&emsp;<code>in-</code> 在内&emsp;&emsp;&emsp;&emsp;<code>her-</code> 粘粘，粘附&emsp;&emsp;&emsp;&emsp; <code>ent-</code> adj后缀<br>&emsp;&emsp;“在内心里、骨子里就有的”<br><strong>inherently</strong>&emsp;&emsp;&emsp;&emsp;内在地，固有地；天生地<br><strong>inherit</strong> &emsp;&emsp;&emsp;&emsp;继承（传统的）；经过遗传而得到的（性格等）</p></li><li><p><strong>scattered</strong>&emsp;&emsp;&emsp;&emsp;分散的，散布的；遍布的<br>&emsp;&emsp;<code>scat- = sect-</code> 切，割</p><blockquote><p>The goals of prize-givers seem as scattered as criticism.</p></blockquote></li><li><p><strong>silly</strong>&emsp;&emsp;&emsp;&emsp;愚蠢的；没头脑的<br>&emsp;&emsp;<code>sil- = smile-</code> 笑<br>&emsp;&emsp;原指“笑的无忧无虑”，后引申为“愚蠢的,荒唐的”</p></li><li><p><strong>spirit</strong>&emsp;&emsp;&emsp;&emsp;精神；灵魂；情绪<br>&emsp;&emsp;<code>spir-</code> 呼吸&emsp;&emsp;&emsp;&emsp;<code>it-</code> 名词后缀<br>&emsp;&emsp;“精神”</p></li><li><p><strong>successive</strong> &emsp;&emsp;&emsp;&emsp;连续的，接连的；继承的<br>&emsp;&emsp;<code>succession-</code>&emsp;&emsp;&emsp;&emsp;连续；继位</p><blockquote><p>But successive governments have presided over selling green spaces,squeezing money from local authorities and declining attention on sport in education.</p></blockquote><p><strong>preside over</strong>&emsp;&emsp;&emsp;&emsp;主持（仪式、会议等）；管理<br><strong>squeeze</strong>&emsp;&emsp;&emsp;&emsp;压榨<br><strong>decline</strong>&emsp;&emsp;&emsp;&emsp;下降</p></li><li><p><strong>tragedy</strong>&emsp;&emsp;&emsp;&emsp;灾难；悲剧<br>&emsp;&emsp;<code>tra- = trans-</code> 转&emsp;&emsp;&emsp;&emsp;<code>ged- = goat-</code> 山羊</p></li><li><p><strong>unemployed</strong> &emsp;&emsp;&emsp;&emsp;未被雇佣的；失业的</p></li></ol><hr><h3 id="Page-358-359"><a href="#Page-358-359" class="headerlink" title="Page(358-359)"></a>Page(358-359)</h3><ol><li><p><strong>upstart</strong> &emsp;&emsp;&emsp;&emsp; 暴发户；（初出茅庐的）自命不凡的人<br>&emsp;&emsp;<code>up-</code> 向上 &emsp;&emsp;&emsp;&emsp; <code>start-</code> 开始<br>&emsp;&emsp;“开始向上的人”</p><blockquote><p>You cannot buy class,as the old saying goes,and these upstart entrepreneurs cannot buy their prizes the prestige of the Nobels.</p></blockquote><p><strong>as the old saying goes</strong> &emsp;&emsp;&emsp;&emsp;俗话说<br><strong>entrepreneur</strong> &emsp;&emsp;&emsp;&emsp; 创业者，企业家（尤指涉及财政风险）<br><strong>prestige</strong> &emsp;&emsp;&emsp;&emsp;声望</p></li><li><p><strong>wealthy</strong> &emsp;&emsp;&emsp;&emsp; 富有的<br>&emsp;&emsp;<code>wealth-</code> 财富；富有</p></li><li><p><strong>workday</strong> &emsp;&emsp;&emsp;&emsp; 工作日</p></li><li><p><strong>circuit</strong> &emsp;&emsp;&emsp;&emsp; 环道，环形；电路<br>&emsp;&emsp;<code>circ- = circle-</code> 圆，环&emsp;&emsp;&emsp;&emsp;<code>it-</code> 走</p><blockquote><p>Curbs on business-method claims would be a dramatic about-face,because it was the Fedaral Circuit itself that introduced such patents with its 1998 desicion in the so-called State Street Bank case,approving a patent on a way of pooling mutual-fund assets.</p></blockquote><p><strong>the U.S. Court of Appeals for the Fedaral Circuit</strong> &emsp;&emsp;&emsp;&emsp; 美国联邦巡回法庭上诉法院<br><strong>Curb</strong>&emsp;&emsp;&emsp;&emsp;限制<br><strong>about-face</strong>&emsp;&emsp;&emsp;&emsp;（态度、观点）彻底改变，大转变<br><strong>introduce</strong> &emsp;&emsp;&emsp;&emsp; 引入<br><strong>approve</strong>&emsp;&emsp;&emsp;&emsp;批准；通过，许可； 赞同；赞许<br><strong>pool</strong> &emsp;&emsp;&emsp;&emsp;合理经营；集中资源；联合投资</p></li><li><p><strong>divide</strong> &emsp;&emsp;&emsp;&emsp; 分割，划分<br>&emsp;&emsp;<code>di = de-</code> 分开，一分为二&emsp;&emsp;&emsp;&emsp;<code>vid-</code> 看<br><strong>divisive</strong> &emsp;&emsp;&emsp;&emsp; 不和的，分裂的；区分的</p></li><li><p><strong>involve</strong> &emsp;&emsp;&emsp;&emsp; 卷入，连累；涉及；参与<br><strong>involved</strong> &emsp;&emsp;&emsp;&emsp; 混乱的；涉及的，牵连的</p></li><li><p><strong>pocket</strong> &emsp;&emsp;&emsp;&emsp;口袋；容器；把..装入袋内；袖珍的，小型的</p></li><li><p><strong>source</strong> &emsp;&emsp;&emsp;&emsp; 源泉；来源</p><blockquote><p>Even though the day-to-day experience of rasing kids can be soul-curshingly hard,Senior writes that “the very things that in the moment dampen our moods can later be sources of intense gratification and delight.”</p></blockquote><p><strong>uncertain source</strong> &emsp;&emsp;&emsp;&emsp;不明来源<br><strong>day-to-day experience</strong> &emsp;&emsp;&emsp;&emsp;日常生活<br><strong>soul-crashingly hard</strong> &emsp;&emsp;&emsp;&emsp;心力交瘁<br><strong>dampen</strong> &emsp;&emsp;&emsp;&emsp;抑制、降低（热情、激动）</p></li><li><p><strong>arm</strong>&emsp;&emsp;&emsp;&emsp; 手臂；武器；武装起来<br><strong>arm…with…</strong>&emsp;&emsp;&emsp;&emsp; 用…武装…</p></li><li><p><strong>document</strong> &emsp;&emsp;&emsp;&emsp;文献；公文，文件；记载</p><blockquote><p>Citizens still have a right to expect private documents to remain private and protected by the Consitution’s prohibition on unresonable searches.</p></blockquote></li><li><p><strong>poet</strong> &emsp;&emsp;&emsp;&emsp; 诗人<br><strong>poetry</strong> &emsp;&emsp;&emsp;&emsp;诗歌</p></li><li><p><strong>around</strong> &emsp;&emsp;&emsp;&emsp; adv.环绕，循环地；到处 prep.在…周围；绕过<br><strong>around the world</strong> &emsp;&emsp;&emsp;&emsp;全世界</p></li><li><p><strong>domain</strong> &emsp;&emsp;&emsp;&emsp;领土；（学术、行业）领域<br>&emsp;&emsp;<code>dom- = dome-</code> 屋顶&emsp;&emsp;&emsp;&emsp;<code>a-</code> 一&emsp;&emsp;&emsp;&emsp;<code>in-</code> 在里面<br><strong>Under The Dome</strong> &emsp;&emsp;&emsp;&emsp; 穹顶之下</p></li></ol><hr><h3 id="Page-360-361"><a href="#Page-360-361" class="headerlink" title="Page(360-361)"></a>Page(360-361)</h3><ol><li><p><strong>point</strong> &emsp;&emsp;&emsp;&emsp;点；要点；分数；指出</p><blockquote><p>Devoted concertgoers who reply that recordings are no subsitute for live performance are missing the point.</p></blockquote><p><strong>point-and-click</strong> &emsp;&emsp;&emsp;&emsp;快速点击<br><strong>miss the point</strong> &emsp;&emsp;&emsp;&emsp;没领会要点<br><strong>beside the point</strong> &emsp;&emsp;&emsp;&emsp;不相关；不中肯<br><strong>selling point</strong> &emsp;&emsp;&emsp;&emsp;卖点<br><strong>pointed</strong> &emsp;&emsp;&emsp;&emsp;尖锐的；率直的</p></li><li><p><strong>arrange</strong> &emsp;&emsp;&emsp;&emsp; 安排；整理，布置<br><strong>arrangement</strong> &emsp;&emsp;&emsp;&emsp; 布置；准备</p></li><li><p><strong>irrelevant</strong> &emsp;&emsp;&emsp;&emsp;不相干的；不恰当的<br>&emsp;&emsp;<code>ir-</code> 否定前缀 &emsp;&emsp;&emsp;&emsp; <code>relevant-</code> 有关的，相应的</p></li><li><p><strong>pointless</strong> &emsp;&emsp;&emsp;&emsp; 无意义的<br>&emsp;&emsp;<code>point-</code> 点，要点 &emsp;&emsp;&emsp;&emsp; <code>less-</code> 否定，adj后缀<br>&emsp;&emsp;“话说不到点子上”</p></li><li><p><strong>ridge</strong> &emsp;&emsp;&emsp;&emsp;山脉，山岭；屋脊<br>&emsp;&emsp;<code>ri- = rise-</code> 升起&emsp;&emsp;&emsp;&emsp;<code>dge- = edge-</code> 边缘</p></li><li><p><strong>community</strong>&emsp;&emsp;&emsp;&emsp;社区；团体；界<br>&emsp;&emsp;<code>commun- = common-</code> 公有的，公众的&emsp;&emsp;&emsp;&emsp;<code>ity-</code> 名词后缀<br>&emsp;&emsp;“所公共生活的地方”</p><blockquote><p>The astronomy community is making compromises to change its use of Mauna Kea.</p></blockquote><p><strong>community service</strong> &emsp;&emsp;&emsp;&emsp; 社区服务<br><strong>health research community</strong> &emsp;&emsp;&emsp;&emsp; 健康研究团体<br><strong>scientific community</strong> &emsp;&emsp;&emsp;&emsp; 科学界<br><strong>compromise</strong> &emsp;&emsp;&emsp;&emsp; 妥协；让步；使（自己）名誉受损；违背（信念）</p></li><li><p><strong>irresponsibility</strong>&emsp;&emsp;&emsp;&emsp; 不负责任</p></li><li><p><strong>poison</strong> &emsp;&emsp;&emsp;&emsp; 毒药；毒害<br>&emsp;&emsp;<code>pois-</code> 由person-和death-组合而成&emsp;&emsp;&emsp;&emsp; <code>on- = ion-</code> 名词后缀<br><strong>poisonous</strong>&emsp;&emsp;&emsp;&emsp;有毒的；有害的；恶毒的</p></li><li><strong>span</strong>&emsp;&emsp;&emsp;&emsp; 跨度，跨距；一段时间<br><strong>attention span</strong> &emsp;&emsp;&emsp;&emsp;注意力持续时间</li><li><p><strong>arrival</strong> &emsp;&emsp;&emsp;&emsp; 到达；到达的人（或物）<br>&emsp;&emsp;<code>ar-</code> 加强语气&emsp;&emsp;&emsp;&emsp;<code>rival-</code> 对手<br><strong>arrive**</strong> &emsp;&emsp;&emsp;&emsp;到达，到来<br>arrive at | arrive in</p></li><li><p><strong>issue</strong> &emsp;&emsp;&emsp;&emsp; v发布，发行；出版； n问题；发放<br>&emsp;&emsp;<code>is- = es-</code> 向外，出来 &emsp;&emsp; &emsp;&emsp;<code>su- = send-</code>发送</p><blockquote><p>G.I. is just a military abbreviation meaning Government Issue, and it was on all of the articles handed out to soldiers.</p></blockquote><p><strong>management issue</strong>&emsp;&emsp;&emsp;&emsp; 管理问题<br><strong>issue a report</strong> &emsp;&emsp;&emsp;&emsp; 发布一篇报告<br><strong>abbreviation</strong> &emsp;&emsp;&emsp;&emsp; 缩写词，缩略形式<br><strong>article</strong> &emsp;&emsp;&emsp;&emsp;物品；文章<br><strong>hand out</strong> &emsp;&emsp;&emsp;&emsp;分发；散发；给与（忠告，许可等）<br><strong>**hand in</strong> &emsp;&emsp;&emsp;&emsp;上交（作业，拾到某物等）；递交（辞呈）；提出（辞职）<br><strong>hand over</strong> &emsp;&emsp;&emsp;&emsp;转交；递交；移交（犯人等）；（把…）移交（给…）处理<br><strong>hand in hand**</strong> &emsp;&emsp;&emsp;&emsp;手拉着手的</p></li><li><p><strong>pole</strong> &emsp;&emsp;&emsp;&emsp; 杆，柱，棒；（地球的）极<br>&emsp;&emsp;<code>bole-</code> 树干</p></li><li><p><strong>righteous</strong> &emsp;&emsp;&emsp;&emsp;正直的，正当的；公正的</p></li><li><p><strong>spear</strong> &emsp;&emsp;&emsp;&emsp;矛，标枪；用矛刺，用标枪叉<br>&emsp;&emsp;<code>s- = slim-</code> 细长的 &emsp;&emsp;&emsp;&emsp;<code>pe- = pin-</code> 尖，刺&emsp;&emsp;&emsp;&emsp; <code>ar-</code>表物<br>&emsp;&emsp;“带尖儿的长兵器”</p></li></ol><hr><h3 id="Page-362-363"><a href="#Page-362-363" class="headerlink" title="Page(362-363)"></a>Page(362-363)</h3><ol><li><p><strong>doom</strong> &emsp;&emsp;&emsp;&emsp; n 厄运，劫数；毁灭；世界末日 v 注定；使失败，使毁灭</p><blockquote><p>But policymakers who refocus efforts on improving well-being rather than simply worrying about GDP figures could avoid the forecasted doom and may even see progress.</p></blockquote><p><strong>well-being</strong>&emsp;&emsp;&emsp;&emsp;健康；安乐；安康</p></li><li><p><strong>item</strong>&emsp;&emsp;&emsp;&emsp;条，条款；（新闻的）一条，一则；物件，物体<br>&emsp;&emsp;<code>i-</code> 加强语气&emsp;&emsp;&emsp;&emsp;<code>te- = tain-</code> 拿住&emsp;&emsp;&emsp;&emsp;<code>m- = matter-</code> 东西</p></li><li><p><strong>policy</strong>&emsp;&emsp;&emsp;&emsp;政策，方针<br>&emsp;&emsp;<code>pol- = pole-</code> 棒&emsp;&emsp;&emsp;&emsp;<code>cy- = country-</code> 国家<br>&emsp;&emsp;“国家的指挥棒”<br><strong>political</strong>&emsp;&emsp;&emsp;&emsp;政治（上）的；对政治感兴趣的<br><strong>politician</strong>&emsp;&emsp;&emsp;&emsp;政治家；通晓政治的人（poli-=policy tic-的 an-人）<br><strong>politics</strong>&emsp;&emsp;&emsp;&emsp;政治，政治学；政见（ics- 学科）<br><strong>political science</strong>&emsp;&emsp;&emsp;&emsp;政治学<br><strong>political stand</strong>&emsp;&emsp;&emsp;&emsp;政治立场<br><strong>political view</strong>&emsp;&emsp;&emsp;&emsp;政治观点</p></li><li><p><strong>rim</strong> &emsp;&emsp;&emsp;&emsp;边，边缘；眼镜框<br>&emsp;&emsp;<code>rim-</code>边，边缘 由ring-环 演变而来</p></li><li><p><strong>arrow</strong>&emsp;&emsp;&emsp;&emsp;箭，箭状物；箭头<br>&emsp;&emsp;<code>ar-</code> 加强语气&emsp;&emsp;&emsp;&emsp;<code>row- = throw-</code> 投掷，发射，扔<br>&emsp;&emsp;“在战场上用来投掷、发射的东西”<br><strong>Cupid Arrow</strong>&emsp;&emsp;&emsp;&emsp;爱神之箭</p></li><li><p><strong>compare</strong>&emsp;&emsp;&emsp;&emsp;比较，相比；比喻<br>&emsp;&emsp;<code>com- = common-</code> 共同，一起&emsp;&emsp;&emsp;&emsp;<code>par-</code> 生，产生<br><strong>compare with | compare to</strong><br><strong>comparative</strong>&emsp;&emsp;&emsp;&emsp;比较的；相比较而言的<br><strong>comparatively</strong>&emsp;&emsp;&emsp;&emsp;比较地；相对地<br><strong>comparison</strong> &emsp;&emsp;&emsp;&emsp; 比较，对照；类似；比喻</p><blockquote><p>But a comparative study of linguistic traits published online supplies a reality check.</p></blockquote><p><strong>comparative method</strong>&emsp;&emsp;&emsp;&emsp;比较法<br><strong>trait</strong>&emsp;&emsp;&emsp;&emsp;特征；特点；特性</p></li><li><p><strong>policymaker</strong>&emsp;&emsp;&emsp;&emsp;决策者</p></li><li><p><strong>species</strong>&emsp;&emsp;&emsp;&emsp;种类；物种<br><strong>group-living species</strong> &emsp;&emsp;&emsp;&emsp;群居物种</p></li><li><p><strong>art</strong> &emsp;&emsp;&emsp;&emsp;艺术（品），美术（品）；技艺，技术<br><strong>anti-happy art</strong>&emsp;&emsp;&emsp;&emsp;反对快乐的艺术（anti- 反抗）<br><strong>artist</strong>&emsp;&emsp;&emsp;&emsp;艺术家，美术家（ist- 表人）<br><strong>artistic</strong>&emsp;&emsp;&emsp;&emsp;艺术家的；有艺术才能的<br><strong>artwork</strong> &emsp;&emsp;&emsp;&emsp;艺术品（work- 工作；产品）</p></li><li><p><strong>compass</strong> &emsp;&emsp;&emsp;&emsp;v 包围 n 指南针；罗盘；圆规</p></li></ol><hr><h3 id="Page-364-365"><a href="#Page-364-365" class="headerlink" title="Page(364-365)"></a>Page(364-365)</h3><ol><li><p><strong>pool</strong>&emsp;&emsp;&emsp;&emsp;n 共用物；共同储金；联合投资 v 合理经营；集中资源</p></li><li><p><strong>rip</strong>&emsp;&emsp;&emsp;&emsp;v 撕、劈；撕裂，裂开； n 裂口，裂缝<br>&emsp;&emsp;rip- 由reap-收割 演变而来</p></li><li><p><strong>arthritis</strong>&emsp;&emsp;&emsp;&emsp;关节炎<br>&emsp;&emsp;<code>arthr- = articulate-</code>用关节连接&emsp;&emsp;&emsp;&emsp;<code>itis-</code> 名词后缀，表“病”<br><strong>arthritis drug</strong>&emsp;&emsp;&emsp;&emsp;关节炎药物<br><strong>articulate</strong>&emsp;&emsp;&emsp;&emsp;善于表达的；口齿清晰的； v 清楚地表达（思想或感情）；清楚地说出</p></li><li><p><strong>ripe</strong>&emsp;&emsp;&emsp;&emsp;成熟的；时机成熟的<br>&emsp;&emsp;<code>ri- = rice-</code> 稻米，粮食&emsp;&emsp;&emsp;&emsp;<code>pe- = plant-</code>种植</p></li><li><p><strong>article</strong>&emsp;&emsp;&emsp;&emsp;文章，论文；条文；（物品的）一件；物品</p></li><li><p><strong>popular</strong>&emsp;&emsp;&emsp;&emsp;民众的；大众的，流行的<br><strong>popularity</strong>&emsp;&emsp;&emsp;&emsp;普及，流行；大众化<br><strong>popularize</strong>&emsp;&emsp;&emsp;&emsp;普及，使流行；是大众化<br><strong>enjoy the widest popularity</strong>&emsp;&emsp;&emsp;&emsp;最受欢迎的</p><blockquote><p>But embarrassing scandals and the popularity of the republican left in recent Euro-elections have forced him to eat his words and stand down.</p></blockquote><p><strong>republican</strong>&emsp;&emsp;&emsp;&emsp;共和主义者；共和的<br><strong>eat one’s words</strong>&emsp;&emsp;&emsp;&emsp;食言<br><strong>stand down</strong>&emsp;&emsp;&emsp;&emsp;(从重要职位上)退下，下台(常为了让位给别人)</p></li><li><p><strong>rise</strong>&emsp;&emsp;&emsp;&emsp;升起；起立；上涨<br><strong>on the rise</strong>&emsp;&emsp;&emsp;&emsp;在上升；在增长；正在兴起<br><strong>arise</strong>&emsp;&emsp;&emsp;&emsp;升起；产生，出现（指一种抽象的升起或出现）<br><strong>arouse</strong>&emsp;&emsp;&emsp;&emsp;唤醒；唤起（指人或动物被唤醒或唤起）</p></li><li><p><strong>downgrade</strong>&emsp;&emsp;&emsp;&emsp;使下降；使降级<br>&emsp;&emsp;<code>down-</code> 向下&emsp;&emsp;&emsp;&emsp;<code>grade-</code> 等级</p></li><li><p><strong>population</strong>&emsp;&emsp;&emsp;&emsp;人口；（某区域的）全部居民<br><strong>populate</strong> &emsp;&emsp;&emsp;&emsp;居住于；移民于，殖民于<br><strong>aging population</strong>&emsp;&emsp;&emsp;&emsp;老年人口；人口老龄化</p></li><li><p><strong>aside</strong>&emsp;&emsp;&emsp;&emsp;adv 在旁边；到旁边 n （戏剧等中的）旁白</p></li><li><p><strong>evaluate</strong>&emsp;&emsp;&emsp;&emsp;估价；评价，鉴定；求…的数值<br>&emsp;&emsp;<code>e-</code>向外，出来 &emsp;&emsp;&emsp;&emsp;<code>valu- = value-</code> 价值&emsp;&emsp;&emsp;&emsp;<code>ate-</code> 动词后缀<br>&emsp;&emsp; “将价值估算出来”</p><blockquote><p>The Federal Circuit issued an unusual order stating that the case would be heard by all 12 of the court’s judges,rather than a typical panel of three,and that one issue it wants to evaluate is whether it should “reconsider” its State Street Bank ruling.</p></blockquote><p><strong>evaluation</strong>&emsp;&emsp;&emsp;&emsp;估价；评价；估算<br><strong>state</strong>&emsp;&emsp;&emsp;&emsp;v 陈述；说明；规定；公布 adj 国家礼仪（规格的）的；州的，邦的 n 情况；状况；国家；州，邦<br><strong>reconsider</strong>&emsp;&emsp;&emsp;&emsp;重新考虑；重新审议</p></li></ol><hr><h3 id="Page-366-367"><a href="#Page-366-367" class="headerlink" title="Page(366-367)"></a>Page(366-367)</h3><ol><li><p><strong>compete</strong>&emsp;&emsp;&emsp;&emsp;v.竞争；比赛，竞赛<br>&emsp;&emsp;<code>com-</code> 共同，一起&emsp;&emsp;&emsp;&emsp;<code>pet-</code> 追求，追寻<br>&emsp;&emsp;“很多人一起你追我赶”<br><strong>competition</strong>&emsp;&emsp;&emsp;&emsp;n.竞赛；比赛<br><strong>competitive</strong>&emsp;&emsp;&emsp;&emsp;a.竞赛的，比赛的；好竞争的<br><strong>competitor</strong>&emsp;&emsp;&emsp;&emsp;n.竞争者；敌手<br><strong>competing</strong>&emsp;&emsp;&emsp;&emsp;a.抵触的，互相矛盾的；竞争的<br><strong>fierce competition</strong>&emsp;&emsp;&emsp;&emsp;激烈的竞争</p></li><li><p><strong>pore</strong>&emsp;&emsp;&emsp;&emsp;n.小孔；气孔；毛孔</p></li><li><p><strong>mobile</strong>&emsp;&emsp;&emsp;&emsp;a.可移动的； n.活动物体<br>&emsp;&emsp;<code>mo- = move-</code> 移动&emsp;&emsp;&emsp;&emsp;<code>bile- = able</code>= 能够…的</p><blockquote><p>The Supreme Court will now conside whether police can search the contents of a moblie phone without a warrant if the phone is on or around a person during an arrest.</p></blockquote><p><strong>mobilize</strong>&emsp;&emsp;&emsp;&emsp;v.调动，动员<br><strong>warrant</strong>&emsp;&emsp;&emsp;&emsp;n.搜查令；正当的理由 v.使显得必要；保证，担保<br><strong>arrest</strong> &emsp;&emsp;&emsp;&emsp;v.逮捕，拘捕；阻止，中止;吸引（注意） n.逮捕，拘捕；阻止</p></li><li><p><strong>rival</strong>&emsp;&emsp;&emsp;&emsp;a.竞争的，对抗的； n.敌手，对手</p></li><li><p><strong>sphere</strong>&emsp;&emsp;&emsp;&emsp;n.球体；领域，范围</p></li><li><p><strong>complain</strong>&emsp;&emsp;&emsp;&emsp;v.抱怨，发牢骚；【法】控诉<br>&emsp;&emsp;<code>com-</code> 完全&emsp;&emsp;&emsp;&emsp;<code>plain-</code> 平<br><strong>complaint</strong>&emsp;&emsp;&emsp;&emsp;n.抱怨，怨言；投诉；控诉</p></li><li><p><strong>drag</strong>&emsp;&emsp;&emsp;&emsp;v.拉，拽；（拖着脚）行进；慢吞吞的行走<br>&emsp;&emsp;<code>dr- = draw-</code>&emsp;&emsp;&emsp;&emsp;<code>ag- = act-</code></p></li><li><p><strong>spit</strong>&emsp;&emsp;&emsp;&emsp;v.吐，吐唾沫<br><strong>spot</strong>&emsp;&emsp;&emsp;&emsp;n.斑点；污点</p></li><li><p><strong>complete</strong> &emsp;&emsp;&emsp;&emsp;a.完整的；完成的； vt.使完整；完成，结束<br><strong>completely</strong>&emsp;&emsp;&emsp;&emsp;adv.完全地；彻底地</p></li><li><p><strong>drain</strong>&emsp;&emsp;&emsp;&emsp;v.排出（液体） n.下水道，排水管；消耗<br>&emsp;&emsp;<code>d- = draw-</code>拉拽，抽拉&emsp;&emsp;&emsp;&emsp;<code>rain-</code> 雨水</p></li></ol><hr><h3 id="Page-368-369"><a href="#Page-368-369" class="headerlink" title="Page(368-369)"></a>Page(368-369)</h3><ol><li><p><strong>robust</strong>&emsp;&emsp;&emsp;&emsp;强健的，强有力的；精力充沛的；结实的<br>&emsp;&emsp;<code>ro- = strong-</code> 强壮的&emsp;&emsp;&emsp;&emsp;<code>bust = best-</code> 最佳，最好</p><blockquote><p>The only major objection came from Justice A, who offered an even more robust defence of state privileges going back to the Alien and Sedition Acts.</p></blockquote><p><strong>privilege</strong>&emsp;&emsp;&emsp;&emsp;特权</p></li><li><p><strong>splash</strong>&emsp;&emsp;&emsp;&emsp;泼；洒；溅<br><strong>make a splash</strong>&emsp;&emsp;&emsp;&emsp;引起轰动；引人注意</p></li><li><p><strong>complicate</strong>&emsp;&emsp;&emsp;&emsp;使复杂；使难懂；使恶化<br><strong>complicated</strong>&emsp;&emsp;&emsp;&emsp;错综复杂的；难懂的<br><strong>complex</strong>&emsp;&emsp;&emsp;&emsp;复杂的；合成的 n.建筑物<br><strong>complexity</strong>&emsp;&emsp;&emsp;&emsp;复杂性；错综性</p><blockquote><p>But if the district is essentially giving a pass to students who do not do their homework because of complicated family lives,it is going riskily close to the implication that standards need to be lowered for poor children.</p></blockquote><p><strong>follow an ambiguous and complicated route</strong><br><strong>district</strong>&emsp;&emsp;&emsp;&emsp;地区；区域</p></li><li><p><strong>draw</strong>&emsp;&emsp;&emsp;&emsp;拖拽；拖拉；画<br><strong>draw experience from</strong>&emsp;&emsp;&emsp;&emsp;从…获取经验</p></li><li><p><strong>split</strong>&emsp;&emsp;&emsp;&emsp;裂开；分裂；裂口</p></li><li><p><strong>athlete</strong>&emsp;&emsp;&emsp;&emsp;运动员</p></li><li><p><strong>bidder</strong>&emsp;&emsp;&emsp;&emsp;出价人；投标人</p></li><li><p><strong>broadband</strong>&emsp;&emsp;&emsp;&emsp;宽带</p></li><li><p><strong>clarity</strong>&emsp;&emsp;&emsp;&emsp;清楚易懂，条理清晰；清晰（度）</p><blockquote><p>Rested in the Pacific Ocean,MaunaKea’s peak rises about the bulk of our planet’s dense atmosphere,where conditions allow telescopes to obtain images of unsurpassed clarity.</p></blockquote></li><li><p><strong>costless</strong>&emsp;&emsp;&emsp;&emsp;无需成本的；无需代价的</p></li><li><p><strong>disengage</strong>&emsp;&emsp;&emsp;&emsp;使分开，使脱离；解开，释放</p><blockquote><p>It makes it hard to disengage, and leads to a lot of bleed-over into the family routine.</p></blockquote></li><li><p><strong>dweller</strong>&emsp;&emsp;&emsp;&emsp;居民</p></li><li><p><strong>explicit</strong>&emsp;&emsp;&emsp;&emsp;清楚的；明确的<br><strong>explicitly</strong>&emsp;&emsp;&emsp;&emsp;明确地；明白地</p><blockquote><p>It’s not explicitly conscious;it’s the idea that I’m a coah, and you’re my team,and we’re in this together.</p></blockquote></li><li><p><strong>fire-prone</strong>&emsp;&emsp;&emsp;&emsp;容易发生火灾的<br><strong>fire-prone district</strong>&emsp;&emsp;&emsp;&emsp;火灾频繁的地区</p></li></ol><hr><h3 id="Page-370-375"><a href="#Page-370-375" class="headerlink" title="Page(370-375)"></a>Page(370-375)</h3><ol><li><p><strong>giant</strong>&emsp;&emsp;&emsp;&emsp;巨大的；大企业；大国；大师；巨人<br><strong>a giant observatory</strong>&emsp;&emsp;&emsp;&emsp;一个巨大的天文台</p></li><li><p><strong>handsome</strong>&emsp;&emsp;&emsp;&emsp;可观的，相当大的；英俊的</p></li><li><p><strong>illusory</strong>&emsp;&emsp;&emsp;&emsp;虚幻的，幻觉的；不切实际的<br><strong>illusion</strong>&emsp;&emsp;&emsp;&emsp;虚幻，幻觉</p></li><li><p><strong>inhabitant</strong>&emsp;&emsp;&emsp;&emsp;居民；（栖息于某区域的）动物</p></li><li><p><strong>internal</strong> &emsp;&emsp;&emsp;&emsp;内部的；国内的；体内的<br>&emsp;&emsp;<code>in-</code> 在里面&emsp;&emsp;&emsp;&emsp;<code>tern- = turn-</code> 转向，转变&emsp;&emsp;&emsp;&emsp;<code>al-</code> 形容词后缀<br><strong>Annals of Internal Medicine</strong>&emsp;&emsp;&emsp;&emsp;内科医学年鉴</p><blockquote><p>Today, the social sciences are largely focused on disciplinary problems and internal scholary debates,rather than on topics with external impact.</p></blockquote><p><strong>disciplinary</strong>&emsp;&emsp;&emsp;&emsp;有关纪律的; 执行纪律的; 惩戒性的</p></li><li><p><strong>Kingdom</strong>&emsp;&emsp;&emsp;&emsp;王国；界，领域</p></li><li><p><strong>medication</strong>&emsp;&emsp;&emsp;&emsp;药物</p></li><li><p><strong>mood</strong>&emsp;&emsp;&emsp;&emsp;情绪；语气；心态</p></li><li><p><strong>offering</strong>&emsp;&emsp;&emsp;&emsp;提供；提议；贡品</p></li><li><p><strong>overpack</strong> &emsp;&emsp;&emsp;&emsp;过度包装；产品外包装</p></li><li><p><strong>prairie</strong>&emsp;&emsp;&emsp;&emsp;(北美）大草原，大牧场</p></li><li><p><strong>refrain</strong>&emsp;&emsp;&emsp;&emsp;（from）节制;克制； （诗歌）的叠句；重复的话</p></li><li><p><strong>revolutionize</strong>&emsp;&emsp;&emsp;&emsp;使发生巨变；彻底改革</p></li><li><p><strong>simplify</strong>&emsp;&emsp;&emsp;&emsp;使简单化；使简单易懂</p></li><li><p><strong>squeeze</strong>&emsp;&emsp;&emsp;&emsp;压榨；挤入；拥挤的人群</p><blockquote><p>About half of U.S. jobs are at high risk of being automated,according to a University of Oxford study, with the middle class disproportionately squeezed.</p></blockquote><p><strong>disproportionately</strong>&emsp;&emsp;&emsp;&emsp;不成比例地</p></li><li><p><strong>suck</strong>&emsp;&emsp;&emsp;&emsp;吸取；将…卷入</p></li><li><p><strong>terrify</strong> &emsp;&emsp;&emsp;&emsp;使极度害怕</p></li><li><p><strong>unintentionally</strong>&emsp;&emsp;&emsp;&emsp;无意的</p></li><li><p><strong>urgent</strong>&emsp;&emsp;&emsp;&emsp;急迫的；紧急的</p><blockquote><p>It needs to put historical prejudices to one side and take some steps to address our urgent housing need.</p></blockquote></li><li><p><strong>weapon</strong>&emsp;&emsp;&emsp;&emsp; 武器；（对付困境的）工具，手段</p></li><li><p><strong>workload</strong>&emsp;&emsp;&emsp;&emsp; 工作量，工作负荷</p></li><li><p><strong>drawn</strong>&emsp;&emsp;&emsp;&emsp; 疲惫的，憔悴的；愁眉苦脸的<br>&emsp;&emsp;<code>dra- = drug-</code>&emsp;&emsp;&emsp;&emsp;<code>wn- = wild-</code><br><strong>drawn-out battle</strong>&emsp;&emsp;&emsp;&emsp;旷日持久的战争</p></li><li><p><strong>rocket</strong>&emsp;&emsp;&emsp;&emsp;火箭；用火箭运载</p></li><li><p><strong>fluctuate</strong>&emsp;&emsp;&emsp;&emsp;波动；上下浮动<br><strong>fluctuation</strong>&emsp;&emsp;&emsp;&emsp;波动，起伏；动摇</p><blockquote><p>However, because these connections are made through effort and practice, scientists believe that intelligence can expand and fluctuate according to mental effort.</p></blockquote></li><li><p><strong>assess</strong>&emsp;&emsp;&emsp;&emsp;评估（财产、收入）；评价，评定<br><strong>assessment</strong>&emsp;&emsp;&emsp;&emsp; 评估；评价</p></li><li><p><strong>role</strong>&emsp;&emsp;&emsp;&emsp;角色；作用，任务<br><strong>play a (key) role in</strong>&emsp;&emsp;&emsp;&emsp;在什么中扮演（关键）角色；在什么中起（关键）作用</p></li><li><p><strong>postmodern</strong>&emsp;&emsp;&emsp;&emsp;后现代主义的<br>&emsp;&emsp;<code>post-</code> 后</p></li><li><p><strong>roll</strong>&emsp;&emsp;&emsp;&emsp;滚动；旋转；卷绕</p></li><li><p><strong>spook</strong>&emsp;&emsp;&emsp;&emsp;鬼，幽灵；鬼怪般出没的；恐吓；（因受到恐吓而）逃窜<br>&emsp;&emsp;<code>spo- = spect-</code>&emsp;&emsp;&emsp;&emsp;<code>ok- = panic-</code></p></li><li><p><strong>drift</strong>&emsp;&emsp;&emsp;&emsp; 漂流，漂泊<br>&emsp;&emsp;<code>dri- = drive-</code>&emsp;&emsp;&emsp;&emsp;<code>ft- = craft-</code></p></li><li><p><strong>posture</strong>&emsp;&emsp;&emsp;&emsp;姿势，姿态；心态；摆出某种姿态<br><strong>pose</strong>&emsp;&emsp;&emsp;&emsp;姿势，姿态</p></li><li><p><strong>spotlight</strong>&emsp;&emsp;&emsp;&emsp;聚光灯；关注点；使注意，使醒目</p></li><li><p><strong>conception</strong>&emsp;&emsp;&emsp;&emsp;概念，观念；思想；构想，想象<br><strong>concept</strong>&emsp;&emsp;&emsp;&emsp;概念；观念；思想<br><strong>conceive</strong>&emsp;&emsp;&emsp;&emsp;怀有（想法，感情等）；设想，构思；怀孕</p><blockquote><p>We reason together,challenge, revise, and complte each other’s reasoning and each other’s conceptions of reason.</p></blockquote><p><strong>reason</strong>&emsp;&emsp;&emsp;&emsp;推理<br><strong>challenge</strong>&emsp;&emsp;&emsp;&emsp;怀疑<br><strong>revise</strong>&emsp;&emsp;&emsp;&emsp;修正</p></li><li><p><strong>root</strong>&emsp;&emsp;&emsp;&emsp;根；根基；根源；扎根于；根除</p></li><li><p><strong>spouse</strong>&emsp;&emsp;&emsp;&emsp;配偶</p></li><li><p><strong>pound</strong>&emsp;&emsp;&emsp;&emsp; 猛击，敲打；英镑</p></li><li><p><strong>pour</strong>&emsp;&emsp;&emsp;&emsp; 倒；倾泻；涌入；（雨）倾盆而下<br><strong>pour cash into</strong>&emsp;&emsp;&emsp;&emsp; 为…大肆花钱</p></li><li><p><strong>spur</strong> &emsp;&emsp;&emsp;&emsp;马刺；刺激（物）；激励</p></li><li><p><strong>concert</strong>&emsp;&emsp;&emsp;&emsp;一致，和谐；音乐会<br><strong>concertgoer</strong>&emsp;&emsp;&emsp;&emsp;经常去听音乐会的人</p></li><li><p><strong>power</strong>&emsp;&emsp;&emsp;&emsp; 权力；力量；能力<br><strong>powerful</strong>&emsp;&emsp;&emsp;&emsp;强有力的；有权势的</p><blockquote><p>This movement, driven by powerful and diverse motivations, built a nation of a wilderness and, bu its nature, shaped the character and destiny of an uncharted contient.</p></blockquote><p><strong>uncharted</strong>&emsp;&emsp;&emsp;&emsp;未知的<br><strong>contient</strong>&emsp;&emsp;&emsp;&emsp;大陆</p></li><li><p><strong>drug</strong>&emsp;&emsp;&emsp;&emsp;药材；毒品；吸毒<br><strong>drugstore</strong>&emsp;&emsp;&emsp;&emsp;（兼卖杂货的）药房，杂货店</p></li><li><p><strong>spy</strong>&emsp;&emsp;&emsp;&emsp;间谍；暗中监视；刺探<br>&emsp;&emsp;<code>sp- = spect-</code> 看&emsp;&emsp;&emsp;&emsp;<code>y- = enemy-</code></p></li></ol><hr>]]></content>
      <categories>
        <category>考研</category>
        <category>英语</category>
        <category>单词</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>英语</tag>
        <tag>考研单词</tag>
      </tags>
  </entry>
  <entry>
    <title>local_search_heuristic_Select</title>
    <url>/2020/03/13/local-search-heuristic-Select/</url>
    <content><![CDATA[<p>&emsp;&emsp;GSAT、GSAT+walk、WALKSAT、WALKSAT/SKC、WalkSAT/TABU、WalkSAT/Novelty、WalkSAT/R Novelty、WalkSAT/Novelty+、WalkSAT/Novelty++;<br><a id="more"></a></p><p><strong>GSAT :</strong><br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">begin</span><br><span class="line">    for i &#x3D; 1 : MAX_TRIES</span><br><span class="line">        T &#x3D;  random generate a true assignment</span><br><span class="line">        for j &#x3D; 1 : MAX_FLIPS</span><br><span class="line">            if T satisfied  then return T</span><br><span class="line">            p &#x3D; 翻转之后使满足子句的个数增加最多的那个变量,若有多个则随机从中选一个;</span><br><span class="line">            T &#x3D; the assignment after flipping p;</span><br><span class="line">        end for</span><br><span class="line">    end for</span><br><span class="line">    return &quot;no find solution&quot;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p></p><p><strong>GSAT + walk :</strong><br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">begin</span><br><span class="line">    for i &#x3D; 1 : MAX_TRIES</span><br><span class="line">        T &#x3D;  random generate a true assignment</span><br><span class="line">        for j &#x3D; 1 : MAX_FLIPS</span><br><span class="line">            if T satisfied  then return T</span><br><span class="line">            r randomly generated from 0 to 1;</span><br><span class="line">            if r&lt;p </span><br><span class="line">                在不满足子句中随机选择一个变元并翻转;</span><br><span class="line">                &#x2F;&#x2F;(random walk)</span><br><span class="line">            else</span><br><span class="line">                p &#x3D; 翻转之后使满足子句的个数增加最多的那个变量,若有多个则随机从中选一个;</span><br><span class="line">                T &#x3D; the assignment after flipping p;</span><br><span class="line">                &#x2F;&#x2F;(GSAT)</span><br><span class="line">        end for</span><br><span class="line">    end for</span><br><span class="line">    return &quot;no find solution&quot;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p></p><p><strong>WalkSAT :</strong><br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">begin</span><br><span class="line">    for i &#x3D; 1 : MAX_TRIES</span><br><span class="line">         T &#x3D;  random generate a true assignment</span><br><span class="line">        for j &#x3D; 1 : MAX_FLIPS</span><br><span class="line">            if T satisfied  then return T</span><br><span class="line">            随机的选择一个不满足子句c;</span><br><span class="line">            r randomly generated from 0 to 1;</span><br><span class="line">            if r&lt;p </span><br><span class="line">                在不满足子句c中随机选择一个变元并翻转;</span><br><span class="line">            else</span><br><span class="line">                记break-count为子句c的变元翻转后由满足变为不满足的子句数;</span><br><span class="line">                选择break-count最小的变元v;</span><br><span class="line">                T &#x3D; the assignment after flipping v;</span><br><span class="line">        end for</span><br><span class="line">    end for</span><br><span class="line">    return &quot;no find solution&quot;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p></p><p><strong>WalkSAT/ SKC :</strong><br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">begin</span><br><span class="line">    for i &#x3D; 1 : MAX_TRIES</span><br><span class="line">         T &#x3D;  random generate a true assignment</span><br><span class="line">        for j &#x3D; 1 : MAX_FLIPS</span><br><span class="line">            if T satisfied  then return T</span><br><span class="line">            随机的选择一个不满足子句c;</span><br><span class="line">            记break-count为子句c的变元翻转后由满足变为不满足的子句数;</span><br><span class="line">            随机从c中选择一个变元v;</span><br><span class="line">            r randomly generated from 0 to 1;</span><br><span class="line">            if r&lt;p  </span><br><span class="line">                if break-count &#x3D;&#x3D; 0</span><br><span class="line">                    flip v;</span><br><span class="line">                else</span><br><span class="line">                    在不满足子句c中随机选择一个变元并翻转;</span><br><span class="line">            else</span><br><span class="line">                </span><br><span class="line">                选择break-count最小的变元v;</span><br><span class="line">                T &#x3D; the assignment after flipping v;</span><br><span class="line">        end for</span><br><span class="line">    end for</span><br><span class="line">    return &quot;no find solution&quot;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p></p><p><strong>WalkSAT/TABU :</strong><br>&emsp;&emsp;策略是选择一个变量,以最大程度地减少不满意子句的数量。但是,在每个步骤中,请拒绝翻转过去t步中已翻转的任何变量；如果所选不满意子句中的所有变量都是禁忌,请选择其他不满意子句。如果所有不满足的子句中的所有变量都是禁忌,则禁忌列表将被忽略。禁忌表长度t是噪声参数。</p><p><strong>WalkSAT/Novelty :</strong><br>&emsp;&emsp;这种策略按照不满意子句的总数对变量进行排序,就像G一样,但是为了最近最少翻转的变量而打破平局。考虑这种情况下的最佳和次佳变量。如果最好的变量不是子句中最近翻转的变量,请选择它。否则,以概率p选择次优变量,以概率1 p选择最佳变量。</p><p><strong>WalkSAT/R Novelty :</strong><br>&emsp;&emsp;与NOVELTY相同,但最佳变量是最近翻转的变量除外。在这种情况下,令n为最佳变量次最佳变量之间的目标函数之差。 然后有四种情况:</p><pre><code> * 当p &lt; 0.5 且 n&gt; 1时,选择最佳。
 * 当p &lt; 0.5且n = 1时,则概率为2p选择第二好的,否则选择最好的。
 * 当p &gt;= 0.5且n = 1时,选择第二好的。
 * 当p &gt;= 0.5且n&gt; 1时,则以2（p - 0.5）的概率选择第二好的,否则选择最好的。
</code></pre><p>&emsp;&emsp;R NOVELTY几乎是确定性的。为了打破搜索中的确定性循环，每翻转100次，策略将从子句中选择一个随机变量。尽管几乎没有涉及不确定性的翻转，但正如我们将看到的，R NOVELTY的性能仍然对参数p的设置非常敏感。</p><p><strong>WalkSAT/Novelty+ :</strong><br>&emsp;&emsp;With probability wp, randomly pick a variable from c (random walk), with probability 1-wp, do as Novelty.</p><p><strong>WalkSAT/Novelty++ :</strong><br>&emsp;&emsp;With probability dp (diversification probability), pick the least recently flipped variable in c (diversification), with probability 1-dp, do as Novelty.</p><hr><p>/<em>gsat</em>/</p><p>评估适应度，建立最好变元(最大的适应度值)的候选列表；从中随机选择一个变量进行翻转。</p><p>/<em>gwsat</em>/</p><p>以概率wp随机地从所有的不满足子句中选择一个变元翻转；否则，建立最好变元(最小的break-count - make-count)<br>的候选列表，从中随机选择一个变量进行翻转。</p><p>/<em>gsat-tabu</em>/<br>(确定禁忌表的长度；从初始开始，将每个翻转的变元存入禁忌表中，若禁忌表已满，则删除禁忌表中最前面的元素，<br>然后将最新翻转的变元添加进去。添加一次，禁忌表中的每个变元的值增1；在添加之前，判断禁忌表是否已满，若已满<br>则将禁忌表头元素删除，然后添加新变元，禁忌表中的每个变元的值增1。可以将禁忌表用队列数据结构表示，“FIFO”特性。<br>禁忌表中每个变元的值用vector模板表示)</p><p>对不是禁忌表中的所有变元，建立最好变元(最大的适应度值)的候选列表，从中随机选择一个变量进行翻转。</p><p>/<em>hsat</em>/<br>评估适应度，建立最好变元(若有多个变元，则选择翻转older的变元)的候选列表；从中随机选择一个变量进行翻转。</p><p>/<em>hwsat</em>/<br>以概率wp随机选择一个不满足子句，从中随机选择一个变元；否则，执行hsat操作。</p><p>/<em>walksat</em>/<br>随机地选择一个不满足子句；翻转这个子句的各个变元得到break-count。建立候选解列表。若所得最好的大于0，则以wp概率随机选择变元，否则从候选解中随机选择一个变量翻转 。</p><p>/<em>walksat-tabu</em>/<br>随机选择一个不满足子句；翻转这个子句的各个变元得到break-count。若break-count值为0则不放入禁忌表，建立候选解列表。若候选列表为空则执行一个null-flip。从候选解中随机选择一个变量翻转 。</p><p>/<em>novelty</em>/<br>随机地选择一个不满足子句；对所有该子句中的变元，通过增加的break-count-make-cout评分，建立最佳列表和次最佳列表；若最佳变元不是最近翻转列表中的元素，则翻转它；否则，以概率p选择次最佳变元。</p><p>/<em>novelty+</em>/<br>以概率wp随机地选择一个变元翻转；否则，以1-wp执行novelty操作。</p><p>/<em>novelty++</em>/<br>随机地选择一个不满足子句，以概率dp选择该子句中最近翻转的变元；否则，以1-wp执行novelty操作。</p><p>/<em>adaptnovelty</em>/<br>若一段时间未有所提高，则提高噪声；否则，减小噪声（wp:= wp - wp*phi/2）。</p><hr><div id="“refer-anchor”"></div><p>1 On_the_Run-time_Behaviour_of_Stochastic_Local_Search_Algorithms_for_SAT</p><p>2 Diversification_and_Determinism_in_Local_Search_for_Satisfiability</p><p>3 [‘UBCSAT’,<a href="http://ubcsat.dtompkins.com/home" target="_blank" rel="noopener">http://ubcsat.dtompkins.com/home</a>]</p>]]></content>
      <categories>
        <category>毕设</category>
        <category>文献阅读</category>
        <category>算法</category>
        <category>GA</category>
      </categories>
      <tags>
        <tag>毕设</tag>
        <tag>文献阅读</tag>
        <tag>笔记</tag>
        <tag>GA</tag>
      </tags>
  </entry>
  <entry>
    <title>An_Adaptive_Noise_Mechanism_for_WalkSAT</title>
    <url>/2020/03/13/An-Adaptive-Noise-Mechanism-for-WalkSAT/</url>
    <content><![CDATA[<p>&emsp;&emsp;WalkSAT算法基于迭代搜索过程,该过程在每个步骤随机选择给定SAT实例的当前不满意子句(均匀概率分布),选择出现子句中的变量并将其翻转,即将其真值从true更改为false,反之亦然。<a id="more"></a>在不满意的子句中使用不同的方法进行翻转选择,从而产生了各种WlkSAT算法(McAllester,Selman和Kautz,1997;Hoos,1999;Hoos和Stutzle,2000a)。所有这些都使用一个称为噪声参数的参数来控制变量选择过程中的贪婪程度,即可能选择的变量的程度,当翻转该变量时,不满足子句数量的最大减少。</p><h3 id="WalkSAT-with-Dynamic-Noise"><a href="#WalkSAT-with-Dynamic-Noise" class="headerlink" title="WalkSAT with Dynamic Noise"></a>WalkSAT with Dynamic Noise</h3><p>&emsp;&emsp;基于噪声设置对搜索过程的影响,似乎最佳噪声设置是在算法通过遵循局部梯度贪婪地找到解决方案的能力与从局部极小值以及吸收搜索对象的其他空间区域逃逸的能力取得良好平衡的设置。执行非贪婪搜索步骤所需要的标准静态噪声机制，以避开搜索将以恒定的概率停滞的情况。</p><p>&emsp;&emsp;这通常会导致目标函数值快速提高一系列，然后停滞（除非找到给定问题实例的解决方案）。在这种情况下，噪声值会增加。如果该增加不足以摆脱停滞情况，即，如果在一定数量的步骤内没有导致目标函数值的改善，则噪声值会进一步增加。甚至，噪声值应足够高，以使搜索过程克服停滞现象，此时可以逐渐降低噪声，直到检测到下一个停滞状况或找到给定问题实例的解决方案为止。</p><p>&emsp;&emsp;滞后检测机制:在经过a·m(m是给定问题实例的子句数)个搜索步骤后,观察到目标函数的是否改善。噪声增大机制:wp:= wp + (1 - wp)b;噪声减小机制:wp:= wp - wp·2b;</p><p>&emsp;&emsp;噪声设置的增加和减少之间的不对称性是由于以下事实引起的:检测搜索停滞在计算上比检测搜索进度更加昂贵,并且通过较早的观察发现,即从上方而不是从下方近似最佳噪声水平是有利的。 在增大或减小了噪声设置之后,当前的目标函数值将被存储并成为测量改进并因此用于检测搜索停滞的基础。 因此,噪声水平的增加之间总是存在一个相位持续时间，,在不进一步增加噪声的情况下,监视轨迹的搜索进度。 在连续降低噪声级之间不会存在此类延迟。</p>]]></content>
      <categories>
        <category>毕设</category>
        <category>文献阅读</category>
        <category>算法</category>
        <category>GA</category>
      </categories>
      <tags>
        <tag>毕设</tag>
        <tag>文献阅读</tag>
        <tag>笔记</tag>
        <tag>GA</tag>
      </tags>
  </entry>
  <entry>
    <title>Evidence_for_Invariants_in_Local_Search</title>
    <url>/2020/03/13/Evidence-for-Invariants-in-Local-Search/</url>
    <content><![CDATA[<p>&emsp;&emsp;众所周知,随机局部搜索程序的性能取决于其噪声参数的设置,并且最佳设置随问题的分布而变化。介绍了两种随机本地搜索的统计方法,可以使人们更快地找到最优噪声设置。这种属性与随机本地搜索策略的详细信息无关,并且似乎相对于与问题域的结构也无关。<br><a id="more"></a></p><p>&emsp;&emsp;”noise”这种参数通过非最优移动决定了跳出局部最小的可能性。退火算法中,是temperature;在禁忌搜索中,是tenure(禁忌时间的长度);在GSAT中,是随机游走参数;在WSAT中,是noise。由于最佳噪声参数设置既取决于问题实例的特征,也取决于搜索程序的精良的细节,这些细节可能会受到其他参数的影响;而反复试验来找到给定问题分布的最佳参数设置需要大量的精力。因此,非常希望找到设置最优噪声的方法,使得其不会随特定的算法或特定的实例而改变。</p><p>&emsp;&emsp;首先,对于给定问题的类别,在最佳参数设置下,由目标函数值(不满足子句的个数)测得的“噪声水平”在整个解决方案策略中近似恒定。称其为”noise level invariant”。其次,发现了一个更通用的原理,该原理表明,最佳参数设置是一种将目标函数均值和其方差之比近似最小化的设置。</p><p>&emsp;&emsp;通过分析该策略的几次短期运行的统计特性,可以快速准确地估算出给定策略的噪声参数的最佳值。</p><h2 id="1-Local-Search-Procedures-for-Boolean-Satisfiability"><a href="#1-Local-Search-Procedures-for-Boolean-Satisfiability" class="headerlink" title="1. Local Search Procedures for Boolean Satisfiability"></a>1. Local Search Procedures for Boolean Satisfiability</h2><p>&emsp;&emsp;“随机3SAT”公式中的子句是通过随机地均匀地选择三个不同的文字,然后以相等的概率否定每个来产生的。 Mitchell et al.(1992)表明,当这种公式中的子句与变量之比约为4.3时,随机3SAT问题在计算上比较困难。</p><p>&emsp;&emsp;本地搜索SAT试图最小化的目标函数(不满意子句的总数)。搜索策略的特征使它做出的动作不是最佳的,即在某种意义上动作会增加或无法降低目标函数,即使在当前状态的本地附近也可以使用这种改进的动作—称为噪音。如前所述,噪声允许局部搜索过程脱离局部最优。</p><p>&emsp;&emsp;考虑了从子句中选择变量的六种启发式方法:</p><ul><li><p>G:以p的概率选择任何变量,否则选择一个使未满足子句总数最小的变量。p为噪声参数,取值范围为0〜1。</p></li><li><p>B:以概率p选择任何变量,否则选择一个变量,该变量将在当前状态下为true的子句的数量最小化,但是如果进行翻转,该变量将为false。在WSAT的原始描述中,这被称为“minimizing breaks”。同样,p是噪声参数。</p></li><li><p>SKC:和前一个一样,但是如果存在一个折中值为0的值,则不要随意移动。请注意,当break-value为0时,则保证移动也可以改善目标函数。这是Selman,Kautz和Cohen（1994）提出的原始WSAT策略。</p></li><li><p>TABU:策略是选择一个变量,以最大程度地减少不满意子句的数量。但是,在每个步骤中,请拒绝翻转过去t步中已翻转的任何变量；如果所选不满意子句中的所有变量都是禁忌,请选择其他不满意子句。如果所有不满足的子句中的所有变量都是禁忌,则禁忌列表将被忽略。禁忌表长度t是噪声参数。</p></li><li><p>NOVELTY:这种策略按照不满意子句的总数对变量进行排序,就像G一样,但是为了最近最少翻转的变量而打破平局。考虑这种情况下的最佳和次佳变量。如果最好的变量不是子句中最近翻转的变量,请选择它。否则,以概率p选择次优变量,以概率1 p选择最佳变量。</p></li><li><p>R NOVELTY:与NOVELTY相同,但最佳变量是最近翻转的变量除外。在这种情况下,令n为最佳变量次最佳变量之间的目标函数之差。 然后有四种情况:</p><ul><li>当p &lt; 0.5 且 n&gt; 1时,选择最佳。</li><li>当p &lt; 0.5且n = 1时,则概率为2p选择第二好的,否则选择最好的。</li><li>当p &gt;= 0.5且n = 1时,选择第二好的。</li><li>当p &gt;= 0.5且n&gt; 1时,则以2（p - 0.5）的概率选择第二好的,否则选择最好的。</li></ul></li></ul><p>&emsp;&emsp;NOVELTY的直觉是要避免反复反复翻转相同的变量。R NOVELTY背后的直觉是目标函数应影响最佳变量和次佳变量之间的选择————目标函数的较大差异有利于最佳变量。请注意,R NOVELTY几乎是确定性的。为了打破搜索中的确定性循环，每翻转100次，策略将从子句中选择一个随机变量。尽管几乎没有涉及不确定性的翻转，但正如我们将看到的，R NOVELTY的性能仍然对参数p的设置非常敏感。</p>]]></content>
      <categories>
        <category>毕设</category>
        <category>文献阅读</category>
        <category>算法</category>
        <category>GA</category>
      </categories>
      <tags>
        <tag>毕设</tag>
        <tag>文献阅读</tag>
        <tag>笔记</tag>
        <tag>GA</tag>
      </tags>
  </entry>
  <entry>
    <title>一个求解结构SAT问题的高效局部搜索算法</title>
    <url>/2020/03/11/%E4%B8%80%E4%B8%AA%E6%B1%82%E8%A7%A3%E7%BB%93%E6%9E%84SAT%E9%97%AE%E9%A2%98%E7%9A%84%E9%AB%98%E6%95%88%E5%B1%80%E9%83%A8%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>&emsp;&emsp;对GSAT+walk算法进行了改进,除去了其中的GSAT部分的“平移”;其次,对没一个子句进行赋权,并在搜索过程中动态调整子句的权。<br><a id="more"></a></p><h2 id="1-一般的GSAT算法"><a href="#1-一般的GSAT算法" class="headerlink" title="1. 一般的GSAT算法"></a>1. 一般的GSAT算法</h2><h3 id="1-1-GSAT伪代码"><a href="#1-1-GSAT伪代码" class="headerlink" title="1.1 GSAT伪代码:"></a>1.1 GSAT伪代码:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">begin</span><br><span class="line">    for i &#x3D; 1 : MAX_TRIES</span><br><span class="line">        T &#x3D;  random generate a true assignment</span><br><span class="line">        for j &#x3D; 1 : MAX_FLIPS</span><br><span class="line">            if T satisfied  then return T</span><br><span class="line">            p &#x3D; 翻转之后使满足子句的个数增加最多的那个变量,若有多个则随机从中选一个;</span><br><span class="line">            T &#x3D; the assignment after flipping p;</span><br><span class="line">        end for</span><br><span class="line">    end for</span><br><span class="line">    return &quot;no find solution&quot;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="1-2-GSAT-walk的局部搜索算法"><a href="#1-2-GSAT-walk的局部搜索算法" class="headerlink" title="1.2 GSAT + walk的局部搜索算法"></a>1.2 GSAT + walk的局部搜索算法</h3><blockquote><p>随机游走 + 贪心算法</p></blockquote><p>&emsp;&emsp;算法中引入了一个参数p,在选择翻转变量的时候,以概率p在不满足子句中随机选择一个变量翻转,以概率1-p按照GSAT的策略翻转,即允许翻转之后的目标值比当前的目标值差<br>(适当后退,防止陷入局部最优);</p><h3 id="1-3-WalkSat"><a href="#1-3-WalkSat" class="headerlink" title="1.3 WalkSat"></a>1.3 WalkSat</h3><p>&emsp;&emsp;在Random Walk上做了改变,在选择变量时,首先随机选择一个不满足子句c,将翻转变量限制在这个子句中,记变量反转之后由满足变为不满足的子句个数为break-count;若break-count = 0,则翻转该变量;否则,以噪声概率p在子句c中最忌选择一个变量,以1-p在子句c中选择break-count最小的变量。<br>&emsp;&emsp;（考虑了变量翻转后满足子句变为不满足的个数,尽可能使其低;只考虑了降低变坏的风险。）</p><h3 id="1-4-TSAT"><a href="#1-4-TSAT" class="headerlink" title="1.4 TSAT"></a>1.4 TSAT</h3><p>&emsp;&emsp;在搜索过程中维持了一个固定长度的禁忌表,记录翻转过的变量,每翻转一个变量就更新一次,防止一段时间之内反复的翻转同一个位置,避免陷入局部极小,保证了变量在搜索空间的均匀分布;</p><hr><h2 id="2-本文的改进"><a href="#2-本文的改进" class="headerlink" title="2. 本文的改进"></a>2. 本文的改进</h2><h3 id="2-1-去掉GSAT-walk的“平移”操作"><a href="#2-1-去掉GSAT-walk的“平移”操作" class="headerlink" title="2.1 去掉GSAT+walk的“平移”操作"></a>2.1 去掉GSAT+walk的“平移”操作</h3><p>&emsp;&emsp;在不加权的GSAT中平台大量存在,搜索过程往往需要经过多次平移通过一个平台,并使不满足子句个数进一步减少。因此在不加权的GSAT中,平移是必须的,并且占了大部分。<br>&emsp;&emsp;在GSAT+walk中,随机行走允许上移,即不满足子句的个数增加。因此,随机行走策略使得搜索过程不会陷入某一平台或局部极小点。但平移依旧存在,并且约占所有移动的一半。<br>通过大量实验证实了GSAT部分的平移不再是必需的,去掉使得算法效率提高了。</p><p><strong>去掉GSAT部分的平移后的GSAT+walk算法:</strong><br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">随机产生一个真值指派作为搜索的起点;</span><br><span class="line">while 在当前指派下还有不满足的子句 do begin</span><br><span class="line">    产生一个[0,1)范围内的随机数r;</span><br><span class="line">    if(r &lt; p) then begin</span><br><span class="line">        在所有的不满足子句中随机挑选一个子句,在该子句中随机选择一个变元翻转(random walk)</span><br><span class="line">    end else begin</span><br><span class="line">        从所有变元中选取这样一个变元,使得翻转这个变元前不满足子句个数减去翻转后不满足子句个数的差达到最大。若这个差所能达到的最大值是0和负数,则不做任何事,否则将该变元的值翻转。(GSAT)</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;GSAT+walk可以很好的解决随机3SAT问题,但对于结构SAT问题,往往会反复地陷入局部极小点或平台中。在GSAT+walk中,由于引入了随机游走,使得一些子句时而满足时而不满足。显示了在结构SAT实例中的子句不对称性,解决办法就是对子句加权。<p></p><p><strong>GSAT(子句加权):</strong><br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">所有子句的权初始化为1;</span><br><span class="line">for i &#x3D;1 to MAXTRIES do begin</span><br><span class="line">    随机产生一个真值指派,作为搜索的起点; </span><br><span class="line">    for j&#x3D;1 to MAXFLIPS do begin</span><br><span class="line">        if 不满足子句的个数&#x3D;0 then 求解成功并输出当前指派;</span><br><span class="line">        从所有变元中选出这样一个变元,使得翻转这个变元前不满足子句的权之和减去翻转后不满足子句的权之和的差达到最大。</span><br><span class="line">        将该变元的值翻转翻转;</span><br><span class="line">    endfor</span><br><span class="line">    若不满足子句的个数不为0,则将所有不满足子句的权加1;否则,求解成功并输出当前指派;</span><br><span class="line">endfor</span><br></pre></td></tr></table></figure><p></p><p><strong>GSAT+walk(子句加权):</strong><br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">所有子句的权初始化为1;</span><br><span class="line">for i &#x3D;1 to MAXTRIES do begin</span><br><span class="line">    随机产生一个真值指派,作为搜索的起点; </span><br><span class="line">    for j&#x3D;1 to MAXFLIPS do begin</span><br><span class="line">        if 不满足子句的个数&#x3D;0 then 求解成功并输出当前指派;</span><br><span class="line">        产生一个[0,1)范围内的随机数r;</span><br><span class="line">        if(r &lt; p) then begin</span><br><span class="line">            在所有的不满足子句中随机挑选一个子句,在该子句中随机选择一个变元翻转(random walk)</span><br><span class="line">        end else begin</span><br><span class="line">            从所有变元中选出这样一个变元,使得翻转这个变元前不满足子句个数减去翻转后不满足子句个数的差达到最大。若这个差所能达到的最大值是0和负数,则不做任何事,否则将该变元的值翻转;</span><br><span class="line">            若不满足子句的个数不为0,则从所有不满足子句中随机挑选一个子句,并将它的权加1;</span><br><span class="line">    end</span><br><span class="line">    if 不满足子句的个数&#x3D;0 then 求解成功并输出当前指派;</span><br><span class="line">endfor</span><br><span class="line">求解失败;</span><br></pre></td></tr></table></figure><p></p><hr>]]></content>
      <categories>
        <category>毕设</category>
        <category>文献阅读</category>
        <category>算法</category>
        <category>GA</category>
      </categories>
      <tags>
        <tag>毕设</tag>
        <tag>文献阅读</tag>
        <tag>笔记</tag>
        <tag>GA</tag>
      </tags>
  </entry>
  <entry>
    <title>基于改进的遗传算法求解3_SAT问题</title>
    <url>/2020/03/08/%E5%9F%BA%E4%BA%8E%E6%94%B9%E8%BF%9B%E7%9A%84%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A33-SAT%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>&emsp;&emsp;基于局部搜索算法策略与SGA算法的基础上将三路划分快速排序算法相结合一种改进。首先通过适应度函数对基准调节，运用改进的三路划分快速排序，重新生成新的种群。</p><h2><a href="#" class="headerlink"></a><a id="more"></a></h2><h2 id="1-LSA"><a href="#1-LSA" class="headerlink" title="1. LSA"></a>1. LSA</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">step 1: rand(X);    &#x2F;&#x2F;随机产生P的一个指派</span><br><span class="line">step 2: t(X);       &#x2F;&#x2F;计算适应度函数值</span><br><span class="line">step 3: X1 &lt;- X;</span><br><span class="line">step 4: For j&#x3D;1 to N Do;</span><br><span class="line">step 5: X&#39; &lt;- NegT(X,j)   &#x2F;&#x2F;从上代群体选择个体加入X1</span><br><span class="line">step 6: If t(X&#39;) &gt;&#x3D; t(X1) then X1&lt;-X&#39;;</span><br><span class="line">step 7: 返回最优个体及相应适应度函数值。</span><br></pre></td></tr></table></figure><hr><h2 id="2-改进的遗传算法"><a href="#2-改进的遗传算法" class="headerlink" title="2. 改进的遗传算法:"></a>2. 改进的遗传算法:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">step 1: 使用随机函数生成一组大小为POPSIZE的染色体组;</span><br><span class="line">step 2: t &lt;- 0;             &#x2F;&#x2F;初始迭代次数为0</span><br><span class="line">step 3: 评估染色体组;initevaluate(X(t)); </span><br><span class="line">step 4: While(not terminate condition) Do 进行交叉、变异、排序，选择产生新一代群体;</span><br><span class="line">step 4.1: 从上一代群体进行三路快速排序; T ~ Sort(X(t);)</span><br><span class="line">step 4.2: 从中选择出更优良的一半染色体组加入X1,淘汰掉另一半差的个体；X1 &lt;-Selection(X(t));</span><br><span class="line">step 4.3: 以概率Pt对X1中选择的染色体进行交叉操作生成X2;X2 &lt;- crossover(X2);</span><br><span class="line">step 4.4: 对X2中的染色体进行变异操作; X(t+1) &lt;- mutation(X2);</span><br><span class="line">step 5: for i&#x3D;0 to POPSIZE Do   &#x2F;&#x2F;对X(t+1)中后半部分个体综合LSA算法改变某个基因分量寻找最优解;  </span><br><span class="line">step 6: X4 &lt;- X(t+1);</span><br><span class="line">step 7: for j&#x3D;0 to N Do;</span><br><span class="line">step 8: X5 &lt;- NegT(X4,j);</span><br><span class="line">step 9: If t(X5)&gt;&#x3D;t(X4) then X5替代X4存活到下一代群体X(t+1)中;</span><br><span class="line">step 10: End While; </span><br><span class="line">step 11: 输出最优个体及相应适应度值。</span><br></pre></td></tr></table></figure><hr><h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><h3 id="排序策略"><a href="#排序策略" class="headerlink" title="排序策略:"></a>排序策略:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void T~Sort(int l, int r)&#123;</span><br><span class="line">    if(l &gt;&#x3D; r) return;          </span><br><span class="line">    &#x2F;&#x2F;选择pivot划分种群，并将其与r位置的染色体交换</span><br><span class="line">    int pivot;</span><br><span class="line">    pivot &#x3D; 1 + rand()%(r-l+1);</span><br><span class="line">    exchangeX(pivot, r);</span><br><span class="line">    &#x2F;&#x2F;双向扫描:left与right为主动移动,lflag与rflag为被动移动</span><br><span class="line">    int left &#x3D; 1, lflag &#x3D; 1;</span><br><span class="line">    int right &#x3D; r - 1, rflag &#x3D; r - 1;</span><br><span class="line">    while(true)&#123;</span><br><span class="line">        while(t(left) &lt;&#x3D; t(r) &amp;&amp; left &lt; r)&#123;</span><br><span class="line">            if(t(left) &#x3D;&#x3D; t(pivot))&#123;</span><br><span class="line">                exchangeX(left, lflag);</span><br><span class="line">                lflag++;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        while(t(right) &gt;&#x3D; t(r) &amp;&amp; right &gt;&#x3D; 1)&#123;</span><br><span class="line">            if(t(right) &#x3D;&#x3D; t(pivot))&#123;</span><br><span class="line">                exchangeX(right, rflag);</span><br><span class="line">                rflag--;</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        if(left &gt;&#x3D; right) break;</span><br><span class="line">        exchangeX(right, left);</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;*此时左右最边上是和t(pivot)相等的染色体,靠左中间是小于其的,靠右中间是大于其的*&#x2F;</span><br><span class="line">    lflag--;</span><br><span class="line">    left--;</span><br><span class="line">    while(lflag &gt;&#x3D; 1)&#123;</span><br><span class="line">        exchangeX(left, lflag);</span><br><span class="line">        left--;</span><br><span class="line">        lflag--;</span><br><span class="line">    &#125;</span><br><span class="line">    rflag++;</span><br><span class="line">    right++;</span><br><span class="line">    while(rflag &lt;&#x3D; r)&#123;</span><br><span class="line">        exchangeX(right, rflag);</span><br><span class="line">        right++;</span><br><span class="line">        rflag++;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;*此时左边上是小于t(pivot)的染色体,中间是等于其的,右边是大于其的*&#x2F;</span><br><span class="line">    &#x2F;&#x2F;最终递归处理左右子序列部分</span><br><span class="line">    selection(l, left);</span><br><span class="line">    selection(right, r);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="交叉操作"><a href="#交叉操作" class="headerlink" title="交叉操作:"></a>交叉操作:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void crossover()&#123;</span><br><span class="line">    &#x2F;&#x2F;以PXOVER概率进行杂交</span><br><span class="line">    for(......)&#123;</span><br><span class="line">        Generate a random number from 0 to 1;</span><br><span class="line">        if(rand() * (1.0&#x2F;(RAND_MAX + 1.0)) &lt; PXOVER)&#123;</span><br><span class="line">            Random access number of two chromosomes from the select action populations;</span><br><span class="line">            Random generated a conform to the starting point for the hybrid operation;</span><br><span class="line">            overType &#x3D; rand() % 3;</span><br><span class="line">            swith(overType)&#123;</span><br><span class="line">                case 1:         &#x2F;&#x2F;以2&#x2F;3的概率进行互换子串杂交</span><br><span class="line">                case 2: int logic &#x3D; rand() % 3;</span><br><span class="line">                swith(logic)&#123;</span><br><span class="line">                    case 0:         &#x2F;&#x2F;以1&#x2F;9的概率进行异或杂交</span><br><span class="line">                    case 1:         &#x2F;&#x2F;以1&#x2F;9的概率进行与杂交</span><br><span class="line">                    case 2:         &#x2F;&#x2F;以1&#x2F;9的概率进行或杂交</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      <categories>
        <category>毕设</category>
        <category>文献阅读</category>
        <category>算法</category>
        <category>GA</category>
      </categories>
      <tags>
        <tag>毕设</tag>
        <tag>文献阅读</tag>
        <tag>笔记</tag>
        <tag>GA</tag>
      </tags>
  </entry>
  <entry>
    <title>一种新的自适应退火遗传算法</title>
    <url>/2020/03/08/%E4%B8%80%E7%A7%8D%E6%96%B0%E7%9A%84%E8%87%AA%E9%80%82%E5%BA%94%E9%80%80%E7%81%AB%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h2><p>对于SAT问题,</p><ul><li>选择<ul><li>引入了一类时变选择策略 — 整体退火选择。通过父代横向的竞争，不仅可以保证算法的收敛性，而且比SA有更快地收敛速度，具有更强的逃脱局部极值和避免过早收敛的全局优化能力。</li><li><script type="math/tex">A_i \in G</script>,则被选的概率为<script type="math/tex">P_s(A_i) = \frac{e^{f(A_i)/T_k}}{\sum_{A_j \in G} e^{f(A_j)/T_k}}</script>。<script type="math/tex">T_k</script>为渐趋于0的退火温度,<center>$$T_k = T_0 \frac{(ln2)^{a-1}}{(ln(1+k))^{a-1}k^{2-a}} &emsp; \begin{cases} {k=1,2,3,\ldots}, & \text{}\\[2ex] a\in{1,2}, & \text{} \end{cases}$$</center>当a为1时，此时为快速模拟退火，提高算法的收敛速度；当a为2时，此时为经典模拟退火，以使算法以概率1收敛到全局最优点。<a id="more"></a></li></ul></li><li><p>交叉</p><ul><li>当前代种群中个体的适应度低于平均值时，就要提高交叉率；当适应度高于平均值时，就要降低交叉率；当适应度值越来越接近最大适应度时，交叉率越来越小； 当其等于最大适应度时，不能使交叉率为0，否则会对进化初期不利，增大了进化趋向局部最优解的可能性。</li><li><script type="math/tex;mode=display">P_c = \begin{cases} {P_{c1} - \frac{(P_{c1}-P_{c2})(f-f_{avg})}{f_{max}-f_{avg}}}, & \text{$f \geq f_{avg}$}\\[2ex] P_{c1}, & \text{$$f< f_{avg}$$} \end{cases}</script></li></ul></li><li><p>变异</p><ul><li><script type="math/tex;mode=display">P_m = \begin{cases} {P_{m1} - \frac{(P_{m1}-P_{m2})(f-f_{avg})}{f_{max}-f_{avg}}}, & \text{$f \geq f_{avg}$}\\[2ex] P_{m1}, & \text{$$f< f_{avg}$$} \end{cases}</script></li></ul></li></ul>]]></content>
      <categories>
        <category>毕设</category>
        <category>文献阅读</category>
        <category>算法</category>
        <category>GA</category>
      </categories>
      <tags>
        <tag>毕设</tag>
        <tag>文献阅读</tag>
        <tag>笔记</tag>
        <tag>GA</tag>
      </tags>
  </entry>
  <entry>
    <title>一种基于有向交叉的遗传算法</title>
    <url>/2020/03/05/%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8E%E6%9C%89%E5%90%91%E4%BA%A4%E5%8F%89%E7%9A%84%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>&emsp;&emsp;从解空间的角度出发分析了交叉算子的作用，针对其盲目搜素的缺陷，提出了一种通过控制交叉子代的落点位置，使得交叉子代大概率地朝最优解的方向前进。</p><h2><a href="#" class="headerlink"></a><a id="more"></a></h2><h2 id="1-交叉操作的特征"><a href="#1-交叉操作的特征" class="headerlink" title="1.交叉操作的特征"></a>1.交叉操作的特征</h2><hr><h2 id="2-有向交叉"><a href="#2-有向交叉" class="headerlink" title="2.有向交叉"></a>2.有向交叉</h2><hr><p>对于SAT问题,<br>&emsp;&emsp;记个体<script type="math/tex">x:=\{x_1,x_2,\ldots,x_n\},y:=\{y_1,y_2,\ldots,y_n\};x,y \in \{0,1\}</script>;记翻转<script type="math/tex">x_i</script>后,<script type="math/tex">diff(x_i)</script>表示可满足子句的增加数;<br></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> each i:</span><br><span class="line">    <span class="keyword">if</span>(x_i == y_i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(diff(x_i) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            flip        <span class="comment">// 可以通过概率p来实现跳出局部最优</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">not</span> flip</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x_i &gt; y_i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x_i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                flip      <span class="comment">// 可以通过概率p来实现跳出局部最优</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">not</span> flip</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(x_i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                flip      <span class="comment">// 可以通过概率p来实现跳出局部最优</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">not</span> flip</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p></p><hr>]]></content>
      <categories>
        <category>毕设</category>
        <category>文献阅读</category>
        <category>算法</category>
        <category>GA</category>
      </categories>
      <tags>
        <tag>毕设</tag>
        <tag>文献阅读</tag>
        <tag>笔记</tag>
        <tag>GA</tag>
      </tags>
  </entry>
  <entry>
    <title>基于竞争指数的模拟退火排序选择算子</title>
    <url>/2020/03/05/%E5%9F%BA%E4%BA%8E%E7%AB%9E%E4%BA%89%E6%8C%87%E6%95%B0%E7%9A%84%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E6%8E%92%E5%BA%8F%E9%80%89%E6%8B%A9%E7%AE%97%E5%AD%90/</url>
    <content><![CDATA[<p>&emsp;&emsp;竞争指数是对个体的适应度以及编码差异度综合评估而产生的一种个体质量评价指标,代表了个体的绝对价值;根据其的竞争指数对个体进行排名,然后模拟退火过程产生排序参数,将其作为个体的相对价值;然后,将绝对价值以及相对价值的加权平均值作为个体生存的概率。这种选择方式可以有效地控制群体在迭代过程中的选择压力,保持群体结构的合理性。<br><a id="more"></a></p><hr><h2 id="1-竞争指数"><a href="#1-竞争指数" class="headerlink" title="1. 竞争指数:"></a>1. 竞争指数:</h2><p>&emsp;&emsp;设群体的规模为n,L为个体编码的长度,m维个体<script type="math/tex">A_i = a_1 a_2 \ldots a_L</script>,<script type="math/tex">a \in \{0,1\}</script>的适应度为<script type="math/tex">F_i>0</script>,<script type="math/tex">F_{max}</script>和<script type="math/tex">F_{avg}</script>分别表示当前群体中最优适应度和平均适应度。<br><br>&emsp;&emsp;规定当前群体中最优个体的竞争指数为1,其余个体的竞争指数为:<center>$$Q(A_i,A_{best}) = Q_i = \begin{cases} 0, & \text{if $D_i=0$}\\[2ex] D_i^{\lambda \overline{R_i}}, & \text{otherwise} \end{cases}$$</center><br>&emsp;&emsp;其中,调节参数<script type="math/tex">\lambda\in \begin{cases} (0,1) & \text{$\overline{R}<1$}\\[2ex] [1,2) & \text{$\overline{R}\geq1$} \end{cases}</script>;个体<script type="math/tex">A_i</script>所具有的相对平均适应度比<script type="math/tex">R_i = \frac{F_max - F_i}{F_max - F_{avg}}</script>;<script type="math/tex">D_i</script>表示<script type="math/tex">A_i</script>与<script type="math/tex">A_{best}</script>的编码差异度。<br><br>&emsp;&emsp;相对平均适应度比可用于描述个体<script type="math/tex">A_i</script>在进化信息传递方面的价值;当<script type="math/tex">F_i>F_{avg}</script>时<script type="math/tex">0 \leq \overline{R_i} \leq 1</script>;当<script type="math/tex">F_i \leq F_{avg}</script>时,<script type="math/tex">\overline{R_i} \geq 1</script>。通常,认为大于平均适应度的个体所承载的进化信息是有价值信息。<br>&emsp;&emsp;<script type="math/tex">D_i</script>反映了个体<script type="math/tex">A_i</script>与最优个体<script type="math/tex">A_{best}</script>的编码差异。由于<script type="math/tex">D_i \in [0,1]</script>,当<script type="math/tex">R_i < 1</script>即<script type="math/tex">F_i > F_{avg}</script>时<script type="math/tex">Q_i>Di</script>;当<script type="math/tex">R_i \geq 1</script>即<script type="math/tex">F_i \leq F_{avg}</script>时<script type="math/tex">Q_i \leq D_i</script>。这种变化方式使得高于群体平均适应度且与群体中最优个体差异较大的个体将具有更接近1的竞争指数,反而低于群体平均适应度且与群体中最优个体差异较小的个体具有更接近0的竞争指数。<br><br>&emsp;&emsp;第k代群体的平均编码差异度为:<center>$$ \chi_k= \frac{1}{n-1} \sum_{i=1}^{n-1}(\frac{1}{n-i} \sum_{j=1}^{n-1}D_{ij}) $$</center><br>&emsp;&emsp;群体平均差异度量化了群体中个体编码的差异性。越接近1说明群体中个体编码差异度越大,群体多样性程度越高。</p><h2 id="2-基于竞争指数的模拟退火排序选择算子"><a href="#2-基于竞争指数的模拟退火排序选择算子" class="headerlink" title="2. 基于竞争指数的模拟退火排序选择算子"></a>2. 基于竞争指数的模拟退火排序选择算子</h2><h3 id="模拟退火算子的工作流程"><a href="#模拟退火算子的工作流程" class="headerlink" title="模拟退火算子的工作流程:"></a>模拟退火算子的工作流程:</h3><p><strong>(1)</strong> &nbsp;计算父个体群体与子个体群体的竞争指数,并依据其对个体队列进行降序排序操作;</p><p><strong>(2)</strong> &nbsp;规定队列中<script type="math/tex">h(1) = 1</script>,其余<script type="math/tex">k=2,\ldots,2n</script>位个体的排序未知参数为:</p><p><center>$$h(k) = \exp(-\chi / T_k)$$</center></p><blockquote><p>&emsp;&emsp;其中,<script type="math/tex">\chi</script>为当前父个体群体的多样性指标,队列中第k位个体的退火温度为<script type="math/tex">T_k=T_0\beta^k</script>;一般<script type="math/tex">T_0 = 2n</script>V,<script type="math/tex">\beta</script>是一个略小于1的数。</p></blockquote><p><strong>(3)</strong> &nbsp;按照队列顺序依次挑选下代个体,队列中第k位个体的选择概率为<script type="math/tex">P_s(k) = \sigma Q_k + (1 - \sigma)h(k)</script>&emsp;&emsp;其中,权值<script type="math/tex">\sigma \in (0,1)</script>用于个体的竞争指数和模拟退火参数对选择概率的影响程度。<br></p><h3 id="该选择过程的特点"><a href="#该选择过程的特点" class="headerlink" title="该选择过程的特点:"></a>该选择过程的特点:</h3><p>（1） &nbsp;<strong>综合评估个体价值产生选择概率;</strong><br><br>（2） &nbsp;<strong>具有精英选择特性:</strong><br></p><blockquote><p>&emsp;&emsp;当群体及其后代中最优个体<script type="math/tex">A_{best}</script>的竞争指数<script type="math/tex">Q_{best}=1,h(A_{best})=1</script>,则<script type="math/tex">A_{best}</script>将以概率1保留到下代群体中,保持了算法的收敛性。</p></blockquote><p>（3） &nbsp;<strong>保持群体多样性;</strong><br><br>（4） &nbsp;<strong>通过参数<script type="math/tex">\sigma</script>动态调节选择概率;</strong><br></p><hr>]]></content>
      <categories>
        <category>毕设</category>
        <category>文献阅读</category>
        <category>算法</category>
        <category>GA</category>
      </categories>
      <tags>
        <tag>毕设</tag>
        <tag>文献阅读</tag>
        <tag>笔记</tag>
        <tag>GA</tag>
      </tags>
  </entry>
  <entry>
    <title>遗传算法研究进展    ---- 马永杰,云文霞</title>
    <url>/2020/03/01/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6%E8%BF%9B%E5%B1%95/</url>
    <content><![CDATA[<p>&emsp;&emsp;对遗传算法编码策略、遗传算子、参数确定、收敛性、欺骗问题等理论进行了分析;<br><a id="more"></a></p><hr><h2 id="1-GA介绍"><a href="#1-GA介绍" class="headerlink" title="1. GA介绍"></a>1. GA介绍</h2><ul><li>&emsp;&emsp;遗传算法是由美国的Holland教授在1975年在他的专著《自然界和人工系统的适应性》中首先提出的,它是一类借鉴生物界自然选择个自然遗传机制的随机搜素算法。遗传算法模拟自然选择和自然遗传过程中发生的繁殖、交叉和基因突变现象,在每次迭代中都保留一组候选解,并按某种指标从解群中选取较优的个体,利用遗传算子（选择、交叉和变异）对这些个体进行组合,产生新一代的候选解群,重复此过程,直至满足某种收敛指标为止。</li><li>&emsp;&emsp;与传统的启发式优化搜素算法相比,GA的主要本质特征在于群体搜索策略和简单的遗传算子。</li><li>&emsp;&emsp;群体搜索使遗传算法得以突破领域搜索的限制,可以实现整个解空间上的分布式信息的采集和探索;遗传算子仅仅利用适应值度量作为运算指标进行随机操作,降低了一般启发式算法在搜索过程中对人机交互的依赖。</li></ul><hr><h2 id="2-GA理论研究进展"><a href="#2-GA理论研究进展" class="headerlink" title="2. GA理论研究进展"></a>2. GA理论研究进展</h2><p>&emsp;&emsp;GA追求的是当前群体产生比现有个体更好个体的能力,即遗传算法的可进化性or群体可进化性。</p><h3 id="2-1-编码策略"><a href="#2-1-编码策略" class="headerlink" title="2.1 编码策略"></a>2.1 编码策略</h3><p>&emsp;&emsp;编码是把一个问题的可行解从其解空间转换到GA所能处理的搜索空间的转换方法。(对于SAT问题,我们采用二进制编码)</p><h3 id="2-2-遗传算子"><a href="#2-2-遗传算子" class="headerlink" title="2.2 遗传算子"></a>2.2 遗传算子</h3><p>&emsp;&emsp;包括选择、交叉和变异三大算子,模拟自然选择和遗传过程中发生的繁殖、杂交和突变现象。</p><ul><li><p><strong>选择算子:</strong><br>&emsp;&emsp;体现了适者生存的原理（通过适应度选择优质个体而抛弃劣质个体),作用是避免基因缺失,提高全局收敛性和计算效率;</p><ul><li>文献<a href="#refer-anchor"><sup>10</sup></a> — 提出了一种基于个体差异的局部竞争选择算子,通过保持种群的多样性增强了算法从局部最优中跳出的能力;</li><li>文献<a href="#refer-anchor"><sup>11</sup></a> — 提出了基于竞争指数的模拟退火排序选择算子,该算子能够有效的避免早熟收敛同时显著提高种群的搜索效率和稳定性;</li></ul></li><li><p><strong>交叉算子:</strong><br>&emsp;&emsp;使个体之间的遗传物质交换从而产生更好的个体;</p><ul><li>文献<a href="#refer-anchor"><sup>13</sup></a> — 提出了一种有向交叉遗传算子,通过优化控制交叉子代的落点位置,是交叉子代大概率地朝着最优解方向进化;</li></ul></li><li><p><strong>变异算子:</strong><br>&emsp;&emsp;能恢复个体失去的或未开发的遗传物质,以防止个体在形成最优解过程中过早的收敛;</p><ul><li>文献<a href="#refer-anchor"><sup>22</sup></a> — 设计了一个新的变异算子-贪婪子巡回变异算子CSTM,在新算子中存在两种不同的贪婪搜索方法和组件;</li></ul></li></ul><h3 id="2-3-参数确定"><a href="#2-3-参数确定" class="headerlink" title="2.3 参数确定"></a>2.3 参数确定</h3><p>&emsp;&emsp;主要包括染色体位串长度l(SAT中变元个数),群体规模n,交叉概率p_c,变异概率p_m;</p><ul><li>文献<a href="#refer-anchor"><sup>29</sup></a> — 针对早熟问题进行研究,提出以优势遗传的原则随个体适应的变化而适应地改变交叉和变异概率;</li></ul><h3 id="2-4-收敛性"><a href="#2-4-收敛性" class="headerlink" title="2.4 收敛性"></a>2.4 收敛性</h3><p>&emsp;&emsp;近几年,在遗传算法的全局收敛性的分析方面取得了突破,运用的主要工具是Markov链。<br>&emsp;&emsp;Rudolph（文献<a href="#refer-anchor"><sup>31</sup></a>）用齐次有限Markov链证明了带有选择、交叉、变异的经典遗传算法收敛不到全局最优解,但,若在遗传算法中保留每一代的最优个体,则算法将收敛到全局最优解;等</p><hr><h2 id="3-GA发展"><a href="#3-GA发展" class="headerlink" title="3. GA发展"></a>3. GA发展</h2><ul><li>文献<a href="#refer-anchor"><sup>62</sup></a> — 在标准GA的基础上,通过改进选择概率提出了一种自适应退火遗传算法;</li></ul><hr><p><br><br><br></p><div id="“refer-anchor”"></div><h2 id="4-References"><a href="#4-References" class="headerlink" title="4. References"></a>4. References</h2><p>[10] [乔家庆,付平,孟升卫.基于个体差异的遗传选择算子设计,2006]</p><p>[11] [陈皓,崔杜武,严太山等.基于竞争指数的模拟退火排序选择算子].2009</p><p>[13] [范青武,王普,高学金．一种基于有向交叉的遗传算法.2009]</p><p>[22] [MURAT A,NOVRUZ A.Development ａ new mutation operator to solve the tarveling saleman problem by aid of GA.2011]</p><p>[29] [陈世哲,刘国栋,浦欣,等．基于优势遗传的自适应遗传算法.2007]</p><p>[31] [RUDOLPH G.Convergence analysis of canonical genetic algorirhms.]</p><p>[62] [黄宜军,章卫国,刘小雄．一种新的自适应退火遗传算法.2006]</p>]]></content>
      <categories>
        <category>毕设</category>
        <category>文献阅读</category>
        <category>算法</category>
        <category>GA</category>
      </categories>
      <tags>
        <tag>毕设</tag>
        <tag>文献阅读</tag>
        <tag>笔记</tag>
        <tag>GA</tag>
      </tags>
  </entry>
  <entry>
    <title>基于个体差异的遗传选择算子设计    ---- 乔家庆,付平,孟升卫</title>
    <url>/2020/03/01/%E5%9F%BA%E4%BA%8E%E4%B8%AA%E4%BD%93%E5%B7%AE%E5%BC%82%E7%9A%84%E9%81%97%E4%BC%A0%E9%80%89%E6%8B%A9%E7%AE%97%E5%AD%90%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>&emsp;&emsp;采用基于局部竞争机制的选择算子不易跳出局部最优的问题,设计了一种基于个体差异的局部竞争选择算子,局部竞争作用的区域由种群的个体差异决定,有利于保持种群的多样性,增强算法从局部最优中跳出的能力。<a id="more"></a></p><hr><h2 id="1-一般选择算子及其特点"><a href="#1-一般选择算子及其特点" class="headerlink" title="1. 一般选择算子及其特点"></a>1. 一般选择算子及其特点</h2><p>&emsp;&emsp;在GA中,选择算子使搜索的重点放在适应值较高的个体上,使其获得较高的复制数目,充分利用了群体内当前具有的有效信息,但同时也是群体内个体失去多样性。</p><p>&emsp;&emsp;不同的选择算子导致了不同的选择压力,较大的选择压力使得最优个体具有较高的复制数目,从而使算法收敛速度快,但容易陷入局部最优;而较小的压力,不易陷入局部最优,但收敛速度慢。</p><h3 id="1-1-基于适应值比例"><a href="#1-1-基于适应值比例" class="headerlink" title="1.1 基于适应值比例:"></a>1.1 基于适应值比例:</h3><p>&emsp;&emsp;以个体在种群中的相对适应值为评价指标的选择策略;</p><ul><li>繁殖池: 根据相对适应值确定个体复制的个数,适应值较小的个体将被淘汰;</li><li>轮盘式选择: 根据相对适应值确定个体被选择的概率,群体中所有成员都有被选择的机会;</li></ul><h3 id="1-2-基于排名"><a href="#1-2-基于排名" class="headerlink" title="1.2 基于排名:"></a>1.2 基于排名:</h3><p>&emsp;&emsp;通过个体适应值在种群中的排名来计算其被选择的概率,然后根据这个概率使用轮盘选择;</p><h3 id="1-3-基于局部竞争"><a href="#1-3-基于局部竞争" class="headerlink" title="1.3 基于局部竞争:"></a>1.3 基于局部竞争:</h3><p>&emsp;&emsp;与其他两个相比,只涉及种群局部的个体间适应值的大小关系,而不涉及适应值信息。</p><p>&emsp;&emsp;竞标赛选择算子是基于此的一种选择算子,选择过程中先随随机的在群体中选择k（竞赛规模）个个体进行比较适应值,大的个体被选择。这种选择使得适应值大的个体有较大的的概率被选择,但选择的标准与适应值大小不直接成比例,因而也能避免群体中出现”超级个体”,可以在一定程度上避免出现早熟现象和停滞现象。</p><hr><h2 id="2-局部竞争机制的改进"><a href="#2-局部竞争机制的改进" class="headerlink" title="2. 局部竞争机制的改进"></a>2. 局部竞争机制的改进</h2><p>&emsp;&emsp;常用的选择算子通过利用个体的相对适应值或局部竞争机制避免算法的早收敛和停滞,但对于比较复杂的问题,如在全局最优解附近剧烈震荡的情况下,算法易陷入局部最优;</p><p>&emsp;&emsp;对于竞标赛选择算子而言,算法陷入局部最优的概率是由局部最优解在种群中所占的比例决定的;</p><h3 id="改进想法来源"><a href="#改进想法来源" class="headerlink" title="改进想法来源:"></a>改进想法来源:</h3><p>&emsp;&emsp;自然界的遗传竞争一般发生在相似或邻近的个体中,因此基于其可改进选择算子。</p><h3 id="理论实践"><a href="#理论实践" class="headerlink" title="理论实践:"></a>理论实践:</h3><p>&emsp;&emsp;在选择过程中,某一个体<script type="math/tex">x_i</script>与种群中各个个体差异表示为:<center>$$ L_{ij} = \sqrt{\sum_k (x_j(k) - x_i(k))^2} &emsp;,j=1,2,\cdots,N.$$</center>&emsp;&emsp;规定局部竞争作用发生在以<script type="math/tex">x_i</script>为中心区域,这一局部区域内适应值最大的个体被选择,并规定区域半径为:<center>$$ R_i = r \times max\{L_{ij}\} &emsp;,j=1,2,\cdots,N.$$</center>r是[0,1]上的平均分布的随机数。<br>&emsp;&emsp;选择作用的局部区域表示为:<script type="math/tex">S_i = \{x_j|L_{ij}<R_i\}</script>。<br>&emsp;&emsp;显然,<script type="math/tex">x_i</script>属于<script type="math/tex">S_i</script>,参与局部竞争的个体与<script type="math/tex">x_i</script>的差异小于<script type="math/tex">S_i</script>,即竞争发生在类似个体间。由于区域半经受随机数r的影响,使得局部竞争中的胜出者既可能是目前种群中最优的个体,也可能是与差异<script type="math/tex">x_i</script>较小的相对优秀的个体。设置局部最优个体<script type="math/tex">x^*</script>与<script type="math/tex">x_i</script>的差异为：<script type="math/tex">L^* = \lambda \times max\{L_{ij}\}</script>。<br></p><h3 id="理论结论"><a href="#理论结论" class="headerlink" title="理论结论:"></a>理论结论:</h3><p>&emsp;&emsp;显然<script type="math/tex">0 \leq \lambda \leq1</script>,若<script type="math/tex">\lambda=1</script>,<script type="math/tex">x^*</script>胜出的概率<script type="math/tex">p^* = 0</script>;<script type="math/tex">\lambda < 1</script>时,<script type="math/tex">p^* = p(L^* < R_i) = p(\lambda < r)</script>。由于r是[0,1]上的平均分布的随机数,易得<script type="math/tex">p^* = 1 - \lambda</script>。<br>&emsp;&emsp;局部最优解被选中则在比较中胜出的概率与局部最优解在种群中所占的比例无关,而且局部最优个体<script type="math/tex">x^*</script>与<script type="math/tex">x_i</script>的差异较大时,参与竞争的概率较小,有利于保持种群的多样性,即搜索从局部最优跳出的概率更大了。基于个体差异的选择算子,由于父代中每个个体都有一次机会作为局部竞争区域的中心,因此不会发生搜索发散。</p><hr>]]></content>
      <categories>
        <category>毕设</category>
        <category>文献阅读</category>
        <category>算法</category>
        <category>GA</category>
      </categories>
      <tags>
        <tag>毕设</tag>
        <tag>文献阅读</tag>
        <tag>笔记</tag>
        <tag>GA</tag>
      </tags>
  </entry>
</search>
